import numpy
import types
import mosek

def _():
  import types

  class Enum:
    @staticmethod
    def __inst(c,name):
      o = c()
      o.name  = name
      o.value = len(c.__members__)
      c.__members__.append(o)
      setattr(c, name, o)

    @classmethod
    def fromInt(c,value):
      return c.members[value]

    @staticmethod
    def new(name,membernames):
      members = []
      c = type(name, (Enum,),{ '__members__' : members })
      for n in membernames:
        Enum.__inst(c,n)
      return c
    @classmethod
    def members(c):
      return iter(c.__members__)

    def __str__(self):
      return self.__class__.__name__ + "." + self.name
    def __repr__(self):
      return self.__class__.__name__ + "." + self.name
  return Enum

class _monty:
  Enum = _()
  @staticmethod
  def deduceShape(l,dim):
    def _deduceShape(l,dim):
      if dim > 1:
        shplst = [ _deduceShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          shplst[0].append(len(l))
          return shplst[0]
        else:
          raise TypeError("Irregular array shape")
      else:
        return [len(dim)]
    return tuple(reversed(_deduceShape(l,dim)))
  @staticmethod
  def checkShape(l,dim):
    def _checkShape(l,dim):
      if dim > 1:
        shplst = [ _checkShape(i,dim-1) for i in l ]
        if all([shplst[0] == i for i in shplst ]):
          pass
        else:
          raise TypeError("Irregular array shape")
        return len(l)
      else:
        try:
          return len(l)
        except TypeError:
          raise TypeError("Wrong or irregular array shape")
    _checkShape(l,dim)
    return dim

  @staticmethod
  def initJaggedArray(data, nd):
    dims = []
    d = data
    for i in range(nd):
      dims.append(len(d))
      d = d[0]

    res = numpy.zeros(dims,dtype=object)
    res.__setitem__(tuple([ slice(d) for d in dims ]), data)

    return res


  @staticmethod
  def makeJaggedArray(src,ndims,dtype):
    if src is None:
      return None
    elif len(ndims) == 1:
      if ndims[0] == 1:
        r = numpy.zeros((len(src),),dtype=dtype)
        r[:] = src
      else:
        d = _monty.deduceDims(src,ndims[0])
        r = numpy.zeros(d,dtype=dtype)
        r.__setitem__(tuple([slice(None)]*ndims[0]),src) # basically: r[:,...,:] = src
      return r
    elif ndims[0] == 1:
      r = numpy.zeros((len(src),),dtype=numpy.dtype(object))
      # Note: This is a bit tricky to do reliably with numpy as it
      # tends to think we are dealing with multidimensional arrays and
      # explode
      for i,s in enumerate(src):
        r[i] = _monty.makeJaggedArray(s,ndims[1:],dtype)

      #r[:] = [ _monty.makeJaggedArray(s,ndims[1:],dtype) for s in src ]
      return r
    else:
      d = _monty.deduceDims(src,ndims[0])
      def _(src,nd):
        if nd == 0:
          return _monty.makeJaggedArray(src)
        else:
          return [ _(s,nd-1) for s in src ]

      r = numpy.zeros(d,dtype=numpy.dtype(object))
      r.__setitem__(tuple([slice(None)]*ndims[0]),_(src,ndims[0])) # basically: r[:,...,:] = convert(src)
      return r

  @staticmethod
  def copyArray(src,dst,dim):
    if dim == 1:
      src[:] = dst[:]
    else:
      for i in range(len(src)):
        _monty.copyArray(src[i],dst[i],dim-1)
  @staticmethod
  def arg_match_sloppy_array(v,elmmatch,dim,l=None):
    if dim == 0:
      elmmatch(v)
    elif dim == 1:
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      for e in v:
        if not elmmatch(e): return False
      return True
    elif isinstance(v,list) or isinstance(v,numpy.ndarray):
      if l is not None:
        if l != len(v): return False
      elif len(v) == 0: return True
      elif not (isinstance(v[0],list) or isinstance(v[0],numpy.ndarray)): return False

      top_len = len(v[0])
      for e in v:
        if not _monty.arg_match_sloppy_array(e,elmmatch,dim-1,top_len): return False
      return True
    else:
      return False

del _

mosek_fusion_RelationKey=_monty.Enum.new('RelationKey',['EqualsTo','LessThan','GreaterThan','IsFree','InRange'])
mosek_fusion_PSDKey=_monty.Enum.new('PSDKey',['IsSymPSD','IsTrilPSD'])
mosek_fusion_QConeKey=_monty.Enum.new('QConeKey',['InQCone','InRotatedQCone','InPExpCone','InPPowCone','InDExpCone','InDPowCone','InPGeoMeanCone','InDGeoMeanCone','Positive','Negative','Unbounded','Zero','InPSDCone','InSVecPSDCone'])
mosek_fusion_ObjectiveSense=_monty.Enum.new('ObjectiveSense',['Undefined','Minimize','Maximize'])
mosek_fusion_SolutionStatus=_monty.Enum.new('SolutionStatus',['Undefined','Unknown','Optimal','Feasible','Certificate','IllposedCert'])
mosek_fusion_AccSolutionStatus=_monty.Enum.new('AccSolutionStatus',['Anything','Optimal','Feasible','Certificate'])
mosek_fusion_ProblemStatus=_monty.Enum.new('ProblemStatus',['Unknown','PrimalAndDualFeasible','PrimalFeasible','DualFeasible','PrimalInfeasible','DualInfeasible','PrimalAndDualInfeasible','IllPosed','PrimalInfeasibleOrUnbounded'])
mosek_fusion_SolverStatus=_monty.Enum.new('SolverStatus',['OK','Error','LostRace'])
mosek_fusion_SolutionType=_monty.Enum.new('SolutionType',['Default','Basic','Interior','Integer'])
mosek_fusion_StatusKey=_monty.Enum.new('StatusKey',['Unknown','Basic','SuperBasic','OnBound','Infinity'])
mosek_fusion_DJCDomainType=_monty.Enum.new('DJCDomainType',['EqualTo','LessThan','GreaterThan','IsFree','InRange','InQCone','InRotatedQCone','InPExpCone','InPPowCone','InDExpCone','InDPowCone','InOneNormCone','InInfNormCone','InPGeoMeanCone','InDGeoMeanCone','InPSDCone'])
#BEFORE CLASS
def __mk_mosek_fusion_Expression():
 class Expression:
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Expression._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.toString()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Expression._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getND()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Expression._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Expression._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Expression._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.slice(int32,int32)\n\tmosek.fusion.Expression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Expression._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getSize()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Expression._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Expression._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Expression._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.index(int32)\n\tmosek.fusion.Expression.index(array(int32,ndim=1))')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Expression._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Expression._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.pick(array(int32,ndim=1))\n\tmosek.fusion.Expression.pick(array(int32,ndim=2))')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Expression._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getShape()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_Expression._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_Expression._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_Expression._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expression.getDim(int32)')
  def __repr__(self): return 'mosek.fusion.Expression'
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
 return Expression
mosek_fusion_Expression=__mk_mosek_fusion_Expression()
del __mk_mosek_fusion_Expression
#BEFORE CLASS
def __mk_mosek_fusion_Variable():
 class Variable(mosek_fusion_Expression):
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_Variable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_Variable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_Variable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.diag()\n\tmosek.fusion.Variable.diag(int32)')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Variable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.dual()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Variable._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getND()')
  def tril(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_tril_(*args): # 
      return self._tril_(*args)
    elif mosek_fusion_Variable._match_alt_tril_(*args): # 
      return self._tril_alt_(*args)
    else:
      raise ValueError('Invalid argument list tril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.tril()')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_Variable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_Variable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_Variable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.Variable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_Variable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_integer()')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_Variable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.asExpr()')
  def fromTril(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_fromTril_I(*args): # int32
      return self._fromTril_I(*args)
    elif mosek_fusion_Variable._match_alt_fromTril_I(*args): # int32
      return self._fromTril_alt_I(*args)
    else:
      raise ValueError('Invalid argument list fromTril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.fromTril(int32)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Variable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.toString()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Variable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getModel()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Variable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.level()')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_Variable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_Variable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.pick(array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=2))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Variable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Variable._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getSize()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_Variable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.make_continuous()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_Variable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.set_values(array(double,ndim=1),bool)')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_Variable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_Variable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.antidiag()\n\tmosek.fusion.Variable.antidiag(int32)')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_Variable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeContinuous()')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_Variable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.setLevel(array(double,ndim=1))')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_Variable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.values(int32,array(double,ndim=1),bool)')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_Variable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.numInst()')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_Variable._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    elif mosek_fusion_Variable._match_reshape_I(*args): # int32
      return self._reshape_I(*args)
    elif mosek_fusion_Variable._match_alt_reshape_I(*args): # int32
      return self._reshape_alt_I(*args)
    elif mosek_fusion_Variable._match_reshape_II(*args): # int32,int32
      return self._reshape_II(*args)
    elif mosek_fusion_Variable._match_alt_reshape_II(*args): # int32,int32
      return self._reshape_alt_II(*args)
    elif mosek_fusion_Variable._match_reshape_III(*args): # int32,int32,int32
      return self._reshape_III(*args)
    elif mosek_fusion_Variable._match_alt_reshape_III(*args): # int32,int32,int32
      return self._reshape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.reshape(array(int32,ndim=1))\n\tmosek.fusion.Variable.reshape(int32)\n\tmosek.fusion.Variable.reshape(int32,int32)\n\tmosek.fusion.Variable.reshape(int32,int32,int32)')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_Variable._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.remove()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Variable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.getShape()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Variable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.transpose()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Variable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Variable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Variable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_Variable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_Variable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_Variable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_Variable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.index(int32)\n\tmosek.fusion.Variable.index(array(int32,ndim=1))\n\tmosek.fusion.Variable.index(int32,int32)\n\tmosek.fusion.Variable.index(int32,int32,int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Variable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Variable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Variable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.slice(int32,int32)\n\tmosek.fusion.Variable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_Variable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_Variable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Variable.makeInteger()')
  def __repr__(self): return 'mosek.fusion.Variable'
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   pass
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   pass
  @staticmethod
  def _match_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match__3J__(_3))
  @staticmethod
  def _match_alt_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match__3J__(_3))
  def _inst_alt_I_3JI_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3JI_3J(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3JI_3J(self,_0,_1,_2,_3):
   pass
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   pass
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   pass
  @staticmethod
  def _match_fromTril_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_fromTril_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _fromTril_alt_I(self,_t__0):
    return self._fromTril_I(numpy.int32(__0))
  def _fromTril_I(self,_0):
   pass
  @staticmethod
  def _match_tril_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_tril_(*args):
    if len(args) != 0: return False
    return True
  def _tril_alt_(self,):
    return self._tril_()
  def _tril_(self,):
   pass
  @staticmethod
  def _match_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _reshape_alt_III(self,_t__0,_t__1,_t__2):
    return self._reshape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _reshape_III(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _reshape_alt_II(self,_t__0,_t__1):
    return self._reshape_II(numpy.int32(__0),numpy.int32(__1))
  def _reshape_II(self,_0,_1):
   pass
  @staticmethod
  def _match_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _reshape_alt_I(self,_t__0):
    return self._reshape_I(numpy.int32(__0))
  def _reshape_I(self,_0):
   pass
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   pass
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   pass
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   pass
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   pass
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   pass
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   pass
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   pass
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   pass
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   pass
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   pass
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   pass
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   pass
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   pass
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   pass
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
 return Variable
mosek_fusion_Variable=__mk_mosek_fusion_Variable()
del __mk_mosek_fusion_Variable
#BEFORE CLASS
def __mk_mosek_fusion_Parameter():
 class Parameter(mosek_fusion_Expression):
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Parameter._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Parameter._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Parameter._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.slice(int32,int32)\n\tmosek.fusion.Parameter.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def setValue(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_setValue_D(*args): # double
      return self._setValue_D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue_D(*args): # double
      return self._setValue_alt_D(*args)
    elif mosek_fusion_Parameter._match_setValue__3D(*args): # []double
      return self._setValue__3D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue__3D(*args): # []double
      return self._setValue_alt__3D(*args)
    elif mosek_fusion_Parameter._match_setValue__3_5D(*args): # [,]double
      return self._setValue__3_5D(*args)
    elif mosek_fusion_Parameter._match_alt_setValue__3_5D(*args): # [,]double
      return self._setValue_alt__3_5D(*args)
    else:
      raise ValueError('Invalid argument list setValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.setValue(double)\n\tmosek.fusion.Parameter.setValue(array(double,ndim=1))\n\tmosek.fusion.Parameter.setValue(array(double,ndim=2))')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_Parameter._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.isSparse()')
  def getValue(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getValue_(*args): # 
      return self._getValue_(*args)
    elif mosek_fusion_Parameter._match_alt_getValue_(*args): # 
      return self._getValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list getValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getValue()')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_Parameter._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.reshape(array(int32,ndim=1))')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Parameter._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getShape()')
  def getNumNonzero(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getNumNonzero_(*args): # 
      return self._getNumNonzero_(*args)
    elif mosek_fusion_Parameter._match_alt_getNumNonzero_(*args): # 
      return self._getNumNonzero_alt_(*args)
    else:
      raise ValueError('Invalid argument list getNumNonzero('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getNumNonzero()')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_clone_Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Model
      return self._clone_Lmosek_4fusion_4Model_2(*args)
    elif mosek_fusion_Parameter._match_alt_clone_Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Model
      return self._clone_alt_Lmosek_4fusion_4Model_2(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.clone(mosek.fusion.Model)')
  def getAllIndexes(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getAllIndexes__3II(*args): # []int32,int32
      return self._getAllIndexes__3II(*args)
    elif mosek_fusion_Parameter._match_alt_getAllIndexes__3II(*args): # []int32,int32
      return self._getAllIndexes_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list getAllIndexes('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getAllIndexes(array(int32,ndim=1),int32)')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_Parameter._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.asExpr()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Parameter._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getSize()')
  def getSp(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getSp__3JI(*args): # []int64,int32
      return self._getSp__3JI(*args)
    elif mosek_fusion_Parameter._match_alt_getSp__3JI(*args): # []int64,int32
      return self._getSp_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list getSp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getSp(array(int64,ndim=1),int32)')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getIndex_I(*args): # int32
      return self._getIndex_I(*args)
    elif mosek_fusion_Parameter._match_alt_getIndex_I(*args): # int32
      return self._getIndex_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getIndex(int32)')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_Parameter._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getDim(int32)')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Parameter._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getModel()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Parameter._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Parameter._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameter.getND()')
  def __repr__(self): return 'mosek.fusion.Parameter'
  @staticmethod
  def _match_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0))
  @staticmethod
  def _match_alt_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   pass
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   pass
  @staticmethod
  def _match_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  def _getAllIndexes_alt__3II(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = self._getAllIndexes__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getAllIndexes__3II(self,_0,_1):
   pass
  @staticmethod
  def _match_getIndex_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getIndex_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getIndex_alt_I(self,_t__0):
    return self._getIndex_I(numpy.int32(__0))
  def _getIndex_I(self,_0):
   pass
  @staticmethod
  def _match_getSp__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_getSp__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1))
  def _getSp_alt__3JI(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _1 = self._getSp__3JI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getSp__3JI(self,_0,_1):
   pass
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   pass
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   pass
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   pass
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   pass
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   pass
  @staticmethod
  def _match_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  def _getNumNonzero_alt_(self,):
    return self._getNumNonzero_()
  def _getNumNonzero_(self,):
   pass
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   pass
  @staticmethod
  def _match_getValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getValue_(*args):
    if len(args) != 0: return False
    return True
  def _getValue_alt_(self,):
    return self._getValue_()
  def _getValue_(self,):
   pass
  @staticmethod
  def _match_setValue__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_setValue__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  def _setValue_alt__3_5D(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = self._setValue__3_5D(_0)
   return _1
  def _setValue__3_5D(self,_0):
   pass
  @staticmethod
  def _match_setValue__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setValue__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setValue_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setValue__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setValue__3D(self,_0):
   pass
  @staticmethod
  def _match_setValue_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_setValue_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _setValue_alt_D(self,_t__0):
    return self._setValue_D(numpy.float64(__0))
  def _setValue_D(self,_0):
   pass
 return Parameter
mosek_fusion_Parameter=__mk_mosek_fusion_Parameter()
del __mk_mosek_fusion_Parameter
#BEFORE CLASS
def __mk_mosek_fusion_FusionException():
 class FusionException(Exception):
  __slots__ = ['_FusionException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionException.__new__(FusionException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionException
mosek_fusion_FusionException=__mk_mosek_fusion_FusionException()
del __mk_mosek_fusion_FusionException
#BEFORE CLASS
def __mk_mosek_fusion_SolutionError():
 class SolutionError(mosek_fusion_FusionException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionError.ctor()\n\tmosek.fusion.SolutionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SolutionError'
  @staticmethod
  def _ctor_():
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionException._ctor_init_S(self,"Solution is invalid or undefined")
  @staticmethod
  def _ctor_S(msg):
    o = SolutionError.__new__(SolutionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionException._ctor_init_S(self,msg)
 return SolutionError
mosek_fusion_SolutionError=__mk_mosek_fusion_SolutionError()
del __mk_mosek_fusion_SolutionError
#BEFORE CLASS
def __mk_mosek_fusion_UnimplementedError():
 class UnimplementedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnimplementedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnimplementedError'
  @staticmethod
  def _ctor_S(msg):
    o = UnimplementedError.__new__(UnimplementedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnimplementedError
mosek_fusion_UnimplementedError=__mk_mosek_fusion_UnimplementedError()
del __mk_mosek_fusion_UnimplementedError
#BEFORE CLASS
def __mk_mosek_fusion_FatalError():
 class FatalError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FatalError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.FatalError'
  @staticmethod
  def _ctor_S(msg):
    o = FatalError.__new__(FatalError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return FatalError
mosek_fusion_FatalError=__mk_mosek_fusion_FatalError()
del __mk_mosek_fusion_FatalError
#BEFORE CLASS
def __mk_mosek_fusion_UnexpectedError():
 class UnexpectedError(Exception):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4FusionException_2(*args): # mosek.fusion.FusionException
      self._ctor_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):# mosek.fusion.FusionException
      self._ctor_alt_init_Lmosek_4fusion_4FusionException_2(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UnexpectedError.ctor(mosek.fusion.FusionException)\n\tmosek.fusion.UnexpectedError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UnexpectedError'
  @staticmethod
  def _ctor_Lmosek_4fusion_4FusionException_2(e):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_Lmosek_4fusion_4FusionException_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4FusionException_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4FusionException_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4FusionException_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4FusionException_2(self,e):
    self._ctor_init_Lmosek_4fusion_4FusionException_2(e)
  def _ctor_init_Lmosek_4fusion_4FusionException_2(self,e):
   Exception.__init__(self,e._toString_())
  @staticmethod
  def _ctor_S(msg):
    o = UnexpectedError.__new__(UnexpectedError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   Exception.__init__(self,msg)
 return UnexpectedError
mosek_fusion_UnexpectedError=__mk_mosek_fusion_UnexpectedError()
del __mk_mosek_fusion_UnexpectedError
#BEFORE CLASS
def __mk_mosek_fusion_FusionRuntimeException():
 class FusionRuntimeException(Exception):
  __slots__ = ['_FusionRuntimeException__msg']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.FusionRuntimeException.ctor(string)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_FusionRuntimeException._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_FusionRuntimeException._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.FusionRuntimeException.toString()')
  def __repr__(self): return 'mosek.fusion.FusionRuntimeException'
  @staticmethod
  def _ctor_S(msg_):
    o = FusionRuntimeException.__new__(FusionRuntimeException)
    o._ctor_init_S(msg_)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_match_S__(msg_))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg_, = args
    return (__arg_alt_match_S__(msg_))
  def _ctor_alt_init_S(self,msg_):
    self._ctor_init_S(msg_)
  def _ctor_init_S(self,msg_):
   Exception.__init__(self,msg_)
   self.__msg = msg_
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (self.__msg)
 return FusionRuntimeException
mosek_fusion_FusionRuntimeException=__mk_mosek_fusion_FusionRuntimeException()
del __mk_mosek_fusion_FusionRuntimeException
#BEFORE CLASS
def __mk_mosek_fusion_SparseFormatError():
 class SparseFormatError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SparseFormatError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SparseFormatError'
  @staticmethod
  def _ctor_S(msg):
    o = SparseFormatError.__new__(SparseFormatError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SparseFormatError
mosek_fusion_SparseFormatError=__mk_mosek_fusion_SparseFormatError()
del __mk_mosek_fusion_SparseFormatError
#BEFORE CLASS
def __mk_mosek_fusion_SliceError():
 class SliceError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SliceError.ctor()\n\tmosek.fusion.SliceError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SliceError'
  @staticmethod
  def _ctor_():
    o = SliceError.__new__(SliceError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Invalid slice range")
  @staticmethod
  def _ctor_S(msg):
    o = SliceError.__new__(SliceError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SliceError
mosek_fusion_SliceError=__mk_mosek_fusion_SliceError()
del __mk_mosek_fusion_SliceError
#BEFORE CLASS
def __mk_mosek_fusion_UpdateError():
 class UpdateError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.UpdateError.ctor()\n\tmosek.fusion.UpdateError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.UpdateError'
  @staticmethod
  def _ctor_():
    o = UpdateError.__new__(UpdateError)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,"Cannot update parameterized item")
  @staticmethod
  def _ctor_S(msg):
    o = UpdateError.__new__(UpdateError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return UpdateError
mosek_fusion_UpdateError=__mk_mosek_fusion_UpdateError()
del __mk_mosek_fusion_UpdateError
#BEFORE CLASS
def __mk_mosek_fusion_SetDefinitionError():
 class SetDefinitionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SetDefinitionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.SetDefinitionError'
  @staticmethod
  def _ctor_S(msg):
    o = SetDefinitionError.__new__(SetDefinitionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return SetDefinitionError
mosek_fusion_SetDefinitionError=__mk_mosek_fusion_SetDefinitionError()
del __mk_mosek_fusion_SetDefinitionError
#BEFORE CLASS
def __mk_mosek_fusion_OptimizeError():
 class OptimizeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.OptimizeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.OptimizeError'
  @staticmethod
  def _ctor_S(msg):
    o = OptimizeError.__new__(OptimizeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return OptimizeError
mosek_fusion_OptimizeError=__mk_mosek_fusion_OptimizeError()
del __mk_mosek_fusion_OptimizeError
#BEFORE CLASS
def __mk_mosek_fusion_NameError():
 class NameError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.NameError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.NameError'
  @staticmethod
  def _ctor_S(msg):
    o = NameError.__new__(NameError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return NameError
mosek_fusion_NameError=__mk_mosek_fusion_NameError()
del __mk_mosek_fusion_NameError
#BEFORE CLASS
def __mk_mosek_fusion_DeletionError():
 class DeletionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DeletionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DeletionError'
  @staticmethod
  def _ctor_S(msg):
    o = DeletionError.__new__(DeletionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DeletionError
mosek_fusion_DeletionError=__mk_mosek_fusion_DeletionError()
del __mk_mosek_fusion_DeletionError
#BEFORE CLASS
def __mk_mosek_fusion_ModelError():
 class ModelError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ModelError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ModelError'
  @staticmethod
  def _ctor_S(msg):
    o = ModelError.__new__(ModelError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ModelError
mosek_fusion_ModelError=__mk_mosek_fusion_ModelError()
del __mk_mosek_fusion_ModelError
#BEFORE CLASS
def __mk_mosek_fusion_MatrixError():
 class MatrixError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.MatrixError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.MatrixError'
  @staticmethod
  def _ctor_S(msg):
    o = MatrixError.__new__(MatrixError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return MatrixError
mosek_fusion_MatrixError=__mk_mosek_fusion_MatrixError()
del __mk_mosek_fusion_MatrixError
#BEFORE CLASS
def __mk_mosek_fusion_DimensionError():
 class DimensionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DimensionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DimensionError'
  @staticmethod
  def _ctor_S(msg):
    o = DimensionError.__new__(DimensionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DimensionError
mosek_fusion_DimensionError=__mk_mosek_fusion_DimensionError()
del __mk_mosek_fusion_DimensionError
#BEFORE CLASS
def __mk_mosek_fusion_LengthError():
 class LengthError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LengthError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.LengthError'
  @staticmethod
  def _ctor_S(msg):
    o = LengthError.__new__(LengthError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return LengthError
mosek_fusion_LengthError=__mk_mosek_fusion_LengthError()
del __mk_mosek_fusion_LengthError
#BEFORE CLASS
def __mk_mosek_fusion_RangeError():
 class RangeError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RangeError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.RangeError'
  @staticmethod
  def _ctor_S(msg):
    o = RangeError.__new__(RangeError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return RangeError
mosek_fusion_RangeError=__mk_mosek_fusion_RangeError()
del __mk_mosek_fusion_RangeError
#BEFORE CLASS
def __mk_mosek_fusion_IndexError():
 class IndexError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IndexError'
  @staticmethod
  def _ctor_S(msg):
    o = IndexError.__new__(IndexError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IndexError
mosek_fusion_IndexError=__mk_mosek_fusion_IndexError()
del __mk_mosek_fusion_IndexError
#BEFORE CLASS
def __mk_mosek_fusion_DomainError():
 class DomainError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.DomainError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.DomainError'
  @staticmethod
  def _ctor_S(msg):
    o = DomainError.__new__(DomainError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return DomainError
mosek_fusion_DomainError=__mk_mosek_fusion_DomainError()
del __mk_mosek_fusion_DomainError
#BEFORE CLASS
def __mk_mosek_fusion_ValueConversionError():
 class ValueConversionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ValueConversionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ValueConversionError'
  @staticmethod
  def _ctor_S(msg):
    o = ValueConversionError.__new__(ValueConversionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ValueConversionError
mosek_fusion_ValueConversionError=__mk_mosek_fusion_ValueConversionError()
del __mk_mosek_fusion_ValueConversionError
#BEFORE CLASS
def __mk_mosek_fusion_ParameterError():
 class ParameterError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ParameterError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ParameterError'
  @staticmethod
  def _ctor_S(msg):
    o = ParameterError.__new__(ParameterError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ParameterError
mosek_fusion_ParameterError=__mk_mosek_fusion_ParameterError()
del __mk_mosek_fusion_ParameterError
#BEFORE CLASS
def __mk_mosek_fusion_ExpressionError():
 class ExpressionError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExpressionError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.ExpressionError'
  @staticmethod
  def _ctor_S(msg):
    o = ExpressionError.__new__(ExpressionError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return ExpressionError
mosek_fusion_ExpressionError=__mk_mosek_fusion_ExpressionError()
del __mk_mosek_fusion_ExpressionError
#BEFORE CLASS
def __mk_mosek_fusion_IOError():
 class IOError(mosek_fusion_FusionRuntimeException):
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IOError.ctor(string)')
  def __repr__(self): return 'mosek.fusion.IOError'
  @staticmethod
  def _ctor_S(msg):
    o = IOError.__new__(IOError)
    o._ctor_init_S(msg)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_match_S__(msg))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    msg, = args
    return (__arg_alt_match_S__(msg))
  def _ctor_alt_init_S(self,msg):
    self._ctor_init_S(msg)
  def _ctor_init_S(self,msg):
   mosek_fusion_FusionRuntimeException._ctor_init_S(self,msg)
 return IOError
mosek_fusion_IOError=__mk_mosek_fusion_IOError()
del __mk_mosek_fusion_IOError
#BEFORE CLASS
def __mk_mosek_fusion_Disjunction():
 class Disjunction(object):
  __slots__ = ['_Disjunction__id']
  def __repr__(self): return 'mosek.fusion.Disjunction'
  @staticmethod
  def _ctor_J(id):
    o = Disjunction.__new__(Disjunction)
    o._ctor_init_J(id)
    return o
  @staticmethod
  def __match_ctor_J(*args):
    if len(args) != 1: return False
    id, = args
    return (__arg_match_J__(id))
  @staticmethod
  def __match_alt_ctor_J(*args):
    if len(args) != 1: return False
    id, = args
    return (__arg_alt_match_J__(id))
  def _ctor_alt_init_J(self,id):
    self._ctor_init_J(numpy.int64(id))
  def _ctor_init_J(self,id):
   (self.__id) = id
 return Disjunction
mosek_fusion_Disjunction=__mk_mosek_fusion_Disjunction()
del __mk_mosek_fusion_Disjunction
#BEFORE CLASS
def __mk_mosek_fusion_Term():
 class Term(object):
  __slots__ = ['_domains','_exprs']
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Term._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Term._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Term.size()')
  def __repr__(self): return 'mosek.fusion.Term'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d):
    o = Term.__new__(Term)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    e,d, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4DJCDomain_2__(d))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    e,d, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4DJCDomain_2__(d))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d):
   self._exprs = numpy.array([e], dtype=numpy.dtype(object))
   self._domains = numpy.array([d], dtype=numpy.dtype(object))
  @staticmethod
  def _ctor__3Lmosek_4fusion_4SimpleTerm_2(t):
    o = Term.__new__(Term)
    o._ctor_init__3Lmosek_4fusion_4SimpleTerm_2(t)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    t, = args
    return (__arg_match__3Lmosek_4fusion_4SimpleTerm_2__(t))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    t, = args
    return (__arg_alt_match__3Lmosek_4fusion_4SimpleTerm_2__(t))
  def _ctor_alt_init__3Lmosek_4fusion_4SimpleTerm_2(self,t):
    self._ctor_init__3Lmosek_4fusion_4SimpleTerm_2(numpy.array(t,dtype=numpy.dtype(object)))
  def _ctor_init__3Lmosek_4fusion_4SimpleTerm_2(self,t):
   _0=int((t).shape[0])
   self._exprs = numpy.ndarray((_0,), dtype=numpy.dtype(object))
   self._domains = numpy.ndarray((_0,), dtype=numpy.dtype(object))
   for _1 in range(0,_0):
    self._exprs[_1] = (t[_1]._exprs)[0]
    self._domains[_1] = (t[_1]._domains)[0]
  def _numaccterms_alt_(self,):
    return self._numaccterms_()
  def _numaccterms_(self,):
   _0=0
   for _1 in range(0,int((self._domains).shape[0])):
    _0 += self._domains[_1]._numaccterms_()
   return numpy.int32(_0)
  def _numaccrows_alt_(self,):
    return self._numaccrows_()
  def _numaccrows_(self,):
   _0=0
   for _1 in range(0,int((self._domains).shape[0])):
    _0 += self._domains[_1]._numaccrows_()
   return numpy.int32(_0)
  def _num_alt_(self,):
    return self._num_()
  def _num_(self,):
   return numpy.int32(int((self._domains).shape[0]))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   _0=0
   for _1 in range(0,int((self._domains).shape[0])):
    _0 += self._domains[_1]._size_()
   return numpy.int32(_0)
 return Term
mosek_fusion_Term=__mk_mosek_fusion_Term()
del __mk_mosek_fusion_Term
#BEFORE CLASS
def __mk_mosek_fusion_SimpleTerm():
 class SimpleTerm(mosek_fusion_Term):
  def __repr__(self): return 'mosek.fusion.SimpleTerm'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d):
    o = SimpleTerm.__new__(SimpleTerm)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    e,d, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4DJCDomain_2__(d))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(*args):
    if len(args) != 2: return False
    e,d, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4DJCDomain_2__(d))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(e,d)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d):
   mosek_fusion_Term._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(self,e,d)
 return SimpleTerm
mosek_fusion_SimpleTerm=__mk_mosek_fusion_SimpleTerm()
del __mk_mosek_fusion_SimpleTerm
#BEFORE CLASS
def __mk_mosek_fusion_DJCDomain():
 class DJCDomain(object):
  __slots__ = ['dom','conedim','shape','par','b']
  def size(self,*args):
    if False: pass
    elif mosek_fusion_DJCDomain._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_DJCDomain._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DJCDomain.size()')
  def __repr__(self): return 'mosek.fusion.DJCDomain'
  @staticmethod
  def _ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(b_,par_,shape_,dom_):
    o = DJCDomain.__new__(DJCDomain)
    o._ctor_init__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(b_,par_,shape_,dom_)
    return o
  @staticmethod
  def __match_ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(*args):
    if len(args) != 4: return False
    b_,par_,shape_,dom_, = args
    return (__arg_match__3D__(b_) and __arg_match__3D__(par_) and __arg_match__3I__(shape_) and __arg_match_Emosek_4fusion_4DJCDomainType_2__(dom_))
  @staticmethod
  def __match_alt_ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(*args):
    if len(args) != 4: return False
    b_,par_,shape_,dom_, = args
    return (__arg_alt_match__3D__(b_) and __arg_alt_match__3D__(par_) and __arg_alt_match__3I__(shape_) and __arg_alt_match_Emosek_4fusion_4DJCDomainType_2__(dom_))
  def _ctor_alt_init__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(self,b_,par_,shape_,dom_):
    self._ctor_init__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(numpy.array(b_,dtype=numpy.dtype(numpy.float64)),numpy.array(par_,dtype=numpy.dtype(numpy.float64)),numpy.array(shape_,dtype=numpy.dtype(numpy.int32)),dom_)
  def _ctor_init__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(self,b_,par_,shape_,dom_):
   self.b = b_
   self.par = par_
   self.shape = shape_
   self.dom = dom_
   self.conedim = (int((shape_).shape[0]) - 1)
  @staticmethod
  def _ctor__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(b_,par_,shape_,conedim_,dom_):
    o = DJCDomain.__new__(DJCDomain)
    o._ctor_init__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(b_,par_,shape_,conedim_,dom_)
    return o
  @staticmethod
  def __match_ctor__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(*args):
    if len(args) != 5: return False
    b_,par_,shape_,conedim_,dom_, = args
    return (__arg_match__3D__(b_) and __arg_match__3D__(par_) and __arg_match__3I__(shape_) and __arg_match_I__(conedim_) and __arg_match_Emosek_4fusion_4DJCDomainType_2__(dom_))
  @staticmethod
  def __match_alt_ctor__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(*args):
    if len(args) != 5: return False
    b_,par_,shape_,conedim_,dom_, = args
    return (__arg_alt_match__3D__(b_) and __arg_alt_match__3D__(par_) and __arg_alt_match__3I__(shape_) and __arg_alt_match_I__(conedim_) and __arg_alt_match_Emosek_4fusion_4DJCDomainType_2__(dom_))
  def _ctor_alt_init__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(self,b_,par_,shape_,conedim_,dom_):
    self._ctor_init__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(numpy.array(b_,dtype=numpy.dtype(numpy.float64)),numpy.array(par_,dtype=numpy.dtype(numpy.float64)),numpy.array(shape_,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim_),dom_)
  def _ctor_init__3D_3D_3IIEmosek_4fusion_4DJCDomainType_2(self,b_,par_,shape_,conedim_,dom_):
   self.b = b_
   self.par = par_
   self.shape = shape_
   self.dom = dom_
   self.conedim = conedim_
  def _numaccterms_alt_(self,):
    return self._numaccterms_()
  def _numaccterms_(self,):
   if (self.dom==mosek.fusion.DJCDomainType.InRange): # src/fusion/Disjunction.mbi:177:12-40
    return numpy.int32(2)
   else:
    return numpy.int32(1)
  def _numaccrows_alt_(self,):
    return self._numaccrows_()
  def _numaccrows_(self,):
   if (self.dom==mosek.fusion.DJCDomainType.InRange): # src/fusion/Disjunction.mbi:171:12-40
    return numpy.int32((self._size_() * 2))
   else:
    return numpy.int32(self._size_())
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   _0=1
   _0 = fragments._c_closure_0(_0,self.shape) # src/fusion/Disjunction.mbi:167:19-61
   _0 = numpy.int32(_0) # postprocess
   return numpy.int32(_0)
 return DJCDomain
mosek_fusion_DJCDomain=__mk_mosek_fusion_DJCDomain()
del __mk_mosek_fusion_DJCDomain
#BEFORE CLASS
def __mk_mosek_fusion_DJC():
 class DJC(object):
  @staticmethod
  def AND(*args):
    if False: pass
    elif mosek_fusion_DJC._match_AND__3Lmosek_4fusion_4SimpleTerm_2(*args): # []mosek.fusion.SimpleTerm
      return mosek_fusion_DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_alt_AND__3Lmosek_4fusion_4SimpleTerm_2(*args): # []mosek.fusion.SimpleTerm
      return mosek_fusion_DJC._AND_alt__3Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_AND_Lmosek_4fusion_4SimpleTerm_2(*args): # mosek.fusion.SimpleTerm
      return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_alt_AND_Lmosek_4fusion_4SimpleTerm_2(*args): # mosek.fusion.SimpleTerm
      return mosek_fusion_DJC._AND_alt_Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args): # mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm
      return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_alt_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args): # mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm
      return mosek_fusion_DJC._AND_alt_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args): # mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm
      return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args)
    elif mosek_fusion_DJC._match_alt_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args): # mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm
      return mosek_fusion_DJC._AND_alt_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args)
    else:
      raise ValueError('Invalid argument list AND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DJC.AND(array(mosek.fusion.SimpleTerm,ndim=1))\n\tmosek.fusion.DJC.AND(mosek.fusion.SimpleTerm)\n\tmosek.fusion.DJC.AND(mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm)\n\tmosek.fusion.DJC.AND(mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm,mosek.fusion.SimpleTerm)')
  @staticmethod
  def term(*args):
    if False: pass
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinearDomain
      return mosek_fusion_DJC._term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.LinearDomain
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return mosek_fusion_DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.RangeDomain
      return mosek_fusion_DJC._term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Variable,mosek.fusion.RangeDomain
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_DJC._match_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return mosek_fusion_DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_DJC._match_alt_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return mosek_fusion_DJC._term_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list term('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DJC.term(mosek.fusion.Variable,mosek.fusion.LinearDomain)\n\tmosek.fusion.DJC.term(mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.DJC.term(mosek.fusion.Variable,mosek.fusion.RangeDomain)\n\tmosek.fusion.DJC.term(mosek.fusion.Expression,mosek.fusion.RangeDomain)')
  def __repr__(self): return 'mosek.fusion.DJC'
  @staticmethod
  def _match_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4SimpleTerm_2__(_0) and __arg_match_Lmosek_4fusion_4SimpleTerm_2__(_1) and __arg_match_Lmosek_4fusion_4SimpleTerm_2__(_2))
  @staticmethod
  def _match_alt_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_0) and __arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_1) and __arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_2))
  @staticmethod
  def _AND_alt_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_t__0,_t__1,_t__2):
    return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_0,_1,_2)
  @staticmethod
  def _AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_0,_1,_2):
   return (mosek.fusion.DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(numpy.array([_0,_1,_2], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4SimpleTerm_2__(_0) and __arg_match_Lmosek_4fusion_4SimpleTerm_2__(_1))
  @staticmethod
  def _match_alt_AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_0) and __arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_1))
  @staticmethod
  def _AND_alt_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_t__0,_t__1):
    return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_0,_1)
  @staticmethod
  def _AND_Lmosek_4fusion_4SimpleTerm_2Lmosek_4fusion_4SimpleTerm_2(_0,_1):
   return (mosek.fusion.DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(numpy.array([_0,_1], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_AND_Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SimpleTerm_2__(_0))
  @staticmethod
  def _match_alt_AND_Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(_0))
  @staticmethod
  def _AND_alt_Lmosek_4fusion_4SimpleTerm_2(_t__0):
    return mosek_fusion_DJC._AND_Lmosek_4fusion_4SimpleTerm_2(_0)
  @staticmethod
  def _AND_Lmosek_4fusion_4SimpleTerm_2(_0):
   return (mosek.fusion.DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(numpy.array([_0], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_AND__3Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4SimpleTerm_2__(_0))
  @staticmethod
  def _match_alt_AND__3Lmosek_4fusion_4SimpleTerm_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4SimpleTerm_2__(_0))
  @staticmethod
  def _AND_alt__3Lmosek_4fusion_4SimpleTerm_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_DJC._AND__3Lmosek_4fusion_4SimpleTerm_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _AND__3Lmosek_4fusion_4SimpleTerm_2(_0):
   return (mosek_fusion_Term._ctor__3Lmosek_4fusion_4SimpleTerm_2(_0))
  @staticmethod
  def _match_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_t__0,_t__1):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  @staticmethod
  def _term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1):
   if ((_1._sparsity) is not None): # src/fusion/Disjunction.mbi:70:12-32
    raise mosek_fusion_DomainError._ctor_S("Sparse domain is not acceptable in disjunctive constraints")
   if (_1._cardinal_flag): # src/fusion/Disjunction.mbi:72:12-29
    raise mosek_fusion_DomainError._ctor_S("Integer domain is not acceptable in disjunctive constraints")
   _2=(_1._lb)
   _3=(_1._ub)
   _4=_0._getShape_()
   _5=_0._getSize_()
   _6=(_1._shape)
   if (_6 is None): # src/fusion/Disjunction.mbi:83:12-25
    _6 = _4
   else:
    if (int((_6).shape[0])!=int((_4).shape[0])): # src/fusion/Disjunction.mbi:85:17-42
     raise mosek_fusion_DomainError._ctor_S("Mismatching shapes")
    else:
     for _9 in range(0,int((_6).shape[0])):
      if (_6[_9]!=_4[_9]): # src/fusion/Disjunction.mbi:89:16-37
       raise mosek_fusion_DomainError._ctor_S("Mismatching shapes")
   if (_1._scalable): # src/fusion/Disjunction.mbi:93:16-28
    _7 = numpy.array([_2[0] for _10 in range(0,_5)], dtype=numpy.dtype(numpy.float64))
    _8 = numpy.array([_3[0] for _11 in range(0,_5)], dtype=numpy.dtype(numpy.float64))
   else:
    _7 = _2
    _8 = _3
   return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_7,_8,_6,mosek.fusion.DJCDomainType.InRange)))
  @staticmethod
  def _match_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_t__0,_t__1):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  @staticmethod
  def _term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4RangeDomain_2(_0,_1):
   return (mosek.fusion.DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0._asExpr_(),_1))
  @staticmethod
  def _match_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_t__0,_t__1):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  @staticmethod
  def _term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1):
   if ((_1._sparsity) is not None): # src/fusion/Disjunction.mbi:35:12-32
    raise mosek_fusion_DomainError._ctor_S("Sparse domain is not acceptable in disjunctive constraints")
   if (_1._cardinal_flag): # src/fusion/Disjunction.mbi:37:12-29
    raise mosek_fusion_DomainError._ctor_S("Integer domain is not acceptable in disjunctive constraints")
   _2=(_1._bnd)
   _3=_0._getShape_()
   _4=_0._getSize_()
   _5=(_1._shape)
   if (_5 is None): # src/fusion/Disjunction.mbi:46:12-25
    _5 = _3
   else:
    if (int((_5).shape[0])!=int((_3).shape[0])): # src/fusion/Disjunction.mbi:48:17-42
     raise mosek_fusion_DomainError._ctor_S("Mismatching shapes")
    else:
     for _7 in range(0,int((_5).shape[0])):
      if (_5[_7]!=_3[_7]): # src/fusion/Disjunction.mbi:52:16-37
       raise mosek_fusion_DomainError._ctor_S("Mismatching shapes")
   if ((_1._bnd) is None): # src/fusion/Disjunction.mbi:56:16-31
    _6 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   elif (_1._scalable): # src/fusion/Disjunction.mbi:57:16-28
    _6 = numpy.array([_2[0] for _8 in range(0,_4)], dtype=numpy.dtype(numpy.float64))
   elif (_1._empty): # src/fusion/Disjunction.mbi:58:16-25
    _6 = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   else:
    _6 = _2
   if ((_1._key)==mosek.fusion.RelationKey.EqualsTo): # src/fusion/Disjunction.mbi:61:16-47
    return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_6,None,_5,mosek.fusion.DJCDomainType.EqualTo)))
   elif ((_1._key)==mosek.fusion.RelationKey.LessThan): # src/fusion/Disjunction.mbi:62:16-47
    return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_6,None,_5,mosek.fusion.DJCDomainType.LessThan)))
   elif ((_1._key)==mosek.fusion.RelationKey.GreaterThan): # src/fusion/Disjunction.mbi:63:16-50
    return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_6,None,_5,mosek.fusion.DJCDomainType.GreaterThan)))
   elif ((_1._key)==mosek.fusion.RelationKey.IsFree): # src/fusion/Disjunction.mbi:64:16-45
    return (mosek_fusion_SimpleTerm._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4DJCDomain_2(_0,mosek_fusion_DJCDomain._ctor__3D_3D_3IEmosek_4fusion_4DJCDomainType_2(_6,None,_5,mosek.fusion.DJCDomainType.IsFree)))
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Invalid linear domain")
  @staticmethod
  def _match_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _term_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_t__0,_t__1):
    return mosek_fusion_DJC._term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  @staticmethod
  def _term_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4LinearDomain_2(_0,_1):
   return (mosek.fusion.DJC._term_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0._asExpr_(),_1))
 return DJC
mosek_fusion_DJC=__mk_mosek_fusion_DJC()
del __mk_mosek_fusion_DJC
def __mk_mosek_fusion_BaseModel():
  import threading
  import mosek
  import mosek.fusion
  import numpy
  
  class BaseModel(object):
    _lock = threading.Lock()
    _global_env = None
    _global_env_counter = 0
  
    @classmethod
    def _globalEnv(self):
      self._lock.acquire()
      try:
        if BaseModel._global_env is None:
          try:
            env = mosek.Env(globalenv=True)
            BaseModel._global_env = env
            BaseModel._global_env_counter += 1
          except mosek.Exception as e:
            raise UnexpectedError(e)
        return BaseModel._global_env
      finally:
        self._lock.release()
  
    @classmethod
    def _env_1putlicensecode__3I(self,code):
      self._globalEnv().putlicensecode(code)
  
    @classmethod
    def _env_1putlicensepath_S(self,path):
      self._globalEnv().putlicensepath(path)
  
    @classmethod
    def _env_1putlicensewait_Z(self,yn):
      if yn:
        self._globalEnv().putlicensewait(1)
      else:
        self._globalEnv().putlicensewait(0)
  
    @classmethod
    def _env_1getversion_(self):
      return ".".join([str(_) for _ in mosek.Env.getversion()])
  
    def __callback(self,callbackkey,dinf,iinf,liinf):
      if self.__user_cb is not None:
        try:
          if self.__user_cb(callbackkey,dinf,iinf,liinf):
            self.__break = True
        except:
          self.__break = True
      if self.__user_pgs is not None:
        try:
          if self.__user_pgs(callbackkey):
            self.__break = True
        except:
          self.__break = True
      return 1 if self.__break else 0
  
    def _ctor_init_SS(self,name,licfile):
      env = self._globalEnv()
      self.__modelname = name
      self.__break = False
      task = mosek.Task(self._global_env, 0, 0);
      self.__user_cb = None
      self.__user_pgs = None
      finished = False
      try:
        task.putintparam(mosek.iparam.log_expand,0);
        task.putintparam(mosek.iparam.remove_unused_solutions,1);
        self.__task = task
        if name is not None:
          task.puttaskname(name)
  
        self._synched = mosek_fusion_SolutionStatus.Optimal;
  
        self._sol_itr = None
        self._sol_bas = None
        self._sol_itg = None
  
        self.__objname = None
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def _ctor_init_Lmosek_4fusion_4BaseModel_2(self,m):
      env = self._globalEnv()
      self.__modelname = m.__modelname
      self.__break = False
      self.__user_cb = None
      self.__user_pgs = None
      task = mosek.Task(m.__task)
      finished = False
      try:
        self.__task = task
        self._synched = m._synched
  
        self._sol_itr = m._sol_itr._clone_() if m._sol_itr is not None else None
        self._sol_bas = m._sol_bas._clone_() if m._sol_bas is not None else None
        self._sol_itg = m._sol_itg._clone_() if m._sol_itg is not None else None
  
        self.__objname = m.__objname
  
        # handler for log output.
        def loghandler(text):
          if self.__logwriter is not None:
            self.__logwriter.write(text)
            self.__logwriter.flush()
        self.__loghandler = loghandler
        self.__logwriter = None
  
        task.set_Stream(mosek.streamtype.log,loghandler)
        task.set_InfoCallback(self.__callback)
        finished = True
      finally:
        if not finished:
          self.__task.__del__()
          self.__task = None
          BaseModel._global_env_counter -= 1
  
    def __del__(self):
        lock = self._lock
        if hasattr(self,'_BaseModel__task'):
          lock.acquire()
          try:
            task = self.__task
            BaseModel._global_env_counter -= 1
            task.__del__()
  
            for a in self.__class__.__slots__ + ['_sol_itr','_sol_bas','_sol_itg',
                                                 '_BaseModel__user_cb','_BaseModel__user_pgs','_BaseModel__loghandler','_BaseModel__logwriter','_BaseModel__task']:
              try: delattr(self,a)
              except AttributeError: pass
          finally:
            lock.release()
  
    def __enter__(self):
      return self
    def __exit__(self,exc_type,exc_val,exc_tb):
      self.__del__()
    def _dispose_(self):
      self.__del__()
  
    def _task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,handler):
      self.__user_cb = handler
    def _task_1setCallbackHandler_LSystem_4CallbackHandler_2(self,handler):
      self.__user_pgs = handler
  
    def _task_1setLogHandler_LSystem_4StreamWriter_2(self,handler):
      """
      Set the object to handle log output from the solver.
  
      The handler object must have a write method accepting a string.
      """
      self.__logwriter = handler
  
    def _task_1put_1param_SS(self,name,value):
      self.__task.putnastrparam(name,value)
    def _task_1put_1param_SD(self,name,value):
      self.__task.putnadouparam(name,value)
    def _task_1put_1param_SI(self,name,value):
      self.__task.putnaintparam(name,value)
  
    def _task_1get_1dinf_S(self,name):
      key = mosek_fusion_SolverInfo._getdouinf(name)
      if key is None:
        raise NameError("Invalid double info name '%s'" % name)
      else:
        return self.__task.getdouinf(key)
  
    def _task_1get_1iinf_S(self,name):
      key = mosek_fusion_SolverInfo._getintinf(name)
      if key is None:
        raise NameError("Invalid integer info name '%s'" % name)
      else:
        return self.__task.getintinf(key)
  
    def _task_1get_1liinf_S(self,name):
      key = mosek_fusion_SolverInfo._getlintinf(name)
      if key is None:
        raise NameError("Invalid long integer info name '%s'" % name)
      else:
        return self.__task.getlintinf(key)
  
    def _numVariables_ (self):
      return len(self.__vars)
    def _numConstraints_ (self):
      return len(self.__cons)
  
    @staticmethod
    def __convert_names(names):
      namelist = None
      if names is not None:
        namelist = []
        namedaxisidxs = []
        for axisi,nl in enumerate(names):
          if nl is not None:
            namelist.extend(nl)
            namedaxisidxs.append(axisi)
      else:
        namelist = None
        namedaxisidxs = None
  
      return namedaxisidxs,namelist
    def _task_1format_1djc_1names__3JS_3I_3_3S(self,sub,fmt,dims,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generatedjcnames(sub,fmt,dims,None,namedaxisidxs,namelist)
    def _task_1format_1acc_1names__3JS_3I_3_3S(self,sub,fmt,dims,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generateaccnames(sub,fmt,dims,None,namedaxisidxs,namelist)
    def _task_1format_1var_1names__3IS_3I_3J_3_3S(self,subj,fmt,dims,sp,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generatevarnames(subj,fmt,dims,sp,namedaxisidxs,namelist)
    def _task_1format_1barvar_1names__3IS_3I_3_3S(self,subj,fmt,dims,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generatebarvarnames(subj,fmt,dims,None,namedaxisidxs,namelist)
    def _task_1format_1con_1names__3IS_3I_3J_3_3S(self,subj,fmt,dims,sp,names):
      namedaxisidxs,namelist = self.__convert_names(names)
      self.__task.generateconnames(subj,fmt,dims,sp,namedaxisidxs,namelist)
  
    def _task_1con_1name_IS(self,idx,name): self.__task.putconname(idx,name)
    def _task_1var_1name_IS(self,idx, name): self.__task.putvarname(idx,name)
    def _task_1acc_1name_JS(self,idx, name): self.__task.putaccname(idx,name)
    def _task_1djc_1name_JS(self,idx, name): self.__task.putdjcname(idx,name)
    def _task_1barvar_1name_IS(self,idx, name): self.__task.putbarvarname(idx,name)
  
    def _task_1numcon_(self):
      return self.__task.getnumcon()
    def _task_1numvar_(self):
      return self.__task.getnumvar()
    def _task_1numacc_(self):
      return self.__task.getnumacc()
    def _task_1numafe_(self):
      return self.__task.getnumafe()
    def _task_1numdjc_(self):
      return self.__task.getnumdjc()
  
    def __task_putvarboundlist(self,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putvarboundlist(idxs,bka,bl,bu)
  
    def __task_putconboundlist(self,idxs,bl,bu,bk):
      num = len(idxs)
      if bl is None: bl = numpy.zeros(num,numpy.float64)
      if bu is None: bu = numpy.zeros(num,numpy.float64)
  
      bka = [bk] * num
      self.__task.putconboundlist(idxs,bka,bl,bu)
  
    def _task_1con_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.fx);
  
    def _task_1con_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.lo);
  
    def _task_1con_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putconboundlist( idxs, rhs, rhs, mosek.boundkey.up);
  
    def _task_1con_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putconboundlist( idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1con_1putboundlist_1fr__3I(self,idxs):
      self.__task_putconboundlist( idxs, None, None, mosek.boundkey.fr);
  
  
    def _task_1var_1putboundlist_1fx__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.fx);
  
    def _task_1var_1putboundlist_1lo__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.lo);
  
    def _task_1var_1putboundlist_1up__3I_3D(self,idxs, rhs):
      self.__task_putvarboundlist( idxs, rhs, rhs, mosek.boundkey.up);
  
    def _task_1var_1putboundlist_1ra__3I_3D_3D(self,idxs, lb, ub):
      self.__task_putvarboundlist( idxs, lb, ub, mosek.boundkey.ra);
  
    def _task_1var_1putboundlist_1fr__3I(self,idxs):
      self.__task_putvarboundlist( idxs, None, None, mosek.boundkey.fr);
  
    def _task_1var_1putintlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_int] * len(idxs))
    def _task_1var_1putcontlist__3I(self,idxs):
      self.__task.putvartypelist(idxs,[mosek.variabletype.type_cont] * len(idxs))
  
  
    def _task_1task_1optimize_ (self):
      try:
        self.__task.optimize()
        if self.__logwriter is not None:
          self.__task.solutionsummary(streamtype.log)
      except mosek.Error as e:
        raise OptimizeError("Error occurred while optimizing")
  
    def __task_appendvars(self,num):
      idx = self.__task.getnumvar()
      self.__task.appendvars(num)
      return idx
  
    def __task_appendcons(self,num):
      idx = self.__task.getnumcon()
      self.__task.appendcons(num)
      return idx
  
    def _task_1append_1var_I(self,num):
      return self.__task_appendvars(num)
  
    def _task_1append_1con_I(self,num):
      return self.__task_appendcons(num)
  
    # def _task_1append_1zerocones_I(self, numcone):
    #   self.__task.appendconesseq([mosek.conetype.zero for i in range(numcone)], numpy.zeros(numcone),numpy.zeros(numcone,int), 0)
  
    # def _task_1clear_1cones__3I(self, idxs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.zero, 0.0, 0,[])
  
    # def _task_1put_1zerocones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.zero, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1quadcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.quad, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1rquadcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.rquad, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1pexpcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.pexp, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1ppowcones__3III_3I_3D(self, idxs, conesize, numcone, membs, alpha):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.ppow, alpha[i], membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1dexpcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.dexp, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1dpowcones__3III_3I_3D(self, idxs, conesize, numcone, membs, alpha):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.dpow, alpha[i], membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1onenormcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.onenrm, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1infnormcones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.infnrm, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1pgeomeancones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.pgeomean, 0.0, membs[i*conesize:(i+1)*conesize])
  
    # def _task_1put_1dgeomeancones__3III_3I(self, idxs, conesize, numcone, membs):
    #   for i,k in enumerate(idxs):
    #     self.__task.putcone(k,mosek.conetype.dgeomean, 0.0, membs[i*conesize:(i+1)*conesize])
  
    def _task_1putarowlist__3I_3J_3I_3D(self,sub, ptrb, subj, cof):
      num   = len(sub)
      self.__task.putarowlist(sub, ptrb[:-1], ptrb[1:], subj, cof);
  
    def _task_1cleararowlist__3I(self,sub):
      num  = len(sub)
      ptr = numpy.zeros(num,dtype=numpy.int64)
      self.__task.putarowlist(sub, ptr, ptr, numpy.zeros(0,dtype=numpy.int32), numpy.zeros(0,dtype=numpy.float64))
  
      # This is probably awfully slow
      nnz   = self.__task.getnumbaranz()
      if nnz > 0:
        idxij = numpy.zeros(nnz,dtype=numpy.int64)
        self.__task.getbarasparsity(idxij)
        sub = set(sub)
        for idx in idxij:
          i,j = self.__task.getbaraidxij(idx)
          if i in sub:
            self.__task.putbaraij(i,j,[],[])
  
    def _task_1clearacollist__3I(self,sub):
      num  = len(sub)
      ptr = numpy.zeros(num,dtype=numpy.int64)
      self.__task.putacollist(sub, ptr, ptr, numpy.zeros(0,dtype=numpy.int32), numpy.zeros(0,dtype=numpy.float64))
  
    def _task_1putaijlist__3I_3I_3DJ(self,subi,subj,cof,num):
      self.__task.putaijlist(subi[:num],subj[:num],cof[:num])
  
    def _task_1putobjectivename_S(self,name):
      self.__task.putobjname("" if name is None else name)
  
    def _task_1putobjective_Z_3I_3DD(self,maximize,subj,cof,cfix):
      c = numpy.zeros(self.__task.getnumvar(),numpy.float64)
      idxs = numpy.arange(0,len(c),dtype=numpy.int32)
      for i in range(len(subj)):
        c[subj[i]] += cof[i]
      self.__task.putclist(idxs,c)
      self.__task.putcfix(cfix)
      self.__task.putobjsense(mosek.objsense.maximize if maximize else mosek.objsense.minimize)
  
    def _task_1putclist__3I_3D(self,subj,cof):
      self.__task.putclist(subj,cof)
  
  
    def _task_1appendsymmatlist__3I_3J_3I_3I_3D(self,dim,nz,subi,subj,cof):
      r = numpy.zeros(len(dim),numpy.int64)
      #print(dim,nz,"totalnz = {}, len(subi) = {},len(subj) = {}, subi = {}".format(sum(nz),len(subi),len(subj),subi))
      self.__task.appendsparsesymmatlist(dim,nz,subi,subj,cof,r)
      return r
  
    def _task_1putbarc__3I_3I_3I_3D(self,subj,subk,subl,val):
      #rint("putbarc: ",subj,subk,subl,val)
      self.__task.putbarcblocktriplet(subj,subk,subl,val)
      #self.__task.writedata("intermediate1.ptf")
  
    def _task_1putbaraijlist__3I_3I_3J(self,subi,subj,matidx):
      alpha = numpy.ones(len(subi),numpy.float64)
      ptr = numpy.arange(0,len(subi)+1,dtype=numpy.int64)
      self.__task.putbaraijlist(subi,subj,ptr[:-1],ptr[1:],matidx,alpha)
  
    def _task_1putbararowlist__3I_3J_3I_3J(self,subi,ptr,subj,matidx):
      alpha = numpy.ones(len(subj),numpy.float64)
      nummat = numpy.ones(len(subj),numpy.int64)
      self.__task.putbararowlist(subi,ptr[:-1],ptr[1:],subj,nummat,matidx,alpha)
  
  
    def _task_1barvardim_I(self,index):
      return self.__task.getdimbarvarj(index)
  
    def _task_1numbarvar_(self):
      return self.__task.getnumbarvar()
  
  
    def _task_1append_1barvar_II(self,size, num):
      res = self.__task.getnumbarvar()
      self.__task.appendbarvars([size] * num)
      return res
  
    def _task_1setnumvar_I(self,num):
      numvar = self.__task.getnumvar()
      if numvar > num:
        self.__task.removevars(range(num,numvar))
  
  
    def _task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(self,whichsol,first,last,xx):
      if   whichsol == mosek_fusion_SolutionType.Interior:
        self.__task.putxxslice(mosek.soltype.itr, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Integer:
        self.__task.putxxslice(mosek.soltype.itg, first,last,xx)
      elif whichsol == mosek_fusion_SolutionType.Basic:
        self.__task.putxxslice(mosek.soltype.bas, first,last,xx)
  
    def _task_1cleanup_IIII(self,inumvar,inumcon,inumcone,inumbarvar):
      numvar  = self.__task.getnumvar()
      numcon  = self.__task.getnumcon()
      numcone = self.__task.getnumcone()
      numbarvar = self.__task.getnumbarvar()
  
      if inumcone < numcone:
        self.__task.removecones(range(inumcone,numcone))
  
      if inumvar < numvar:
        n = numvar-inumvar
        vals = numpy.zeros((n,), numpy.float64)
        bk   = [ mosek.boundkey.fx for i in range(n) ]
        self.__task.putvarboundslice(inumvar,numvar,bk, vals, vals)
  
      if (inumcon < numcon):
        idxs = range(inumcon,numcon)
        self.__task.removecons(idxs)
  
      if (inumbarvar < numbarvar):
        self.__task.removebarvars(range(inumbarvar,numbarvar))
  
    def _task_1append_1afes_J(self,num):
      first = self.__task.getnumafe()
      self.__task.appendafes(num)
      return first
  
  
    def _task_1clearafelist__3J(self,idxs):
      self.__task.emptyafefrowlist(idxs)
      self.__task.emptyafebarfrowlist(idxs)
      self.__task.putafeglist(idxs,numpy.zeros(len(idxs),dtype=numpy.float64))
  
    def _task_1putafeflist__3J_3I_3I_3D_3D(self,idxs,ptr,subj,cof,g):
      lptr = numpy.array(ptr[:-1],dtype=numpy.int64)
      rownz = numpy.array([ptr[i+1]-ptr[i] for i in range(len(ptr)-1)],dtype=numpy.int32)
      self.__task.putafefrowlist(idxs,rownz,lptr, subj,cof)
      self.__task.putafeglist(idxs,g)
  
    # def _task_1putafebarfrowlist__3I_3J_3I_3J (self,idxs,ptr,barsubj,symmatidx):
    #     num = len(barsubj)
    #     afeidxlist = numpy.array([ idxs[i] for i in range(len(idxs)) for j in range(ptr[i],ptr[i+1]) ],dtype=numpy.int64)
    #     numtermslist = numpy.ones(num,numpy.int64)
    #     ptrtermslist = numpy.arange(num,numpy.int64)
    #     termweights = numpy.ones(num,numpy.float64)
    #     self.__task.putafebarfentrylist(afeidxlist,barsubj,numtermslist,ptrtermslist,symmatidx,termweights)
  
    def _task_1putafefijlist__3I_3I_3D (self,idxs,subj,cof):
      # TODO: use putafefenrtylist
      for i,j,c in zip(idxs,subj,cof):
        self.__task.putafefentry(i,j,c)
      #raise UnexpectedError("Not implemented: putafefijlist")
    def _task_putafefglist__3I_3D(self,idxs,g):
      self.__task.putafeglist(idxs,g)
  
    def _task_1append_1accs_JI_3J_3D(self,domidx,numcone,afeidxs,g):
      domidxs = numpy.array([domidx for i in range(numcone)],dtype=numpy.int64)
      self.__task.appendaccs(domidxs,afeidxs,g)
  
    def _task_1putacclist__3J_3J_3J_3D(self,accidxs,domidxs,afeidxs,g):
      self.__task.putacclist(accidxs,domidxs,afeidxs,g)
  
  
  
    @staticmethod
    def __convertSolutionStatus(soltype,sol,status,prosta):
      pd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
      }
  
      dd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Unknown,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.Unknown,
      }
  
      psd = {
          mosek.prosta.unknown  :                   mosek_fusion_ProblemStatus.Unknown,
          mosek.prosta.prim_and_dual_feas :         mosek_fusion_ProblemStatus.PrimalAndDualFeasible,
          mosek.prosta.prim_feas :                  mosek_fusion_ProblemStatus.PrimalFeasible,
          mosek.prosta.dual_feas :                  mosek_fusion_ProblemStatus.DualFeasible,
          mosek.prosta.prim_infeas :                mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.dual_infeas :                mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_and_dual_infeas :       mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.ill_posed :                  mosek_fusion_ProblemStatus.IllPosed,
          mosek.prosta.prim_infeas_or_unbounded :   mosek_fusion_ProblemStatus.PrimalInfeasibleOrUnbounded,
        }
  
      try: sol.pstatus = pd[status]
      except KeyError: sol.pstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.dstatus = dd[status]
      except KeyError: sol.dstatus = mosek_fusion_SolutionStatus.Unknown
  
      try: sol.probstatus = psd[prosta]
      except KeyError: sol.probstatus = mosek_fusion_SolutionStatus.Unknown
  
  
    @staticmethod
    def _matchargs_task_1write_S(self,*args):
        return True
    def _task_1write_S(self,filename):
        self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
        #self.__task.putintparam(mosek.iparam.write_ignore_incompatible_items, 1)
        self.__task.writedata(filename)
  
    def _task_1write_1stream_SLSystem_4DataStream_2(self,ext,stream):
        exts = {
          'mps' : mosek.dataformat.mps,
          'cbf' : mosek.dataformat.cb,
          'ptf' : mosek.dataformat.ptf,
          'opf' : mosek.dataformat.op,
          'lp'  : mosek.dataformat.lp,
          'jtask'  : mosek.dataformat.json_task,
          'task'  : mosek.dataformat.task,
        }
        ct = {
          'gz' : mosek.compresstype.gzip,
          'zst' : mosek.compresstype.zstd,
        }
  
        fmt = mosek.dataformat.mps
        comptype = mosek.compresstype.none
        parts = ext.split('.')
        if len(parts) > 0: fmt = parts[0]
        if len(parts) > 1: comptype = parts[1]
  
        try:
          self.__task.putintparam(mosek.iparam.opf_write_solutions, 1)
          self.__task.writedatastream(exts.get(fmt,mosek.dataformat.mps), ct.get(comptype,mosek.compresstype.none), stream)
        except mosek.Error as e:
          raise mosek.fusion.UnexpectedError(e.msg)
  
    def _task_1write(self,filename):
      return self._writeProblem_S(filename)
  
    def _task_1get_(self):
      return self.__task
  
    def _task_1break_1solve_(self):
      self.__break = True
  
    def _task_1putoptserver_1host_S(self, addr):
      self.__task.putoptserverhost(addr)
  
    def _report_1solution__Lmosek_4fusion_4SolutionType_Emosek_4fusion_4ProblemStatus_Emosek_4fusion_4SolutionStatus_Lmosek_4fusion_4SolutionStatus_DDIIIIIZZ(
        self,
        soltype,
        prosta,
        psolsta,
        dsolsta,
        pobj,
        dobj,
        numvar,
        numcon,
        numbarelm,
        numacc,
        numaccelm,
        hasprimal,
        hasdual):
      assert False
    def _report_1solution_1get_1xx__3D  (self,v): self.__task.getxxslice(  self.__cursol,0,len(v),v)
    def _report_1solution_1get_1slx__3D (self,v): self.__task.getslxslice( self.__cursol,0,len(v),v)
    def _report_1solution_1get_1sux__3D (self,v): self.__task.getsuxslice( self.__cursol,0,len(v),v)
    def _report_1solution_1get_1xc__3D  (self,v): self.__task.getxcslice(  self.__cursol,0,len(v),v)
    def _report_1solution_1get_1slc__3D (self,v): self.__task.getslcslice( self.__cursol,0,len(v),v)
    def _report_1solution_1get_1suc__3D (self,v): self.__task.getsucslice( self.__cursol,0,len(v),v)
    def _report_1solution_1get_1barx__3D(self,v): self.__task.getbarxslice(self.__cursol,0,self.__task.getnumbarvar(),len(v),v)
    def _report_1solution_1get_1bars__3D(self,v): self.__task.getbarsslice(self.__cursol,0,self.__task.getnumbarvar(),len(v),v)
    def _report_1solution_1get_1accx__3D(self,v): self.__task.evaluateaccs(self.__cursol,v)
    def _report_1solution_1get_1accy__3D(self,v):
      ptr = 0
      numacc = self.__task.getnumacc()
      for i in range(numacc):
        accn   = self.__task.getaccn(i)
        data = numpy.zeros(accn,numpy.float64)
        self.__task.getaccdoty(self.__cursol,i,data);
        v[ptr:ptr+accn] = data
        ptr += accn
  
    def _report_1solution_1get_1accptr__3I(self,v):
      ptr = 0
      numacc = self.__task.getnumacc()
      for i in range(numacc):
        v[i] = ptr;
        ptr += self.__task.getaccn(i)
  
    #def __report_task_solution(self,mosek.soltype st, int numvar, int numcon, int numbarelm, long numacc, long numaccelm) {
    def __report_task_solution(self,st,numvar,numcon,numbarelm,numacc,numaccelm):
      pd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.unknown :                    mosek_fusion_SolutionStatus.Unknown,
      }
  
      dd = {
          mosek.solsta.optimal :                    mosek_fusion_SolutionStatus.Optimal,
          mosek.solsta.integer_optimal :            mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.prim_and_dual_feas :         mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_feas :                  mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.dual_feas :                  mosek_fusion_SolutionStatus.Feasible,
          mosek.solsta.prim_infeas_cer :            mosek_fusion_SolutionStatus.Certificate,
          mosek.solsta.dual_infeas_cer :            mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.prim_illposed_cer :          mosek_fusion_SolutionStatus.IllposedCert,
          mosek.solsta.dual_illposed_cer :          mosek_fusion_SolutionStatus.Undefined,
          mosek.solsta.unknown :                    mosek_fusion_SolutionStatus.Unknown,
      }
  
      psd = {
          mosek.prosta.unknown  :                   mosek_fusion_ProblemStatus.Unknown,
          mosek.prosta.prim_and_dual_feas :         mosek_fusion_ProblemStatus.PrimalAndDualFeasible,
          mosek.prosta.prim_feas :                  mosek_fusion_ProblemStatus.PrimalFeasible,
          mosek.prosta.dual_feas :                  mosek_fusion_ProblemStatus.DualFeasible,
          mosek.prosta.prim_infeas :                mosek_fusion_ProblemStatus.PrimalInfeasible,
          mosek.prosta.dual_infeas :                mosek_fusion_ProblemStatus.DualInfeasible,
          mosek.prosta.prim_and_dual_infeas :       mosek_fusion_ProblemStatus.PrimalAndDualInfeasible,
          mosek.prosta.ill_posed :                  mosek_fusion_ProblemStatus.IllPosed,
          mosek.prosta.prim_infeas_or_unbounded :   mosek_fusion_ProblemStatus.PrimalInfeasibleOrUnbounded,
        }
  
  
      solsta = self.__task.getsolsta(st)
      prosta = self.__task.getprosta(st)
  
      psolsta = pd[solsta]
      dsolsta = dd[solsta]
  
      # Special unconditional cases for integer solution:
      if st == mosek.soltype.itg:
        dsolsta = mosek_fusion_SolutionStatus.Undefined
        if prosta == mosek.prosta.prim_infeas:
          psolsta = mosek_fusion_SolutionStatus.Undefined
  
      hasprimal = psolsta != mosek_fusion_SolutionStatus.Undefined
      hasdual   = dsolsta != mosek_fusion_SolutionStatus.Undefined
  
      pobj   = self.__task.getprimalobj(st) if hasprimal else 0.0
      dobj   = self.__task.getdualobj(st) if hasdual else 0.0
  
      ps = psd[prosta]
  
      if   st == mosek.soltype.bas: soltp = mosek_fusion_SolutionType.Basic
      elif st == mosek.soltype.itr: soltp = mosek_fusion_SolutionType.Interior
      elif st == mosek.soltype.itg: soltp = mosek_fusion_SolutionType.Integer
  
      self.__cursol = st
      self._report_1solution_Emosek_4fusion_4SolutionType_2Emosek_4fusion_4ProblemStatus_2Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4SolutionStatus_2DDIIIIIZZ(
        soltp,ps,psolsta,dsolsta,pobj,dobj,numvar,numcon,numbarelm,numacc,numaccelm,hasprimal,hasdual)
  
  
  
  
    @classmethod
    def _env_1solve_1batch_ZDI_3Lmosek_4fusion_4Model_2(self,israce,timelimit,numthreads,models):
      n = len(models)
      tasks = [_m.getTask() for _m in models]
      res = [mosek.rescode.err_unknown] * n
      trm = [mosek.rescode.err_unknown] * n
      ok = False
      try:
        BaseModel._globalEnv().optimizebatch(israce,          # israce
                                             timelimit,       # timelimit
                                             numthreads,      # numthread
                                             tasks,
                                             trm,
                                             res)
        ok = True
      except mosek.Error as e:
        raise mosek_fusion_OptimizeError(str(e))
      finally:
        if not ok: # means exception, post-solve won't be called
          for _m in models:
            _m._sol_itr = None
            _m._sol_bas = None
            _m._sol_itg = None
  
      return [mosek_fusion_SolverStatus.Error if res[i]!=mosek.rescode.ok else mosek_fusion_SolverStatus.LostRace if trm[i]==mosek.rescode.trm_lost_race else mosek_fusion_SolverStatus.OK for i in range(n)]
  
    @staticmethod
    def _matchargs_task_1solve_(self,*args):
      return True
    def _task_1solve_ZSS(self, remote, server, port):
      task = self.__task
      ok = False
      try:
        trmcode = mosek.rescode.ok
        try:
          self.__break = False
          if remote:
            trmcode = task.optimizermt(server, port)
          else:
            trmcode = task.optimize()
          task.solutionsummary(mosek.streamtype.log)
          ok = True
        except mosek.Error as e:
          raise mosek_fusion_OptimizeError(str(e))
      finally:
        if not ok: # means exception, post-solve won't be called
          self._sol_itr = None
          self._sol_bas = None
          self._sol_itg = None
  
    def _task_1post_1solve_(self):
      task = self.__task  
      numcon  = task.getnumcon()
      numvar  = task.getnumvar()
      numbarvar = task.getnumbarvar()
      barvarveclen = 0
      for j in range(numbarvar):
        barxjdim = task.getdimbarvarj(j)
        barvarveclen += barxjdim * (1+barxjdim)/2
      barvarveclen = numpy.int32(barvarveclen)
      numacc = task.getnumacc();
      numaccelm = task.getaccntot();
  
      sol_bas_def = 0 != task.solutiondef(mosek.soltype.bas)
      sol_itr_def = 0 != task.solutiondef(mosek.soltype.itr)
      sol_itg_def = 0 != task.solutiondef(mosek.soltype.itg)
  
      self._clear_1solutions_();
      if sol_itr_def:
        self.__report_task_solution(mosek.soltype.itr, numvar, numcon, barvarveclen,numacc,numaccelm)
      if sol_bas_def:
        self.__report_task_solution(mosek.soltype.bas, numvar, numcon, barvarveclen,numacc,numaccelm)
      if sol_itg_def:
        self.__report_task_solution(mosek.soltype.itg, numvar, numcon, barvarveclen,numacc,numaccelm)
  
  
    @staticmethod
    def _env_1syeig_I_3D_3D(n,a,w): BaseModel._globalEnv().syeig(n,a,w)
    @staticmethod
    def _env_1syevd_I_3D_3D(n,a,w): BaseModel._globalEnv().syevd(n,a,w)
    #@staticmethod
    #def _env_1potrf_I_3D(n,a):      BaseModel._globalEnv().potrf(n,a)
  
  
  
    def _task_1putafefrow_J_3I_3D(self,idx,subj,cof): self.__task.putafefrow(idx,subj,cof)
  
    def _task_1clearaferowlist__3I(self,idxs):
      subj = numpy.zeros(0,dtype=numpy.int32)
      val  = numpy.zeros(0,dtype=numpy.float64)
  
      for i in range(len(idxs)):
          self.__task.putafefrow(idxs[i],subj,val)
          self.__task.putafeg(idxs[i],0.0)
      raise  UnexpectedError("Not implemented: clearbarfrowlist");
  
    def _task_1putafefrowlist__3I_3I_3I_3D_3D(self,idxs,ptr,subj,cof,g):
      for i in range(len(idxs)):
          self.__task.putafefrow(idxs[i],subj[ptr[i]:ptr[i+1]],cof[ptr[i]:ptr[i+1]])
          self.__task.putafeg(idxs[i],g[i])
  
    def _task_1putafebarfrowlist__3I_3I_3I_3J (self,idxs,ptr,barsubj,symmatidx):
      num = len(barsubj);
      #print('ptr = ',ptr)
      #print('idxs = ',idxs)
      #print('barsubj = ',barsubj)
      afeidxlist   = numpy.array([idxs[i] for i in range(len(idxs)) for j in range(ptr[i],ptr[i+1])],dtype=numpy.int64)
      numtermslist = numpy.ones(num,dtype=numpy.int64)
      ptrtermslist = numpy.arange(num,dtype=numpy.int64)
      termweights  = numpy.ones(num,dtype=numpy.float64)
      #print('afeidxlist   = ',afeidxlist  )
      #print('numtermslist = ',numtermslist)
      #print('ptrtermslist = ',ptrtermslist)
      #print('termweights  = ',termweights )
  
      #print(idxs,afeidxlist,barsubj,numtermslist,ptrtermslist,symmatidx,termweights)
      #print(len(idxs),len(afeidxlist),len(barsubj),len(numtermslist),len(ptrtermslist),len(symmatidx),len(termweights))
      self.__task.putafebarfentrylist(afeidxlist,barsubj,numtermslist,ptrtermslist,symmatidx,termweights)
  
    #def _task_1putafefijlist__3I_3I_3D(self,idxs,subj,cof):
    #  raise UnexpectedError("Not implemented: putafefijlist")
  
    def _task_1putafefglist__3I_3D (self,idxs,g):
      for i,v in zip(idxs,g):
        self.__task.putafeg(i,v)
  
    def _task_1append_1accs_II_3I_3D_3I(self,domidx,numcone,afeidxs,g,accidxs):
      domidxs = numpy.array([domidx]*numcone,dtype=numpy.int32)
      lafeidxs = numpy.array(afeidxs,dtype=numpy.int64)
      firstacc = self.__task.getnumacc()
  
      for i in range(numcone):
        accidxs[i] = firstacc + i
      self.__task.appendaccs(domidxs,lafeidxs,g)
  
    def _task_1putafefrow_I_3I_3D (self,idx,subj,cof):
      self.__task.putafefrow(idx, subj, cof)
  
    def _task_1append_1domain_1quad_I     (self, conesize): return self.__task.appendquadraticconedomain(conesize)
    def _task_1append_1domain_1rquad_I    (self, conesize): return self.__task.appendrquadraticconedomain(conesize)
    def _task_1append_1domain_1pexp_      (self): return self.__task.appendprimalexpconedomain()
    def _task_1append_1domain_1dexp_      (self): return self.__task.appenddualexpconedomain()
    def _task_1append_1domain_1ppow_I_3D  (self, conesize, alpha): return self.__task.appendprimalpowerconedomain(conesize,alpha)
    def _task_1append_1domain_1dpow_I_3D  (self, conesize, alpha): return self.__task.appenddualpowerconedomain(conesize,alpha)
    #def _task_1append_1domain_1onenorm_I  (self, conesize): return self.__task.appendonenormconedomain(conesize)
    #def _task_1append_1domain_1infnorm_I  (self, conesize): return self.__task.appendinfnormconedomain(conesize)
    def _task_1append_1domain_1pgeomean_I (self, conesize): return self.__task.appendprimalgeomeanconedomain(conesize)
    def _task_1append_1domain_1dgeomean_I (self, conesize): return self.__task.appenddualgeomeanconedomain(conesize)
    def _task_1append_1domain_1rpos_I     (self, conesize): return self.__task.appendrplusdomain(conesize)
    def _task_1append_1domain_1rneg_I     (self, conesize): return self.__task.appendrminusdomain(conesize)
    def _task_1append_1domain_1r_I        (self, conesize): return self.__task.appendrdomain(conesize)
    def _task_1append_1domain_1rzero_I    (self, conesize): return self.__task.appendrzerodomain(conesize)
    def _task_1append_1domain_1svec_1psd_I(self, conesize): return self.__task.appendsvecpsdconedomain(conesize)
    def _task_1append_1domain_1empty_     (self): return self.__task.appendrdomain(0)
    def __task_append_1afes(self,num):
      idx = self.__task.getnumafe()
      self.__task.appendafes(num)
      return idx
  
    def __task_appenddjcs(self,num):
      idx = self.__task.getnumdjc()
      self.__task.appenddjcs(num)
      return idx
  
    def _task_1append_1djc_J(self,num):
      return self.__task_appenddjcs(num)
  
    def _task_1putdjcslice_JJ_3J_3J_3J_3J_3D(self,first,last,numterm,termsizes,domidxlist,afeidxlist,b):
      return self.__task.putdjcslice(first,last,domidxlist,afeidxlist,b,termsizes,numterm)
  return BaseModel
mosek_fusion_BaseModel=__mk_mosek_fusion_BaseModel()
#BEFORE CLASS
def __mk_mosek_fusion_Model():
 class Model(mosek_fusion_BaseModel):
  __slots__ = ['_Model__xs','_Model__ws','_Model__rs','_Model__sol_itg','_Model__sol_bas','_Model__sol_itr','_Model__con_map','_Model__acons','_Model__cons','_Model__task_numaferow','_Model__param_value','_Model__param_num','_Model__par_map','_Model__numparameter','_Model__parameters','_Model__initsol_xx_flag','_Model__initsol_xx','_Model__var_map','_Model__barvars','_Model__vars','_Model__bfixidx','_Model__barvar_block_elm_j','_Model__barvar_block_elm_i','_Model__barvar_block_elm_barj','_Model__barvar_block_elm_ptr','_Model__barvar_block_dim','_Model__barvar_block_ptr','_Model__barvar_dim','_Model__barvar_num','_Model__var_elm_acc_ofs','_Model__var_elm_acc_idx','_Model__var_block_acc_id','_Model__var_block_map','_Model__acon_elm_afe','_Model__acon_elm_ofs','_Model__acon_elm_scale','_Model__acon_elm_accid','_Model__acon_afe','_Model__acon_acc','_Model__acon_block_map','_Model__acc_block_map','_Model__obj_blocks','_Model__afe_blocks','_Model__con_blocks','_Model__num_task_acc','_Model__num_task_afe','_Model__num_task_con','_Model__solutionptr','_Model__acceptable_sol','_Model__model_name']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_S(*args): # string
      self._ctor_init_S(*args)
    elif self.__match_alt_ctor_S(*args):# string
      self._ctor_alt_init_S(*args)
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_SI(*args): # string,int32
      self._ctor_init_SI(*args)
    elif self.__match_alt_ctor_SI(*args):# string,int32
      self._ctor_alt_init_SI(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Model.ctor()\n\tmosek.fusion.Model.ctor(string)\n\tmosek.fusion.Model.ctor(int32)\n\tmosek.fusion.Model.ctor(string,int32)')
  def flushParameters(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushParameters_(*args): # 
      return self._flushParameters_(*args)
    elif mosek_fusion_Model._match_alt_flushParameters_(*args): # 
      return self._flushParameters_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushParameters('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushParameters()')
  def breakSolver(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_breakSolver_(*args): # 
      return self._breakSolver_(*args)
    elif mosek_fusion_Model._match_alt_breakSolver_(*args): # 
      return self._breakSolver_alt_(*args)
    else:
      raise ValueError('Invalid argument list breakSolver('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.breakSolver()')
  def getConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraint_S(*args): # string
      return self._getConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_S(*args): # string
      return self._getConstraint_alt_S(*args)
    elif mosek_fusion_Model._match_getConstraint_I(*args): # int32
      return self._getConstraint_I(*args)
    elif mosek_fusion_Model._match_alt_getConstraint_I(*args): # int32
      return self._getConstraint_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraint(string)\n\tmosek.fusion.Model.getConstraint(int32)')
  def solve(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_solve_(*args): # 
      return self._solve_(*args)
    elif mosek_fusion_Model._match_alt_solve_(*args): # 
      return self._solve_alt_(*args)
    elif mosek_fusion_Model._match_solve_SS(*args): # string,string
      return self._solve_SS(*args)
    elif mosek_fusion_Model._match_alt_solve_SS(*args): # string,string
      return self._solve_alt_SS(*args)
    else:
      raise ValueError('Invalid argument list solve('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.solve()\n\tmosek.fusion.Model.solve(string,string)')
  def disjunction(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_disjunction_Lmosek_4fusion_4Term_2(*args): # mosek.fusion.Term
      return self._disjunction_Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_Lmosek_4fusion_4Term_2(*args): # mosek.fusion.Term
      return self._disjunction_alt_Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction__3Lmosek_4fusion_4Term_2(*args): # []mosek.fusion.Term
      return self._disjunction__3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction__3Lmosek_4fusion_4Term_2(*args): # []mosek.fusion.Term
      return self._disjunction_alt__3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args): # mosek.fusion.Term,mosek.fusion.Term
      return self._disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args): # mosek.fusion.Term,mosek.fusion.Term
      return self._disjunction_alt_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_SLmosek_4fusion_4Term_2(*args): # string,mosek.fusion.Term
      return self._disjunction_SLmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_SLmosek_4fusion_4Term_2(*args): # string,mosek.fusion.Term
      return self._disjunction_alt_SLmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_S_3Lmosek_4fusion_4Term_2(*args): # string,[]mosek.fusion.Term
      return self._disjunction_S_3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_S_3Lmosek_4fusion_4Term_2(*args): # string,[]mosek.fusion.Term
      return self._disjunction_alt_S_3Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args): # mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term
      return self._disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args): # mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term
      return self._disjunction_alt_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args): # string,mosek.fusion.Term,mosek.fusion.Term
      return self._disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args): # string,mosek.fusion.Term,mosek.fusion.Term
      return self._disjunction_alt_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args): # string,mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term
      return self._disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    elif mosek_fusion_Model._match_alt_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args): # string,mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term
      return self._disjunction_alt_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args)
    else:
      raise ValueError('Invalid argument list disjunction('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.disjunction(mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(array(mosek.fusion.Term,ndim=1))\n\tmosek.fusion.Model.disjunction(mosek.fusion.Term,mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(string,mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(string,array(mosek.fusion.Term,ndim=1))\n\tmosek.fusion.Model.disjunction(mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(string,mosek.fusion.Term,mosek.fusion.Term)\n\tmosek.fusion.Model.disjunction(string,mosek.fusion.Term,mosek.fusion.Term,mosek.fusion.Term)')
  def getDualSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_(*args): # 
      return self._getDualSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getDualSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getDualSolutionStatus()\n\tmosek.fusion.Model.getDualSolutionStatus(mosek.fusion.SolutionType)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_Model._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.clone()')
  def getVariableValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariableValues_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableValues_Z_3J_3DI(*args)
    elif mosek_fusion_Model._match_alt_getVariableValues_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableValues_alt_Z_3J_3DI(*args)
    else:
      raise ValueError('Invalid argument list getVariableValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariableValues(bool,array(int64,ndim=1),array(double,ndim=1),int32)')
  def getName(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getName_(*args): # 
      return self._getName_(*args)
    elif mosek_fusion_Model._match_alt_getName_(*args): # 
      return self._getName_alt_(*args)
    else:
      raise ValueError('Invalid argument list getName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getName()')
  def flushNames(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushNames_(*args): # 
      return self._flushNames_(*args)
    elif mosek_fusion_Model._match_alt_flushNames_(*args): # 
      return self._flushNames_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushNames('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushNames()')
  def writeTaskNoFlush(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_writeTaskNoFlush_S(*args): # string
      return self._writeTaskNoFlush_S(*args)
    elif mosek_fusion_Model._match_alt_writeTaskNoFlush_S(*args): # string
      return self._writeTaskNoFlush_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTaskNoFlush('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTaskNoFlush(string)')
  def dualObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dualObjValue_(*args): # 
      return self._dualObjValue_(*args)
    elif mosek_fusion_Model._match_alt_dualObjValue_(*args): # 
      return self._dualObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list dualObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dualObjValue()')
  def setSolverParam(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_SS(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SS(*args): # string,string
      return self._setSolverParam_alt_SS(*args)
    elif mosek_fusion_Model._match_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_SI(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SI(*args): # string,int32
      return self._setSolverParam_alt_SI(*args)
    elif mosek_fusion_Model._match_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_SD(*args)
    elif mosek_fusion_Model._match_alt_setSolverParam_SD(*args): # string,double
      return self._setSolverParam_alt_SD(*args)
    else:
      raise ValueError('Invalid argument list setSolverParam('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setSolverParam(string,string)\n\tmosek.fusion.Model.setSolverParam(string,int32)\n\tmosek.fusion.Model.setSolverParam(string,double)')
  def getAcceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getAcceptedSolutionStatus_(*args): # 
      return self._getAcceptedSolutionStatus_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAcceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getAcceptedSolutionStatus()')
  def getSolverLIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverLIntInfo_S(*args): # string
      return self._getSolverLIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverLIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverLIntInfo(string)')
  def getVariableDuals(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariableDuals_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableDuals_Z_3J_3DI(*args)
    elif mosek_fusion_Model._match_alt_getVariableDuals_Z_3J_3DI(*args): # bool,[]int64,[]double,int32
      return self._getVariableDuals_alt_Z_3J_3DI(*args)
    else:
      raise ValueError('Invalid argument list getVariableDuals('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariableDuals(bool,array(int64,ndim=1),array(double,ndim=1),int32)')
  @staticmethod
  def getVersion(*args):
    if False: pass
    elif mosek_fusion_Model._match_getVersion_(*args): # 
      return mosek_fusion_Model._getVersion_(*args)
    elif mosek_fusion_Model._match_alt_getVersion_(*args): # 
      return mosek_fusion_Model._getVersion_alt_(*args)
    else:
      raise ValueError('Invalid argument list getVersion('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVersion()')
  def dispose(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_dispose_(*args): # 
      return self._dispose_(*args)
    elif mosek_fusion_Model._match_alt_dispose_(*args): # 
      return self._dispose_alt_(*args)
    else:
      raise ValueError('Invalid argument list dispose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.dispose()')
  def getSolverIntInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverIntInfo_S(*args): # string
      return self._getSolverIntInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverIntInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverIntInfo(string)')
  def getParameter(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getParameter_S(*args): # string
      return self._getParameter_S(*args)
    elif mosek_fusion_Model._match_alt_getParameter_S(*args): # string
      return self._getParameter_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getParameter(string)')
  def variable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_variable_(*args): # 
      return self._variable_(*args)
    elif mosek_fusion_Model._match_alt_variable_(*args): # 
      return self._variable_alt_(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return self._variable_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S(*args): # string
      return self._variable_S(*args)
    elif mosek_fusion_Model._match_alt_variable_S(*args): # string
      return self._variable_alt_S(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return self._variable_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_I(*args): # int32
      return self._variable_I(*args)
    elif mosek_fusion_Model._match_alt_variable_I(*args): # int32
      return self._variable_alt_I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return self._variable_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return self._variable_alt_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3I(*args): # []int32
      return self._variable__3I(*args)
    elif mosek_fusion_Model._match_alt_variable__3I(*args): # []int32
      return self._variable_alt__3I(*args)
    elif mosek_fusion_Model._match_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.PSDDomain
      return self._variable_alt_Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.LinearDomain
      return self._variable_alt_SLmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.PSDDomain
      return self._variable_alt_SLmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4ConeDomain_2(*args): # []int32,mosek.fusion.ConeDomain
      return self._variable__3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4ConeDomain_2(*args): # []int32,mosek.fusion.ConeDomain
      return self._variable_alt__3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args): # []int32,mosek.fusion.RangeDomain
      return self._variable_alt__3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SI(*args): # string,int32
      return self._variable_SI(*args)
    elif mosek_fusion_Model._match_alt_variable_SI(*args): # string,int32
      return self._variable_alt_SI(*args)
    elif mosek_fusion_Model._match_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args): # []int32,mosek.fusion.LinearDomain
      return self._variable_alt__3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args): # int32,mosek.fusion.LinearDomain
      return self._variable_alt_ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3I(*args): # string,[]int32
      return self._variable_S_3I(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3I(*args): # string,[]int32
      return self._variable_alt_S_3I(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args): # int32,mosek.fusion.RangeDomain
      return self._variable_alt_ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4ConeDomain_2(*args): # int32,mosek.fusion.ConeDomain
      return self._variable_ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4ConeDomain_2(*args): # int32,mosek.fusion.ConeDomain
      return self._variable_alt_ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.ConeDomain
      return self._variable_SLmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.ConeDomain
      return self._variable_alt_SLmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.RangeDomain
      return self._variable_alt_SLmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args): # int32,mosek.fusion.PSDDomain
      return self._variable_alt_ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args): # string,[]int32,mosek.fusion.RangeDomain
      return self._variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args): # string,[]int32,mosek.fusion.LinearDomain
      return self._variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4ConeDomain_2(*args): # string,int32,mosek.fusion.ConeDomain
      return self._variable_SILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4ConeDomain_2(*args): # string,int32,mosek.fusion.ConeDomain
      return self._variable_alt_SILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args): # int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_IILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args): # string,[]int32,mosek.fusion.ConeDomain
      return self._variable_S_3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args): # string,[]int32,mosek.fusion.ConeDomain
      return self._variable_alt_S_3ILmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args): # string,[]int32,mosek.fusion.PSDDomain
      return self._variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args): # string,int32,mosek.fusion.RangeDomain
      return self._variable_alt_SILmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args): # string,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args): # string,int32,mosek.fusion.LinearDomain
      return self._variable_alt_SILmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_SIILmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args): # string,int32,int32,mosek.fusion.PSDDomain
      return self._variable_alt_SIILmosek_4fusion_4PSDDomain_2(*args)
    else:
      raise ValueError('Invalid argument list variable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.variable()\n\tmosek.fusion.Model.variable(mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string)\n\tmosek.fusion.Model.variable(mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32)\n\tmosek.fusion.Model.variable(mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1))\n\tmosek.fusion.Model.variable(mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32)\n\tmosek.fusion.Model.variable(array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1))\n\tmosek.fusion.Model.variable(int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(int32,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.variable(string,array(int32,ndim=1),mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.variable(string,int32,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.variable(string,int32,int32,mosek.fusion.PSDDomain)')
  def getSolverDoubleInfo(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_S(*args)
    elif mosek_fusion_Model._match_alt_getSolverDoubleInfo_S(*args): # string
      return self._getSolverDoubleInfo_alt_S(*args)
    else:
      raise ValueError('Invalid argument list getSolverDoubleInfo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getSolverDoubleInfo(string)')
  def objective(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_objective_D(*args): # double
      return self._objective_D(*args)
    elif mosek_fusion_Model._match_alt_objective_D(*args): # double
      return self._objective_alt_D(*args)
    elif mosek_fusion_Model._match_objective_SD(*args): # string,double
      return self._objective_SD(*args)
    elif mosek_fusion_Model._match_alt_objective_SD(*args): # string,double
      return self._objective_alt_SD(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args): # mosek.fusion.ObjectiveSense,double
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args): # string,mosek.fusion.ObjectiveSense,double
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(*args)
    elif mosek_fusion_Model._match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Model._match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args): # string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression
      return self._objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list objective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.objective(double)\n\tmosek.fusion.Model.objective(string,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(mosek.fusion.ObjectiveSense,mosek.fusion.Expression)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,double)\n\tmosek.fusion.Model.objective(string,mosek.fusion.ObjectiveSense,mosek.fusion.Expression)')
  def selectedSolution(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._selectedSolution_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list selectedSolution('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.selectedSolution(mosek.fusion.SolutionType)')
  def acceptedSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_Model._match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list acceptedSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.acceptedSolutionStatus(mosek.fusion.AccSolutionStatus)')
  def constraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.PSDDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.ConeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.LinearDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Model._match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Model._match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args): # string,mosek.fusion.Expression,mosek.fusion.RangeDomain
      return self._constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list constraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.RangeDomain)\n\tmosek.fusion.Model.constraint(mosek.fusion.Expression,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.PSDDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.ConeDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.LinearDomain)\n\tmosek.fusion.Model.constraint(string,mosek.fusion.Expression,mosek.fusion.RangeDomain)')
  def hasParameter(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasParameter_S(*args): # string
      return self._hasParameter_S(*args)
    elif mosek_fusion_Model._match_alt_hasParameter_S(*args): # string
      return self._hasParameter_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasParameter(string)')
  def optserverHost(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_optserverHost_S(*args): # string
      return self._optserverHost_S(*args)
    elif mosek_fusion_Model._match_alt_optserverHost_S(*args): # string
      return self._optserverHost_alt_S(*args)
    else:
      raise ValueError('Invalid argument list optserverHost('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.optserverHost(string)')
  def getConstraintValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraintValues_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintValues_Z_3I_3DI(*args)
    elif mosek_fusion_Model._match_alt_getConstraintValues_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintValues_alt_Z_3I_3DI(*args)
    else:
      raise ValueError('Invalid argument list getConstraintValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraintValues(bool,array(int32,ndim=1),array(double,ndim=1),int32)')
  def hasVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasVariable_S(*args): # string
      return self._hasVariable_S(*args)
    elif mosek_fusion_Model._match_alt_hasVariable_S(*args): # string
      return self._hasVariable_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasVariable(string)')
  def getTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getTask_(*args): # 
      return self._getTask_(*args)
    elif mosek_fusion_Model._match_alt_getTask_(*args): # 
      return self._getTask_alt_(*args)
    else:
      raise ValueError('Invalid argument list getTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getTask()')
  def setCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_LSystem_4CallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args): # System.CallbackHandler
      return self._setCallbackHandler_alt_LSystem_4CallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setCallbackHandler(System.CallbackHandler)')
  def getConstraintDuals(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getConstraintDuals_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintDuals_Z_3I_3DI(*args)
    elif mosek_fusion_Model._match_alt_getConstraintDuals_Z_3I_3DI(*args): # bool,[]int32,[]double,int32
      return self._getConstraintDuals_alt_Z_3I_3DI(*args)
    else:
      raise ValueError('Invalid argument list getConstraintDuals('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getConstraintDuals(bool,array(int32,ndim=1),array(double,ndim=1),int32)')
  def hasConstraint(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_hasConstraint_S(*args): # string
      return self._hasConstraint_S(*args)
    elif mosek_fusion_Model._match_alt_hasConstraint_S(*args): # string
      return self._hasConstraint_alt_S(*args)
    else:
      raise ValueError('Invalid argument list hasConstraint('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.hasConstraint(string)')
  def primalObjValue(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_primalObjValue_(*args): # 
      return self._primalObjValue_(*args)
    elif mosek_fusion_Model._match_alt_primalObjValue_(*args): # 
      return self._primalObjValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list primalObjValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.primalObjValue()')
  def setDataCallbackHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args)
    elif mosek_fusion_Model._match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args): # System.DataCallbackHandler
      return self._setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(*args)
    else:
      raise ValueError('Invalid argument list setDataCallbackHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setDataCallbackHandler(System.DataCallbackHandler)')
  def getVariable(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getVariable_S(*args): # string
      return self._getVariable_S(*args)
    elif mosek_fusion_Model._match_alt_getVariable_S(*args): # string
      return self._getVariable_alt_S(*args)
    elif mosek_fusion_Model._match_getVariable_I(*args): # int32
      return self._getVariable_I(*args)
    elif mosek_fusion_Model._match_alt_getVariable_I(*args): # int32
      return self._getVariable_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getVariable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getVariable(string)\n\tmosek.fusion.Model.getVariable(int32)')
  def writeTask(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_writeTask_S(*args): # string
      return self._writeTask_S(*args)
    elif mosek_fusion_Model._match_alt_writeTask_S(*args): # string
      return self._writeTask_alt_S(*args)
    else:
      raise ValueError('Invalid argument list writeTask('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTask(string)')
  def setVariableValues(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setVariableValues_Z_3J_3D(*args): # bool,[]int64,[]double
      return self._setVariableValues_Z_3J_3D(*args)
    elif mosek_fusion_Model._match_alt_setVariableValues_Z_3J_3D(*args): # bool,[]int64,[]double
      return self._setVariableValues_alt_Z_3J_3D(*args)
    else:
      raise ValueError('Invalid argument list setVariableValues('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setVariableValues(bool,array(int64,ndim=1),array(double,ndim=1))')
  def setLogHandler(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_LSystem_4StreamWriter_2(*args)
    elif mosek_fusion_Model._match_alt_setLogHandler_LSystem_4StreamWriter_2(*args): # System.StreamWriter
      return self._setLogHandler_alt_LSystem_4StreamWriter_2(*args)
    else:
      raise ValueError('Invalid argument list setLogHandler('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.setLogHandler(System.StreamWriter)')
  def parameter(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_parameter_(*args): # 
      return self._parameter_(*args)
    elif mosek_fusion_Model._match_alt_parameter_(*args): # 
      return self._parameter_alt_(*args)
    elif mosek_fusion_Model._match_parameter_S(*args): # string
      return self._parameter_S(*args)
    elif mosek_fusion_Model._match_alt_parameter_S(*args): # string
      return self._parameter_alt_S(*args)
    elif mosek_fusion_Model._match_parameter_I(*args): # int32
      return self._parameter_I(*args)
    elif mosek_fusion_Model._match_alt_parameter_I(*args): # int32
      return self._parameter_alt_I(*args)
    elif mosek_fusion_Model._match_parameter__3I(*args): # []int32
      return self._parameter__3I(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I(*args): # []int32
      return self._parameter_alt__3I(*args)
    elif mosek_fusion_Model._match_parameter_SI(*args): # string,int32
      return self._parameter_SI(*args)
    elif mosek_fusion_Model._match_alt_parameter_SI(*args): # string,int32
      return self._parameter_alt_SI(*args)
    elif mosek_fusion_Model._match_parameter__3I_3J(*args): # []int32,[]int64
      return self._parameter__3I_3J(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I_3J(*args): # []int32,[]int64
      return self._parameter_alt__3I_3J(*args)
    elif mosek_fusion_Model._match_parameter_II(*args): # int32,int32
      return self._parameter_II(*args)
    elif mosek_fusion_Model._match_alt_parameter_II(*args): # int32,int32
      return self._parameter_alt_II(*args)
    elif mosek_fusion_Model._match_parameter__3I_3_5I(*args): # []int32,[,]int32
      return self._parameter__3I_3_5I(*args)
    elif mosek_fusion_Model._match_alt_parameter__3I_3_5I(*args): # []int32,[,]int32
      return self._parameter_alt__3I_3_5I(*args)
    elif mosek_fusion_Model._match_parameter_S_3I(*args): # string,[]int32
      return self._parameter_S_3I(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I(*args): # string,[]int32
      return self._parameter_alt_S_3I(*args)
    elif mosek_fusion_Model._match_parameter_S_3I_3J(*args): # string,[]int32,[]int64
      return self._parameter_S_3I_3J(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I_3J(*args): # string,[]int32,[]int64
      return self._parameter_alt_S_3I_3J(*args)
    elif mosek_fusion_Model._match_parameter_III(*args): # int32,int32,int32
      return self._parameter_III(*args)
    elif mosek_fusion_Model._match_alt_parameter_III(*args): # int32,int32,int32
      return self._parameter_alt_III(*args)
    elif mosek_fusion_Model._match_parameter_S_3I_3_5I(*args): # string,[]int32,[,]int32
      return self._parameter_S_3I_3_5I(*args)
    elif mosek_fusion_Model._match_alt_parameter_S_3I_3_5I(*args): # string,[]int32,[,]int32
      return self._parameter_alt_S_3I_3_5I(*args)
    elif mosek_fusion_Model._match_parameter_SII(*args): # string,int32,int32
      return self._parameter_SII(*args)
    elif mosek_fusion_Model._match_alt_parameter_SII(*args): # string,int32,int32
      return self._parameter_alt_SII(*args)
    elif mosek_fusion_Model._match_parameter_SIII(*args): # string,int32,int32,int32
      return self._parameter_SIII(*args)
    elif mosek_fusion_Model._match_alt_parameter_SIII(*args): # string,int32,int32,int32
      return self._parameter_alt_SIII(*args)
    else:
      raise ValueError('Invalid argument list parameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.parameter()\n\tmosek.fusion.Model.parameter(string)\n\tmosek.fusion.Model.parameter(int32)\n\tmosek.fusion.Model.parameter(array(int32,ndim=1))\n\tmosek.fusion.Model.parameter(string,int32)\n\tmosek.fusion.Model.parameter(array(int32,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Model.parameter(int32,int32)\n\tmosek.fusion.Model.parameter(array(int32,ndim=1),array(int32,ndim=2))\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1))\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Model.parameter(int32,int32,int32)\n\tmosek.fusion.Model.parameter(string,array(int32,ndim=1),array(int32,ndim=2))\n\tmosek.fusion.Model.parameter(string,int32,int32)\n\tmosek.fusion.Model.parameter(string,int32,int32,int32)')
  @staticmethod
  def putlicensepath(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_S(*args)
    elif mosek_fusion_Model._match_alt_putlicensepath_S(*args): # string
      return mosek_fusion_Model._putlicensepath_alt_S(*args)
    else:
      raise ValueError('Invalid argument list putlicensepath('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensepath(string)')
  @staticmethod
  def putlicensewait(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_Z(*args)
    elif mosek_fusion_Model._match_alt_putlicensewait_Z(*args): # bool
      return mosek_fusion_Model._putlicensewait_alt_Z(*args)
    else:
      raise ValueError('Invalid argument list putlicensewait('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensewait(bool)')
  @staticmethod
  def solveBatch(*args):
    if False: pass
    elif mosek_fusion_Model._match_solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args): # bool,double,int32,[]mosek.fusion.Model
      return mosek_fusion_Model._solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args)
    elif mosek_fusion_Model._match_alt_solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args): # bool,double,int32,[]mosek.fusion.Model
      return mosek_fusion_Model._solveBatch_alt_ZDI_3Lmosek_4fusion_4Model_2(*args)
    else:
      raise ValueError('Invalid argument list solveBatch('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.solveBatch(bool,double,int32,array(mosek.fusion.Model,ndim=1))')
  @staticmethod
  def putlicensecode(*args):
    if False: pass
    elif mosek_fusion_Model._match_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode__3I(*args)
    elif mosek_fusion_Model._match_alt_putlicensecode__3I(*args): # []int32
      return mosek_fusion_Model._putlicensecode_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list putlicensecode('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.putlicensecode(array(int32,ndim=1))')
  def writeTaskStream(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_writeTaskStream_SLSystem_4DataStream_2(*args): # string,System.DataStream
      return self._writeTaskStream_SLSystem_4DataStream_2(*args)
    elif mosek_fusion_Model._match_alt_writeTaskStream_SLSystem_4DataStream_2(*args): # string,System.DataStream
      return self._writeTaskStream_alt_SLSystem_4DataStream_2(*args)
    else:
      raise ValueError('Invalid argument list writeTaskStream('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.writeTaskStream(string,System.DataStream)')
  def flushSolutions(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_flushSolutions_(*args): # 
      return self._flushSolutions_(*args)
    elif mosek_fusion_Model._match_alt_flushSolutions_(*args): # 
      return self._flushSolutions_alt_(*args)
    else:
      raise ValueError('Invalid argument list flushSolutions('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.flushSolutions()')
  def updateObjective(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Model._match_alt_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._updateObjective_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list updateObjective('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.updateObjective(mosek.fusion.Expression,mosek.fusion.Variable)')
  def getProblemStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getProblemStatus_(*args): # 
      return self._getProblemStatus_(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_(*args): # 
      return self._getProblemStatus_alt_(*args)
    elif mosek_fusion_Model._match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getProblemStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getProblemStatus()\n\tmosek.fusion.Model.getProblemStatus(mosek.fusion.SolutionType)')
  def getPrimalSolutionStatus(self,*args):
    if False: pass
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_(*args): # 
      return self._getPrimalSolutionStatus_alt_(*args)
    elif mosek_fusion_Model._match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args)
    elif mosek_fusion_Model._match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args): # mosek.fusion.SolutionType
      return self._getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(*args)
    else:
      raise ValueError('Invalid argument list getPrimalSolutionStatus('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Model.getPrimalSolutionStatus()\n\tmosek.fusion.Model.getPrimalSolutionStatus(mosek.fusion.SolutionType)')
  def __repr__(self): return 'mosek.fusion.Model'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2(m):
    o = Model.__new__(Model)
    o._ctor_init_Lmosek_4fusion_4Model_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Model_2(m)
  def _ctor_init_Lmosek_4fusion_4Model_2(self,m):
   mosek_fusion_BaseModel._ctor_init_Lmosek_4fusion_4BaseModel_2(self,m)
   _0=self
   self.__model_name = (m.__model_name)
   self.__acceptable_sol = (m.__acceptable_sol)
   self.__solutionptr = (m.__solutionptr)
   self.__sol_itr = ((m.__sol_itr)._clone_() if (((m.__sol_itr) is not None) ) else None)
   self.__sol_itg = ((m.__sol_itg)._clone_() if (((m.__sol_itg) is not None) ) else None)
   self.__sol_bas = ((m.__sol_bas)._clone_() if (((m.__sol_bas) is not None) ) else None)
   self.__num_task_afe = (m.__num_task_afe)
   self.__num_task_con = (m.__num_task_con)
   self.__num_task_acc = (m.__num_task_acc)
   self.__con_blocks = mosek_fusion_RowBlockManager._ctor_Lmosek_4fusion_4RowBlockManager_2((m.__con_blocks))
   self.__afe_blocks = mosek_fusion_RowBlockManager._ctor_Lmosek_4fusion_4RowBlockManager_2((m.__afe_blocks))
   self.__obj_blocks = mosek_fusion_RowBlockManager._ctor_Lmosek_4fusion_4RowBlockManager_2((m.__obj_blocks))
   self.__acc_block_map = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__acc_block_map))
   self.__acon_block_map = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__acon_block_map))
   self.__acon_acc = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_acc))
   self.__acon_afe = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_afe))
   self.__acon_elm_accid = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_elm_accid))
   self.__acon_elm_scale = mosek.fusion.Utils.Tools._arraycopy__3D((m.__acon_elm_scale))
   self.__acon_elm_ofs = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_elm_ofs))
   self.__acon_elm_afe = mosek.fusion.Utils.Tools._arraycopy__3I((m.__acon_elm_afe))
   self.__task_numaferow = (m.__task_numaferow)
   self.__var_block_map = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((m.__var_block_map))
   self.__var_block_acc_id = mosek.fusion.Utils.Tools._arraycopy__3I((m.__var_block_acc_id))
   self.__var_elm_acc_idx = mosek.fusion.Utils.Tools._arraycopy__3I((m.__var_elm_acc_idx))
   self.__var_elm_acc_ofs = mosek.fusion.Utils.Tools._arraycopy__3I((m.__var_elm_acc_ofs))
   self.__barvar_num = 0
   self.__barvar_dim = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_dim))
   self.__barvar_block_ptr = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_ptr))
   self.__barvar_block_dim = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_dim))
   self.__barvar_block_elm_ptr = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_elm_ptr))
   self.__barvar_block_elm_barj = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_elm_barj))
   self.__barvar_block_elm_i = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_elm_i))
   self.__barvar_block_elm_j = mosek.fusion.Utils.Tools._arraycopy__3I((m.__barvar_block_elm_j))
   self.__vars = numpy.array([((m.__vars)[_1]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__vars)[_1] is not None) ) else None) for _1 in range(0,int(((m.__vars)).shape[0]))], dtype=numpy.dtype(object))
   self.__barvars = numpy.array([((m.__barvars)[_2]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__barvars)[_2] is not None) ) else None) for _2 in range(0,int(((m.__barvars)).shape[0]))], dtype=numpy.dtype(object))
   self.__var_map = (m.__var_map)._clone_()
   self.__cons = numpy.array([((m.__cons)[_3]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__cons)[_3] is not None) ) else None) for _3 in range(0,int(((m.__cons)).shape[0]))], dtype=numpy.dtype(object))
   self.__acons = numpy.array([((m.__acons)[_4]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__acons)[_4] is not None) ) else None) for _4 in range(0,int(((m.__acons)).shape[0]))], dtype=numpy.dtype(object))
   self.__con_map = (m.__con_map)._clone_()
   self.__numparameter = (m.__numparameter)
   self.__parameters = (None if (((m.__parameters) is None) ) else numpy.array([((m.__parameters)[_5]._clone_Lmosek_4fusion_4Model_2(_0) if (((m.__parameters)[_5] is not None) ) else None) for _5 in range(0,int(((m.__parameters)).shape[0]))], dtype=numpy.dtype(object)))
   self.__par_map = (m.__par_map)._clone_()
   self.__param_num = (m.__param_num)
   self.__param_value = (mosek.fusion.Utils.Tools._arraycopy__3D((m.__param_value)) if (((m.__param_value) is not None) ) else None)
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self.__bfixidx = (m.__bfixidx)
   self.__rs = mosek_fusion_WorkStack._ctor_()
   self.__ws = mosek_fusion_WorkStack._ctor_()
   self.__xs = mosek_fusion_WorkStack._ctor_()
  @staticmethod
  def _ctor_SI(name,basesize):
    o = Model.__new__(Model)
    o._ctor_init_SI(name,basesize)
    return o
  @staticmethod
  def __match_ctor_SI(*args):
    if len(args) != 2: return False
    name,basesize, = args
    return (__arg_match_S__(name) and __arg_match_I__(basesize))
  @staticmethod
  def __match_alt_ctor_SI(*args):
    if len(args) != 2: return False
    name,basesize, = args
    return (__arg_alt_match_S__(name) and __arg_alt_match_I__(basesize))
  def _ctor_alt_init_SI(self,name,basesize):
    self._ctor_init_SI(name,numpy.int32(basesize))
  def _ctor_init_SI(self,name,basesize):
   mosek_fusion_BaseModel._ctor_init_SS(self,name,"")
   self.__model_name = name
   self.__acceptable_sol = mosek.fusion.AccSolutionStatus.Optimal
   self.__solutionptr = mosek.fusion.SolutionType.Default
   self.__sol_itr = None
   self.__sol_itg = None
   self.__sol_bas = None
   self.__num_task_afe = 0
   self.__num_task_con = 0
   self.__num_task_acc = 0
   self.__con_blocks = mosek_fusion_RowBlockManager._ctor_()
   self.__afe_blocks = mosek_fusion_RowBlockManager._ctor_()
   self.__obj_blocks = mosek_fusion_RowBlockManager._ctor_()
   self.__acc_block_map = mosek_fusion_LinkedBlocks._ctor_()
   self.__acon_block_map = mosek_fusion_LinkedBlocks._ctor_()
   self.__task_numaferow = 0
   self.__acon_acc = numpy.zeros((self.__acon_block_map._block_1capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__acon_afe = numpy.zeros((self.__acon_block_map._block_1capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__acon_elm_accid = numpy.zeros((self.__acon_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__acon_elm_scale = numpy.array([1.0 for _0 in range(0,self.__acon_block_map._capacity_())], dtype=numpy.dtype(numpy.float64))
   self.__acon_elm_ofs = numpy.zeros((self.__acon_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__acon_elm_afe = numpy.zeros((self.__acon_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__var_block_map = mosek_fusion_LinkedBlocks._ctor_()
   self.__var_block_acc_id = numpy.zeros((self.__var_block_map._block_1capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__var_elm_acc_idx = numpy.zeros((self.__var_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__var_elm_acc_ofs = numpy.zeros((self.__var_block_map._capacity_(),), dtype=numpy.dtype(numpy.int32))
   self.__barvar_num = 0
   self.__barvar_dim = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_ptr = numpy.zeros(((basesize + 1),), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_dim = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_elm_ptr = numpy.zeros(((basesize + 1),), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_elm_barj = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_elm_i = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__barvar_block_elm_j = numpy.zeros((basesize,), dtype=numpy.dtype(numpy.int32))
   self.__vars = numpy.array([None for _1 in range(0,(basesize * 8))], dtype=numpy.dtype(object))
   self.__barvars = numpy.array([None for _2 in range(0,basesize)], dtype=numpy.dtype(object))
   self.__var_map = mosek.fusion.Utils.StringIntMap()
   self.__initsol_xx = None
   self.__initsol_xx_flag = None
   self.__cons = numpy.array([None for _3 in range(0,(basesize * 8))], dtype=numpy.dtype(object))
   self.__acons = numpy.array([None for _4 in range(0,(basesize * 8))], dtype=numpy.dtype(object))
   self.__con_map = mosek.fusion.Utils.StringIntMap()
   self.__numparameter = 0
   self.__parameters = None
   self.__par_map = mosek.fusion.Utils.StringIntMap()
   self.__param_num = 0
   self.__param_value = None
   _5=numpy.zeros((1,), dtype=numpy.dtype(numpy.int32))
   _6=self.__linearvar_1alloc_I_3I(1,_5)
   self.__bfixidx = _5[0]
   self._task_1var_1putboundlist_1fx__3I_3D(numpy.array([self.__bfixidx], dtype=numpy.dtype(numpy.int32)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)))
   self._task_1var_1name_IS(self.__bfixidx,"1.0")
   self._task_1append_1domain_1empty_()
   self.__rs = mosek_fusion_WorkStack._ctor_()
   self.__ws = mosek_fusion_WorkStack._ctor_()
   self.__xs = mosek_fusion_WorkStack._ctor_()
  @staticmethod
  def _ctor_I(basesize):
    o = Model.__new__(Model)
    o._ctor_init_I(basesize)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    basesize, = args
    return (__arg_match_I__(basesize))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    basesize, = args
    return (__arg_alt_match_I__(basesize))
  def _ctor_alt_init_I(self,basesize):
    self._ctor_init_I(numpy.int32(basesize))
  def _ctor_init_I(self,basesize):
   mosek_fusion_Model._ctor_init_SI(self,"",basesize)
  @staticmethod
  def _ctor_S(name):
    o = Model.__new__(Model)
    o._ctor_init_S(name)
    return o
  @staticmethod
  def __match_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_match_S__(name))
  @staticmethod
  def __match_alt_ctor_S(*args):
    if len(args) != 1: return False
    name, = args
    return (__arg_alt_match_S__(name))
  def _ctor_alt_init_S(self,name):
    self._ctor_init_S(name)
  def _ctor_init_S(self,name):
   mosek_fusion_Model._ctor_init_SI(self,name,128)
  @staticmethod
  def _ctor_():
    o = Model.__new__(Model)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_Model._ctor_init_S(self,"")
  @staticmethod
  def _match_disjunction_S_3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match__3Lmosek_4fusion_4Term_2__(_1))
  @staticmethod
  def _match_alt_disjunction_S_3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3Lmosek_4fusion_4Term_2__(_1))
  def _disjunction_alt_S_3Lmosek_4fusion_4Term_2(self,_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = self._disjunction_S_3Lmosek_4fusion_4Term_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _disjunction_S_3Lmosek_4fusion_4Term_2(self,_0,_1):
   _2=int((_1).shape[0])
   _3=0
   _4=0
   _5=0
   _6=0
   for _7 in range(0,_2):
    _3 += _1[_7]._size_()
    _4 += _1[_7]._num_()
    _6 += _1[_7]._numaccrows_()
    _5 += _1[_7]._numaccterms_()
   _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   _11=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _13=self.__afe_1allocate__3I(_8)
   _14=0
   _15=0
   _16=0
   _17=0
   for _18 in range(0,_2):
    for _19 in range(0,_1[_18]._num_()):
     _20=(_1[_18]._domains)[_19]
     _21=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2((_1[_18]._exprs)[_19])))
     _21._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
     self.__rs._pop_1expr_()
     _22=(self.__rs.i32)
     _23=(self.__rs.i64)
     _24=(self.__rs.f64)
     _25=(self.__rs.nd)
     _26=(self.__rs.shape_base)
     _27=(self.__rs.nelem)
     _28=(self.__rs.nnz)
     _29=(self.__rs.ncodeatom)
     _30=(self.__rs.hassp)
     _31=(self.__rs.ptr_base)
     _32=(self.__rs.nidxs_base)
     _33=(self.__rs.cof_base)
     _34=(self.__rs.code_base)
     _35=(self.__rs.codeptr_base)
     _36=(self.__rs.cconst_base)
     _37=numpy.array([_22[(_26 + _38)] for _38 in range(0,_25)], dtype=numpy.dtype(numpy.int32))
     self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_8,_17,self.__rs,_27,_28,_31,_32,_33)
     if ((_20.dom)==mosek.fusion.DJCDomainType.InRange): # src/fusion/Model.mbi:4847:20-52
      _39=(_20.b)
      _40=(_20.par)
      fragments._c_closure_1(_9,_10,_8,_17,_16,_39,_27,_40) # src/fusion/Model.mbi:4850:14-4855:15
      _11[_15] = self._task_1append_1domain_1rpos_I(_27)
      _11[(_15 + 1)] = self._task_1append_1domain_1rneg_I(_27)
      _12[_18] += 2
      _15 += 2
      _16 += (_27 * 2)
     elif (((_20.dom)==mosek.fusion.DJCDomainType.EqualTo) or (((_20.dom)==mosek.fusion.DJCDomainType.LessThan) or (((_20.dom)==mosek.fusion.DJCDomainType.GreaterThan) or ((_20.dom)==mosek.fusion.DJCDomainType.IsFree)))): # src/fusion/Model.mbi:4863:20-4866:51
      _41=(_20.b)
      fragments._c_closure_2(_9,_10,_8,_17,_16,_41,_27) # src/fusion/Model.mbi:4869:14-4872:15
      if ((_20.dom)==mosek.fusion.DJCDomainType.EqualTo): # src/fusion/Model.mbi:4874:22-54
       _11[_15] = self._task_1append_1domain_1rzero_I(_27)
      elif ((_20.dom)==mosek.fusion.DJCDomainType.LessThan): # src/fusion/Model.mbi:4876:22-55
       _11[_15] = self._task_1append_1domain_1rneg_I(_27)
      elif ((_20.dom)==mosek.fusion.DJCDomainType.GreaterThan): # src/fusion/Model.mbi:4878:22-58
       _11[_15] = self._task_1append_1domain_1rpos_I(_27)
      else:
       _11[_15] = self._task_1append_1domain_1r_I(_27)
      _12[_18] += 1
      _15 += 1
      _16 += _27
     else:
      raise mosek_fusion_UnexpectedError._ctor_S("Not implemented: Non-linear conic DJC constraints")
     _17 += _27
     if (_29 > 0): # src/fusion/Model.mbi:4891:16-29
      self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_8,_31,_32,_35,_34,_36)
     _14 += 1
   _42=self._task_1append_1djc_J(1)
   self._task_1putdjcslice_JJ_3J_3J_3J_3J_3D(_42,(_42 + 1),numpy.array([numpy.int64(_2)], dtype=numpy.dtype(numpy.int64)),_12,_11,numpy.array([_9[_43] for _43 in range(0,int((_9).shape[0]))], dtype=numpy.dtype(numpy.int64)),_10)
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:4908:12-25
    self._task_1djc_1name_JS(_42,mosek.fusion.Utils.StringBuffer()._a_S(_0)._a_S("[")._a_S("]")._toString_())
   return (mosek_fusion_Disjunction._ctor_J(_42))
  @staticmethod
  def _match_disjunction__3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Term_2__(_0))
  @staticmethod
  def _match_alt_disjunction__3Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Term_2__(_0))
  def _disjunction_alt__3Lmosek_4fusion_4Term_2(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = self._disjunction__3Lmosek_4fusion_4Term_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _disjunction__3Lmosek_4fusion_4Term_2(self,_0):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",_0))
  @staticmethod
  def _match_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Term_2__(_0) and __arg_match_Lmosek_4fusion_4Term_2__(_1) and __arg_match_Lmosek_4fusion_4Term_2__(_2))
  @staticmethod
  def _match_alt_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Term_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_2))
  def _disjunction_alt_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_t__0,_t__1,_t__2):
    return self._disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(_0,_1,_2)
  def _disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_0,_1,_2):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",numpy.array([_0,_1,_2], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Term_2__(_0) and __arg_match_Lmosek_4fusion_4Term_2__(_1))
  @staticmethod
  def _match_alt_disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Term_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_1))
  def _disjunction_alt_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_t__0,_t__1):
    return self._disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(_0,_1)
  def _disjunction_Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_0,_1):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",numpy.array([_0,_1], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Term_2__(_0))
  @staticmethod
  def _match_alt_disjunction_Lmosek_4fusion_4Term_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Term_2__(_0))
  def _disjunction_alt_Lmosek_4fusion_4Term_2(self,_t__0):
    return self._disjunction_Lmosek_4fusion_4Term_2(_0)
  def _disjunction_Lmosek_4fusion_4Term_2(self,_0):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2("",numpy.array([_0], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Term_2__(_1) and __arg_match_Lmosek_4fusion_4Term_2__(_2) and __arg_match_Lmosek_4fusion_4Term_2__(_3))
  @staticmethod
  def _match_alt_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_3))
  def _disjunction_alt_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(_0,_1,_2,_3)
  def _disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_0,_1,_2,_3):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_0,numpy.array([_1,_2,_3], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Term_2__(_1) and __arg_match_Lmosek_4fusion_4Term_2__(_2))
  @staticmethod
  def _match_alt_disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_2))
  def _disjunction_alt_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_t__0,_t__1,_t__2):
    return self._disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(_0,_1,_2)
  def _disjunction_SLmosek_4fusion_4Term_2Lmosek_4fusion_4Term_2(self,_0,_1,_2):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_0,numpy.array([_1,_2], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_disjunction_SLmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Term_2__(_1))
  @staticmethod
  def _match_alt_disjunction_SLmosek_4fusion_4Term_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Term_2__(_1))
  def _disjunction_alt_SLmosek_4fusion_4Term_2(self,_t__0,_t__1):
    return self._disjunction_SLmosek_4fusion_4Term_2(_0,_1)
  def _disjunction_SLmosek_4fusion_4Term_2(self,_0,_1):
   return (self._disjunction_S_3Lmosek_4fusion_4Term_2(_0,numpy.array([_1], dtype=numpy.dtype(object))))
  def _formstConstr_alt_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._formstConstr_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _formstConstr_Lmosek_4fusion_4Utils_4StringBuffer_2_3I_3I(self,_0,_1,_2):
   return (_0)
  def __acon_1release_alt_I(self,_t__0):
    return self.__acon_1release_I(numpy.int32(__0))
  def __acon_1release_I(self,_0):
   _1=self.__acon_block_map._blocksize_I(_0)
   if (_1 >= 0): # src/fusion/Model.mbi:4671:12-20
    _2=self.__acc_block_map._blocksize_I(self.__acon_acc[_0])
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    self.__acc_block_map._get_I_3II(self.__acon_acc[_0],_3,0)
    self.__acc_block_map._free_I(self.__acon_acc[_0])
    self.__afe_blocks._get_I_3II(self.__acon_afe[_0],_4,0)
    self.__afe_1release_I(self.__acon_afe[_0])
    self.__acon_block_map._free_I(_0)
    self._task_1clearafelist__3J(numpy.array([_4[_5] for _5 in range(0,_1)], dtype=numpy.dtype(numpy.int64)))
    self._task_1putacclist__3J_3J_3J_3D(numpy.array([_3[_6] for _6 in range(0,_2)], dtype=numpy.dtype(numpy.int64)),numpy.array([0 for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
  def __acon_1allocate_alt_JII_3D_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int64(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _1 = self.__acon_1allocate_JII_3D_3I_3I(_0,_1,_2,_3,_4,_5)
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __acon_1allocate_JII_3D_3I_3I(self,_0,_1,_2,_3,_4,_5):
   _6=(_2 * _1)
   _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _8=self.__acon_block_map._alloc_I(_6)
   _9=self.__acc_block_map._alloc_I(_2)
   _10=self.__afe_1allocate__3I(_4)
   self.__acon_block_map._get_I_3II(_8,_7,0)
   self.__acc_block_map._get_I_3II(_9,_5,0)
   _11=self.__acon_block_map._block_1capacity_()
   _12=self.__acon_block_map._capacity_()
   if (_11 > int((self.__acon_acc).shape[0])): # src/fusion/Model.mbi:4609:12-42
    _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    _14=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_acc,0,_13,0,int((self.__acon_acc).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_afe,0,_14,0,int((self.__acon_afe).shape[0]))
    self.__acon_acc = _13
    self.__acon_afe = _14
   self.__acon_acc[_8] = _9
   self.__acon_afe[_8] = _10
   if (_8 >= int((self.__acons).shape[0])): # src/fusion/Model.mbi:4621:12-32
    _15=numpy.array([None for _16 in range(0,(int((self.__acons).shape[0]) * 2))], dtype=numpy.dtype(object))
    for _17 in range(0,int((self.__acons).shape[0])):
     _15[_17] = self.__acons[_17]
    self.__acons = _15
   if (_12 > int((self.__acon_elm_accid).shape[0])): # src/fusion/Model.mbi:4627:12-42
    _18=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    _19=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
    _20=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    _21=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_elm_accid,0,_18,0,int((self.__acon_elm_accid).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__acon_elm_scale,0,_19,0,int((self.__acon_elm_scale).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_elm_ofs,0,_20,0,int((self.__acon_elm_ofs).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__acon_elm_afe,0,_21,0,int((self.__acon_elm_afe).shape[0]))
    self.__acon_elm_accid = _18
    self.__acon_elm_ofs = _20
    self.__acon_elm_afe = _21
    self.__acon_elm_scale = _19
   _22=0
   _22 = fragments._c_closure_3(_5,_22) # src/fusion/Model.mbi:4644:27-108
   _22 = numpy.int32(_22) # postprocess
   _22 += 1
   _23=self._task_1numacc_()
   if (_23 < _22): # src/fusion/Model.mbi:4646:12-28
    self._task_1append_1accs_JI_3J_3D(0,(_22 - _23),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
   self._task_1putacclist__3J_3J_3J_3D(numpy.array([_5[_24] for _24 in range(0,int((_5).shape[0]))], dtype=numpy.dtype(numpy.int64)),numpy.array([_0 for _25 in range(0,int((_5).shape[0]))], dtype=numpy.dtype(numpy.int64)),numpy.array([_4[_26] for _26 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int64)),_3)
   fragments._c_closure_4(_5,self.__acon_elm_accid,self.__acon_elm_afe,self.__acon_elm_ofs,self.__acon_elm_scale,_7,_4,_1,_2) # src/fusion/Model.mbi:4652:8-4663:9
   return numpy.int32(_8)
  def __afe_1release_alt_I(self,_t__0):
    return self.__afe_1release_I(numpy.int32(__0))
  def __afe_1release_I(self,_0):
   _1=numpy.zeros((self.__afe_blocks._blocksize_I(_0),), dtype=numpy.dtype(numpy.int32))
   self.__afe_blocks._release_I_3I(_0,_1)
   self._task_1clearafelist__3J(numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int64)))
  def __afe_1allocate_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__afe_1allocate__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __afe_1allocate__3I(self,_0):
   _1=self.__afe_blocks._allocate__3I(_0)
   if (int((_0).shape[0]) > 0): # src/fusion/Model.mbi:4566:12-31
    _2=self._task_1numafe_()
    _3=_0[0]
    _3 = fragments._c_closure_5(_3,_0) # src/fusion/Model.mbi:4568:38-122
    _3 = numpy.int32(_3) # postprocess
    if ((_3 + 1) > _2): # src/fusion/Model.mbi:4569:14-32
     _4=((_3 + 1) - _2)
     self._task_1append_1afes_J(_4)
     self.__task_numaferow += _4
   return numpy.int32(_1)
  def __con_1release_alt_I(self,_t__0):
    return self.__con_1release_I(numpy.int32(__0))
  def __con_1release_I(self,_0):
   _1=self.__con_blocks._blocksize_I(_0)
   if (_1 >= 0): # src/fusion/Model.mbi:4552:12-18
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    self.__con_blocks._release_I_3I(_0,_2)
    self.__cons[_0] = None
    self._task_1con_1putboundlist_1fr__3I(_2)
  def __con_1allocate_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__con_1allocate__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __con_1allocate__3I(self,_0):
   _1=self.__con_blocks._allocate__3I(_0)
   if (int((_0).shape[0]) > 0): # src/fusion/Model.mbi:4532:12-31
    _2=_0[0]
    _2 = fragments._c_closure_6(_2,_0) # src/fusion/Model.mbi:4533:38-122
    _2 = numpy.int32(_2) # postprocess
    if ((_2 + 1) > self.__num_task_con): # src/fusion/Model.mbi:4534:14-37
     _3=((_2 + 1) - self.__num_task_con)
     self._task_1append_1con_I(_3)
     self.__num_task_con += _3
   if (_1 >= int((self.__cons).shape[0])): # src/fusion/Model.mbi:4540:12-30
    _4=numpy.array([None for _5 in range(0,(int((self.__cons).shape[0]) * 2))], dtype=numpy.dtype(object))
    for _6 in range(0,int((self.__cons).shape[0])):
     _4[_6] = self.__cons[_6]
    self.__cons = _4
   return numpy.int32(_1)
  def __barvar_1alloc_alt_II_3I_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self.__barvar_1alloc_II_3I_3J(_0,_1,_2,_3)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __barvar_1alloc_II_3I_3J(self,_0,_1,_2,_3):
   _4=self.__barvar_num
   self.__barvar_num += 1
   _5=((_0 * (_0 + 1)) // 2)
   _6=(_5 * _1)
   _7=self.__barvar_block_ptr[_4]
   _8=int((self.__barvar_block_dim).shape[0])
   _9=self.__barvar_block_elm_ptr[_4]
   _10=int((self.__barvar_block_elm_barj).shape[0])
   if (_8 < (_7 + 1)): # src/fusion/Model.mbi:4444:12-35
    _11=numpy.zeros(((int((self.__barvar_block_dim).shape[0]) * 2),), dtype=numpy.dtype(numpy.int32))
    _12=numpy.zeros((((int((self.__barvar_block_dim).shape[0]) * 2) + 1),), dtype=numpy.dtype(numpy.int32))
    _13=numpy.zeros((((int((self.__barvar_block_dim).shape[0]) * 2) + 1),), dtype=numpy.dtype(numpy.int32))
    _14=numpy.array([None for _15 in range(0,((int((self.__barvar_block_dim).shape[0]) * 2) + 1))], dtype=numpy.dtype(object))
    for _16 in range(0,int((self.__barvars).shape[0])):
     _14[_16] = self.__barvars[_16]
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_dim,0,_11,0,int((self.__barvar_block_dim).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_ptr,0,_12,0,int((self.__barvar_block_ptr).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_elm_ptr,0,_13,0,int((self.__barvar_block_elm_ptr).shape[0]))
    self.__barvar_block_dim = _11
    self.__barvar_block_ptr = _12
    self.__barvar_block_elm_ptr = _13
    self.__barvars = _14
   if (_10 < (_9 + _6)): # src/fusion/Model.mbi:4463:12-49
    _17=((_10 + _6) - _9)
    if (_17 < _10): # src/fusion/Model.mbi:4465:14-36
     _17 = _10
    _18=(_10 + _17)
    _19=numpy.zeros((_18,), dtype=numpy.dtype(numpy.int32))
    _20=numpy.zeros((_18,), dtype=numpy.dtype(numpy.int32))
    _21=numpy.zeros((_18,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_elm_barj,0,_19,0,int((self.__barvar_block_elm_barj).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_elm_i,0,_20,0,int((self.__barvar_block_elm_i).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_block_elm_j,0,_21,0,int((self.__barvar_block_elm_j).shape[0]))
    self.__barvar_block_elm_barj = _19
    self.__barvar_block_elm_i = _20
    self.__barvar_block_elm_j = _21
   _22=self._task_1numbarvar_()
   fragments._c_closure_7(_2,_22,_1) # src/fusion/Model.mbi:4483:8-61
   if ((_22 + _1) >= int((self.__barvar_dim).shape[0])): # src/fusion/Model.mbi:4484:12-48
    _23=((_22 + _1) - int((self.__barvar_dim).shape[0]))
    if (_23 < int((self.__barvar_dim).shape[0])): # src/fusion/Model.mbi:4486:14-38
     _23 = int((self.__barvar_dim).shape[0])
    _24=(_23 + int((self.__barvar_dim).shape[0]))
    _25=numpy.zeros((_24,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__barvar_dim,0,_25,0,int((self.__barvar_dim).shape[0]))
    self.__barvar_dim = _25
   self.__barvar_block_dim[_4] = _0
   self.__barvar_block_ptr[(_4 + 1)] = (self.__barvar_block_ptr[_4] + _1)
   self.__barvar_block_elm_ptr[(_4 + 1)] = (self.__barvar_block_elm_ptr[_4] + _6)
   fragments._c_closure_8(self.__barvar_block_elm_barj,self.__barvar_block_elm_i,self.__barvar_block_elm_j,self.__barvar_block_elm_ptr,self.__barvar_dim,_4,_0,_22,_3,_1) # src/fusion/Model.mbi:4497:8-4516:9
   _26=self._task_1append_1barvar_II(_0,_1)
   return numpy.int32(_4)
  def __conicvar_1alloc_alt_JII_3I_3I(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int64(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = self.__conicvar_1alloc_JII_3I_3I(_0,_1,_2,_3,_4)
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __conicvar_1alloc_JII_3I_3I(self,_0,_1,_2,_3,_4):
   _5=(_1 * _2)
   _6=self.__linearvar_1alloc_I_3I(_5,_4)
   _7=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _10=self.__acon_1allocate_JII_3D_3I_3I(_0,_1,_2,_7,_9,_3)
   self.__var_block_acc_id[_6] = _10
   fragments._c_closure_9(_3,_1,_5,_4,self.__var_elm_acc_idx,self.__var_elm_acc_ofs) # src/fusion/Model.mbi:4408:8-4411:9
   self._task_1putafeflist__3J_3I_3I_3D_3D(numpy.array([_9[_11] for _11 in range(0,int((_9).shape[0]))], dtype=numpy.dtype(numpy.int64)),numpy.array([_12 for _12 in range(0,(_5 + 1))], dtype=numpy.dtype(numpy.int32)),_4,numpy.array([1.0 for _13 in range(0,_5)], dtype=numpy.dtype(numpy.float64)),numpy.array([0.0 for _14 in range(0,_5)], dtype=numpy.dtype(numpy.float64)))
   return numpy.int32(_6)
  def __linearvar_1alloc_alt_I_3I(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self.__linearvar_1alloc_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __linearvar_1alloc_I_3I(self,_0,_1):
   _2=self.__var_block_map._alloc_I(_0)
   _3=(self.__var_block_map._maxidx_I(_2) + 1)
   _4=self.__var_block_map._capacity_()
   _5=self.__var_block_map._block_1capacity_()
   self.__var_block_map._get_I_3II(_2,_1,0)
   if (self._task_1numvar_() < _3): # src/fusion/Model.mbi:4358:12-37
    self._task_1append_1var_I((_3 - self._task_1numvar_()))
   if (_2 >= int((self.__vars).shape[0])): # src/fusion/Model.mbi:4361:12-30
    _6=numpy.array([None for _7 in range(0,(int((self.__vars).shape[0]) * 2))], dtype=numpy.dtype(object))
    for _8 in range(0,int((self.__vars).shape[0])):
     _6[_8] = self.__vars[_8]
    self.__vars = _6
   if (_5 > int((self.__var_block_acc_id).shape[0])): # src/fusion/Model.mbi:4367:12-45
    _9=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__var_block_acc_id,0,_9,0,int((self.__var_block_acc_id).shape[0]))
    self.__var_block_acc_id = _9
   if (_4 > int((self.__var_elm_acc_idx).shape[0])): # src/fusion/Model.mbi:4373:12-38
    _10=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__var_elm_acc_idx,0,_10,0,int((self.__var_elm_acc_idx).shape[0]))
    self.__var_elm_acc_idx = _10
    _11=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__var_elm_acc_ofs,0,_11,0,int((self.__var_elm_acc_ofs).shape[0]))
    self.__var_elm_acc_ofs = _11
   self.__var_block_acc_id[_2] = (- 1)
   fragments._c_closure_10(_0,_1,self.__var_elm_acc_idx) # src/fusion/Model.mbi:4384:8-4385:46
   return numpy.int32(_2)
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   _1=0
   _1 = fragments._c_closure_11(_1,_0) # src/fusion/Model.mbi:4338:23-75
   _1 = numpy.int32(_1) # postprocess
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _3=0
   _3 = fragments._c_closure_12(_0,_3,_2) # src/fusion/Model.mbi:4342:8-4346:11
   _3 = numpy.int32(_3) # postprocess
   self._task_1var_1putcontlist__3I(_2)
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   _1=0
   _1 = fragments._c_closure_13(_1,_0) # src/fusion/Model.mbi:4326:23-75
   _1 = numpy.int32(_1) # postprocess
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _3=0
   _3 = fragments._c_closure_14(_0,_3,_2) # src/fusion/Model.mbi:4329:8-4333:11
   _3 = numpy.int32(_3) # postprocess
   self._task_1var_1putintlist__3I(_2)
  @staticmethod
  def _match_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Z__(_0))
  @staticmethod
  def _match_alt_putlicensewait_Z(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Z__(_0))
  @staticmethod
  def _putlicensewait_alt_Z(_t__0):
    return mosek_fusion_Model._putlicensewait_Z(_0)
  @staticmethod
  def _putlicensewait_Z(_0):
   mosek.fusion.BaseModel._env_1putlicensewait_Z(_0)
  @staticmethod
  def _match_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_putlicensepath_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  @staticmethod
  def _putlicensepath_alt_S(_t__0):
    return mosek_fusion_Model._putlicensepath_S(_0)
  @staticmethod
  def _putlicensepath_S(_0):
   mosek.fusion.BaseModel._env_1putlicensepath_S(_0)
  @staticmethod
  def _match_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_putlicensecode__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _putlicensecode_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Model._putlicensecode__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _putlicensecode__3I(_0):
   mosek.fusion.BaseModel._env_1putlicensecode__3I(_0)
  @staticmethod
  def _match_dispose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dispose_(*args):
    if len(args) != 0: return False
    return True
  def _dispose_alt_(self,):
    return self._dispose_()
  def _dispose_(self,):
   for _0 in range(0,int((self.__vars).shape[0])):
    self.__vars[_0] = None
   for _1 in range(0,int((self.__cons).shape[0])):
    self.__cons[_1] = None
   for _2 in range(0,int((self.__acons).shape[0])):
    self.__acons[_2] = None
   for _3 in range(0,int((self.__barvars).shape[0])):
    self.__barvars[_3] = None
   if (self.__parameters is not None): # src/fusion/Model.mbi:4311:12-30
    for _4 in range(0,int((self.__parameters).shape[0])):
     self.__parameters[_4] = None
   mosek_fusion_BaseModel._dispose_(self)
  @staticmethod
  def _match_getTask_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getTask_(*args):
    if len(args) != 0: return False
    return True
  def _getTask_alt_(self,):
    return self._getTask_()
  def _getTask_(self,):
   return (self._task_1get_())
  @staticmethod
  def _match_getConstraintDuals_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getConstraintDuals_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getConstraintDuals_alt_Z_3I_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getConstraintDuals_Z_3I_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getConstraintDuals_Z_3I_3DI(self,_0,_1,_2,_3):
   _4=int((_1).shape[0])
   _5=self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   _6=self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
   for _7 in range(0,_4):
    if (_1[_7] >= 0): # src/fusion/Model.mbi:4265:14-32
     if _0: # src/fusion/Model.mbi:4266:16-21
      _2[(_3 + _7)] = _5[_1[_7]]
     else:
      _2[(_3 + _7)] = (- _6[_1[_7]])
    else:
     raise mosek_fusion_SolutionError._ctor_S("Requested invalid solution item")
  @staticmethod
  def _match_getConstraintValues_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getConstraintValues_Z_3I_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getConstraintValues_alt_Z_3I_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getConstraintValues_Z_3I_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getConstraintValues_Z_3I_3DI(self,_0,_1,_2,_3):
   _4=int((_1).shape[0])
   if _0: # src/fusion/Model.mbi:4228:12-18
    _5=self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6=self._getSolution_1accx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _7=self._getSolution_1accptr_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_15(_7,_6,self.__acon_elm_accid,self.__acon_elm_ofs,self.__acon_elm_scale,_4,_1,_3,_2,_5) # src/fusion/Model.mbi:4233:10-4240:11
   else:
    _8=self._getSolution_1y_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _9=self._getSolution_1accy_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _10=self._getSolution_1accptr_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_16(_10,_9,self.__acon_elm_accid,self.__acon_elm_ofs,self.__acon_elm_scale,_4,_1,_3,_2,_8) # src/fusion/Model.mbi:4247:10-4254:11
  @staticmethod
  def _match_getVariableDuals_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getVariableDuals_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getVariableDuals_alt_Z_3J_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getVariableDuals_Z_3J_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getVariableDuals_Z_3J_3DI(self,_0,_1,_2,_3):
   _4=int((_1).shape[0])
   if _0: # src/fusion/Model.mbi:4198:12-17
    _5=self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_17(_4,_1,_3,_2,_5) # src/fusion/Model.mbi:4201:10-4208:11
   else:
    _6=self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_18(_4,_1,_3,_2,_6) # src/fusion/Model.mbi:4213:10-4220:11
  @staticmethod
  def _match_getVariableValues_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_getVariableValues_Z_3J_3DI(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3))
  def _getVariableValues_alt_Z_3J_3DI(self,_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _1 = self._getVariableValues_Z_3J_3DI(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getVariableValues_Z_3J_3DI(self,_0,_1,_2,_3):
   _4=int((_1).shape[0])
   self.__barvar_num = self._task_1numbarvar_()
   if _0: # src/fusion/Model.mbi:4158:12-18
    _5=self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _6=(self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if ((self.__barvar_num > 0) ) else None)
    fragments._c_closure_19(_6,_4,_1,_3,_2,_5) # src/fusion/Model.mbi:4161:10-4171:11
   else:
    _7=self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _8=(self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default) if ((self.__barvar_num > 0) ) else None)
    _9=self._getSolution_1accy_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    _10=self._getSolution_1accptr_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Default)
    fragments._c_closure_20(_10,_9,_8,_4,_1,_3,_2,self.__var_elm_acc_idx,self.__var_elm_acc_ofs,_7) # src/fusion/Model.mbi:4178:10-4189:11
  @staticmethod
  def _match_setVariableValues_Z_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Z__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_setVariableValues_Z_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2))
  def _setVariableValues_alt_Z_3J_3D(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._setVariableValues_Z_3J_3D(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setVariableValues_Z_3J_3D(self,_0,_1,_2):
   if _0: # src/fusion/Model.mbi:4132:12-18
    _3=0
    _3 = fragments._c_closure_21(_1,_3) # src/fusion/Model.mbi:4134:10-4135:44
    _3 = numpy.int32(_3) # postprocess
    _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
    _6=0
    _6 = fragments._c_closure_22(_6,_1,_4,_5,_2) # src/fusion/Model.mbi:4140:10-4145:13
    _6 = numpy.int32(_6) # postprocess
    self._setSolution_1xx__3I_3D(_4,_5)
   else:
    pass
  @staticmethod
  def _match_flushNames_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushNames_(*args):
    if len(args) != 0: return False
    return True
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   for _0 in range(0,int((self.__vars).shape[0])):
    if (self.__vars[_0] is not None): # src/fusion/Model.mbi:4112:14-29
     self.__vars[_0]._flushNames_()
   for _1 in range(0,int((self.__barvars).shape[0])):
    if (self.__barvars[_1] is not None): # src/fusion/Model.mbi:4115:14-32
     self.__barvars[_1]._flushNames_()
   for _2 in range(0,int((self.__cons).shape[0])):
    if (self.__cons[_2] is not None): # src/fusion/Model.mbi:4118:14-29
     self.__cons[_2]._flushNames_()
   for _3 in range(0,int((self.__acons).shape[0])):
    if (self.__acons[_3] is not None): # src/fusion/Model.mbi:4121:14-30
     self.__acons[_3]._flushNames_()
  @staticmethod
  def _match_writeTaskNoFlush_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_writeTaskNoFlush_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _writeTaskNoFlush_alt_S(self,_t__0):
    return self._writeTaskNoFlush_S(_0)
  def _writeTaskNoFlush_S(self,_0):
   self._flushNames_()
   self._task_1write_S(_0)
  @staticmethod
  def _match_writeTaskStream_SLSystem_4DataStream_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_LSystem_4DataStream_2__(_1))
  @staticmethod
  def _match_alt_writeTaskStream_SLSystem_4DataStream_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_LSystem_4DataStream_2__(_1))
  def _writeTaskStream_alt_SLSystem_4DataStream_2(self,_t__0,_t__1):
    return self._writeTaskStream_SLSystem_4DataStream_2(_0,_1)
  def _writeTaskStream_SLSystem_4DataStream_2(self,_0,_1):
   self._flushNames_()
   self.__flush_1parameters_()
   self._task_1write_1stream_SLSystem_4DataStream_2(_0,_1)
  @staticmethod
  def _match_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_writeTask_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _writeTask_alt_S(self,_t__0):
    return self._writeTask_S(_0)
  def _writeTask_S(self,_0):
   self._flushNames_()
   self.__flush_1parameters_()
   self._task_1write_S(_0)
  @staticmethod
  def _match_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverLIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverLIntInfo_alt_S(self,_t__0):
    return self._getSolverLIntInfo_S(_0)
  def _getSolverLIntInfo_S(self,_0):
   return numpy.int64(self._task_1get_1liinf_S(_0))
  @staticmethod
  def _match_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverIntInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverIntInfo_alt_S(self,_t__0):
    return self._getSolverIntInfo_S(_0)
  def _getSolverIntInfo_S(self,_0):
   return numpy.int32(self._task_1get_1iinf_S(_0))
  @staticmethod
  def _match_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getSolverDoubleInfo_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getSolverDoubleInfo_alt_S(self,_t__0):
    return self._getSolverDoubleInfo_S(_0)
  def _getSolverDoubleInfo_S(self,_0):
   return numpy.float64(self._task_1get_1dinf_S(_0))
  @staticmethod
  def _match_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4CallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setCallbackHandler_LSystem_4CallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4CallbackHandler_2__(_0))
  def _setCallbackHandler_alt_LSystem_4CallbackHandler_2(self,_t__0):
    return self._setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  def _setCallbackHandler_LSystem_4CallbackHandler_2(self,_0):
   self._task_1setCallbackHandler_LSystem_4CallbackHandler_2(_0)
  @staticmethod
  def _match_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4DataCallbackHandler_2__(_0))
  @staticmethod
  def _match_alt_setDataCallbackHandler_LSystem_4DataCallbackHandler_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4DataCallbackHandler_2__(_0))
  def _setDataCallbackHandler_alt_LSystem_4DataCallbackHandler_2(self,_t__0):
    return self._setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  def _setDataCallbackHandler_LSystem_4DataCallbackHandler_2(self,_0):
   self._task_1setDataCallbackHandler_LSystem_4DataCallbackHandler_2(_0)
  @staticmethod
  def _match_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_LSystem_4StreamWriter_2__(_0))
  @staticmethod
  def _match_alt_setLogHandler_LSystem_4StreamWriter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_LSystem_4StreamWriter_2__(_0))
  def _setLogHandler_alt_LSystem_4StreamWriter_2(self,_t__0):
    return self._setLogHandler_LSystem_4StreamWriter_2(_0)
  def _setLogHandler_LSystem_4StreamWriter_2(self,_0):
   self._task_1setLogHandler_LSystem_4StreamWriter_2(_0)
  @staticmethod
  def _match_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _setSolverParam_alt_SD(self,_t__0,_t__1):
    return self._setSolverParam_SD(_0,numpy.float64(__1))
  def _setSolverParam_SD(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SD(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _setSolverParam_alt_SI(self,_t__0,_t__1):
    return self._setSolverParam_SI(_0,numpy.int32(__1))
  def _setSolverParam_SI(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SI(self,_0,_1)
  @staticmethod
  def _match_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_S__(_1))
  @staticmethod
  def _match_alt_setSolverParam_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_S__(_1))
  def _setSolverParam_alt_SS(self,_t__0,_t__1):
    return self._setSolverParam_SS(_0,_1)
  def _setSolverParam_SS(self,_0,_1):
   mosek.fusion.Parameters._setParameter_Lmosek_4fusion_4Model_2SS(self,_0,_1)
  @staticmethod
  def _match_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_breakSolver_(*args):
    if len(args) != 0: return False
    return True
  def _breakSolver_alt_(self,):
    return self._breakSolver_()
  def _breakSolver_(self,):
   self._task_1break_1solve_()
  @staticmethod
  def _match_optserverHost_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_optserverHost_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _optserverHost_alt_S(self,_t__0):
    return self._optserverHost_S(_0)
  def _optserverHost_S(self,_0):
   self._task_1putoptserver_1host_S(_0)
  def _report_1solution_alt_Emosek_4fusion_4SolutionType_2Emosek_4fusion_4ProblemStatus_2Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4SolutionStatus_2DDIIIIIZZ(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11,_t__12):
    return self._report_1solution_Emosek_4fusion_4SolutionType_2Emosek_4fusion_4ProblemStatus_2Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4SolutionStatus_2DDIIIIIZZ(__0,__1,__2,__3,numpy.float64(__4),numpy.float64(__5),numpy.int32(__6),numpy.int32(__7),numpy.int32(__8),numpy.int32(__9),numpy.int32(__10),_11,_12)
  def _report_1solution_Emosek_4fusion_4SolutionType_2Emosek_4fusion_4ProblemStatus_2Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4SolutionStatus_2DDIIIIIZZ(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12):
   if (_0==mosek.fusion.SolutionType.Interior): # src/fusion/Model.mbi:3818:16-48
    _13 = self.__sol_itr
   elif (_0==mosek.fusion.SolutionType.Basic): # src/fusion/Model.mbi:3819:16-45
    _13 = self.__sol_bas
   elif (_0==mosek.fusion.SolutionType.Integer): # src/fusion/Model.mbi:3820:16-47
    _13 = self.__sol_itg
   else:
    _13 = None
   if (_13 is None): # src/fusion/Model.mbi:3823:12-23
    _13 = mosek_fusion_SolutionStruct._ctor_IIIII(_6,_7,_8,_9,_10)
   else:
    _13._resize_IIIII(_6,_7,_8,_9,_10)
   (_13.pobj) = _4
   (_13.dobj) = _5
   (_13.pstatus) = _2
   (_13.dstatus) = _3
   (_13.probstatus) = _1
   if (_6 > 0): # src/fusion/Model.mbi:3834:12-22
    if _11: # src/fusion/Model.mbi:3835:14-23
     self._report_1solution_1get_1xx__3D((_13.xx))
    if _12: # src/fusion/Model.mbi:3836:14-21
     self._report_1solution_1get_1slx__3D((_13.slx))
     self._report_1solution_1get_1sux__3D((_13.sux))
     _14=(_13.yx)
     _15=(_13.slx)
     _16=(_13.sux)
     fragments._c_closure_23(_6,_15,_16,_14) # src/fusion/Model.mbi:3844:12-3845:36
   if (_7 > 0): # src/fusion/Model.mbi:3849:12-22
    if _11: # src/fusion/Model.mbi:3850:14-23
     self._report_1solution_1get_1xc__3D((_13.xc))
    if _12: # src/fusion/Model.mbi:3851:14-21
     self._report_1solution_1get_1slc__3D((_13.slc))
     self._report_1solution_1get_1suc__3D((_13.suc))
     _17=(_13.y)
     _18=(_13.slc)
     _19=(_13.suc)
     fragments._c_closure_24(_7,_18,_19,_17) # src/fusion/Model.mbi:3858:12-3859:35
   if (_8 > 0): # src/fusion/Model.mbi:3863:12-25
    if _11: # src/fusion/Model.mbi:3864:14-23
     self._report_1solution_1get_1barx__3D((_13.barx))
    if _12: # src/fusion/Model.mbi:3865:14-21
     self._report_1solution_1get_1bars__3D((_13.bars))
   if (self._task_1numacc_() > 0): # src/fusion/Model.mbi:3868:12-29
    self._report_1solution_1get_1accptr__3I((_13.accptr))
    if _11: # src/fusion/Model.mbi:3870:14-23
     self._report_1solution_1get_1accx__3D((_13.accx))
    if _12: # src/fusion/Model.mbi:3871:14-21
     self._report_1solution_1get_1accy__3D((_13.accy))
   if (_0==mosek.fusion.SolutionType.Interior): # src/fusion/Model.mbi:3875:16-48
    self.__sol_itr = _13
   elif (_0==mosek.fusion.SolutionType.Basic): # src/fusion/Model.mbi:3876:16-45
    self.__sol_bas = _13
   elif (_0==mosek.fusion.SolutionType.Integer): # src/fusion/Model.mbi:3877:16-47
    self.__sol_itg = _13
  def _clear_1solutions_alt_(self,):
    return self._clear_1solutions_()
  def _clear_1solutions_(self,):
   self.__sol_itr = None
   self.__sol_itg = None
   self.__sol_bas = None
  @staticmethod
  def _match_solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Z__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2) and __arg_match__3Lmosek_4fusion_4Model_2__(_3))
  @staticmethod
  def _match_alt_solveBatch_ZDI_3Lmosek_4fusion_4Model_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Z__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match__3Lmosek_4fusion_4Model_2__(_3))
  @staticmethod
  def _solveBatch_alt_ZDI_3Lmosek_4fusion_4Model_2(_t__0,_t__1,_t__2,_t__3):
   _0=_t__0
   _1=numpy.float64(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Model._solveBatch_ZDI_3Lmosek_4fusion_4Model_2(_0,_1,_2,_3)
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _solveBatch_ZDI_3Lmosek_4fusion_4Model_2(_0,_1,_2,_3):
   _4=int((_3).shape[0])
   for _5 in range(0,_4):
    if (_3[_5] is None): # src/fusion/Model.mbi:3777:14-29
     raise mosek_fusion_OptimizeError._ctor_S("One of the models is a null object")
   for _6 in range(0,_4):
    _3[_6]._flushSolutions_()
    _3[_6].__flush_1parameters_()
   _7=mosek.fusion.BaseModel._env_1solve_1batch_ZDI_3Lmosek_4fusion_4Model_2(_0,_1,_2,_3)
   for _8 in range(0,_4):
    _3[_8]._task_1post_1solve_()
   return (_7)
  @staticmethod
  def _match_solve_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_S__(_1))
  @staticmethod
  def _match_alt_solve_SS(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_S__(_1))
  def _solve_alt_SS(self,_t__0,_t__1):
    return self._solve_SS(_0,_1)
  def _solve_SS(self,_0,_1):
   self._flushSolutions_()
   self.__flush_1parameters_()
   self._task_1solve_ZSS(True,_0,_1)
   self._task_1post_1solve_()
  @staticmethod
  def _match_solve_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_solve_(*args):
    if len(args) != 0: return False
    return True
  def _solve_alt_(self,):
    return self._solve_()
  def _solve_(self,):
   self._flushSolutions_()
   self.__flush_1parameters_()
   self._task_1solve_ZSS(False,"","")
   self._task_1post_1solve_()
  def __flush_1parameters_alt_(self,):
    return self.__flush_1parameters_()
  def __flush_1parameters_(self,):
   _0=self.__con_blocks._num_1parameterized_()
   _1=self.__afe_blocks._num_1parameterized_()
   _2=self.__obj_blocks._num_1parameterized_()
   if (_0 > 0): # src/fusion/Model.mbi:3682:12-32
    _3=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self.__con_blocks._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self.__xs,self.__param_value,_3,_4,_5)
    self._task_1putaijlist__3I_3I_3DJ(_3,_4,_5,_0)
   if (_1 > 0): # src/fusion/Model.mbi:3698:12-32
    _6=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _7=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _8=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    self.__afe_blocks._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self.__xs,self.__param_value,_6,_7,_8)
    self._task_1putafefijlist__3I_3I_3D(_6,_7,_8)
   if (_2 > 0): # src/fusion/Model.mbi:3713:12-32
    _9=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _10=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _11=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
    self.__obj_blocks._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self.__xs,self.__param_value,_9,_10,_11)
    self._task_1putclist__3I_3D(_10,_11)
  @staticmethod
  def _match_flushParameters_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushParameters_(*args):
    if len(args) != 0: return False
    return True
  def _flushParameters_alt_(self,):
    return self._flushParameters_()
  def _flushParameters_(self,):
   self.__flush_1parameters_()
  def __evaluate_1parameterized_alt_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3I_3D_3I_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.array(_t__9,dtype=numpy.dtype(numpy.int32))
   _10=numpy.array(_t__10,dtype=numpy.dtype(numpy.float64))
   _1 = self.__evaluate_1parameterized_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3I_3D_3I_3D(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__9[:] = _9
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__10[:] = _10
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __evaluate_1parameterized_Lmosek_4fusion_4WorkStack_2I_3I_3I_3J_3I_3I_3I_3D_3I_3D(self,_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10):
   _11=_0._allocf64_I(int((_7).shape[0]))
   _12=0
   _13=(_0.f64)
   _14=0
   _14,_12 = fragments._c_closure_25(_8,_7,_4,_5,_6,_14,_1,self.__param_value,_2,_3,_11,_12,_9,_10,_13) # src/fusion/Model.mbi:3620:8-3664:9
   _14 = numpy.int32(_14) # postprocess
   _12 = numpy.int32(_12) # postprocess
   _0._popf64_I(int((_7).shape[0]))
  @staticmethod
  def _match_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_flushSolutions_(*args):
    if len(args) != 0: return False
    return True
  def _flushSolutions_alt_(self,):
    return self._flushSolutions_()
  def _flushSolutions_(self,):
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Interior)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Integer)
   self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(mosek.fusion.SolutionType.Basic)
  def __flush_1initsol_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self.__flush_1initsol_Emosek_4fusion_4SolutionType_2(__0)
  def __flush_1initsol_Emosek_4fusion_4SolutionType_2(self,_0):
   if (self.__initsol_xx is not None): # src/fusion/Model.mbi:3572:12-30
    _1=self._task_1numvar_()
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    try:
     _3=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True)
     if ((_3.xx) is not None): # src/fusion/Model.mbi:3577:16-30
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_3.xx),0,_2,0,(int(((_3.xx)).shape[0]) if ((int(((_3.xx)).shape[0]) <= _1) ) else _1))
    except mosek_fusion_SolutionError as _4:
     pass
    _5=(int((self.__initsol_xx).shape[0]) if ((int((self.__initsol_xx).shape[0]) <= _1) ) else _1)
    for _6 in range(0,_5):
     if self.__initsol_xx_flag[_6]: # src/fusion/Model.mbi:3584:16-34
      _2[_6] = self.__initsol_xx[_6]
    _2[self.__bfixidx] = 1.0
    self._task_1putxx_1slice_Emosek_4fusion_4SolutionType_2II_3D(_0,0,_1,_2)
  @staticmethod
  def _match_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDualSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getDualSolutionStatus_alt_(self,):
    return self._getDualSolutionStatus_()
  def _getDualSolutionStatus_(self,):
   return (self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_getProblemStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getProblemStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getProblemStatus_alt_(self,):
    return self._getProblemStatus_()
  def _getProblemStatus_(self,):
   return (self._getProblemStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getPrimalSolutionStatus_alt_(self,):
    return self._getPrimalSolutionStatus_()
  def _getPrimalSolutionStatus_(self,):
   return (self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self.__solutionptr))
  @staticmethod
  def _match_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dualObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _dualObjValue_alt_(self,):
    return self._dualObjValue_()
  def _dualObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,False).dobj))
  @staticmethod
  def _match_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_primalObjValue_(*args):
    if len(args) != 0: return False
    return True
  def _primalObjValue_alt_(self,):
    return self._primalObjValue_()
  def _primalObjValue_(self,):
   return numpy.float64((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(mosek.fusion.SolutionType.Default,True).pobj))
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2ZZ(self,_t__0,_t__1,_t__2):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(__0,_1,_2)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(self,_0,_1,_2):
   _3=None
   _4=_0
   if (_4==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:3475:12-41
    _4 = self.__solutionptr
   if (_4==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:3477:12-41
    if (self.__sol_itg is not None): # src/fusion/Model.mbi:3479:18-33
     _3 = self.__sol_itg
    elif (self.__sol_bas is not None): # src/fusion/Model.mbi:3480:18-33
     _3 = self.__sol_bas
    else:
     _3 = self.__sol_itr
   elif (_4==mosek.fusion.SolutionType.Interior): # src/fusion/Model.mbi:3483:16-46
    _3 = self.__sol_itr
   elif (_4==mosek.fusion.SolutionType.Basic): # src/fusion/Model.mbi:3484:16-43
    _3 = self.__sol_bas
   elif (_4==mosek.fusion.SolutionType.Integer): # src/fusion/Model.mbi:3485:16-45
    _3 = self.__sol_itg
   if (_3 is None): # src/fusion/Model.mbi:3487:12-23
    raise mosek_fusion_SolutionError._ctor_S("Solution not available")
   else:
    if (_2 or ((_1 and _3._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)) or ((not _1) and _3._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self.__acceptable_sol)))): # src/fusion/Model.mbi:3493:14-3495:69
     return (_3)
    else:
     _5=mosek.fusion.Utils.StringBuffer()
     _6=(_3.pstatus)
     _7=(_3.probstatus)
     if (not _1): # src/fusion/Model.mbi:3504:16-26
      _6 = (_3.dstatus)
     _5._a_S("Solution status is ")
     if (_6==mosek.fusion.SolutionStatus.Undefined): # src/fusion/Model.mbi:3506:20-54
      _5._a_S("Undefined")
     elif (_6==mosek.fusion.SolutionStatus.Unknown): # src/fusion/Model.mbi:3507:20-52
      _5._a_S("Unknown")
     elif (_6==mosek.fusion.SolutionStatus.Optimal): # src/fusion/Model.mbi:3508:20-52
      _5._a_S("Optimal")
     elif (_6==mosek.fusion.SolutionStatus.Feasible): # src/fusion/Model.mbi:3509:20-53
      _5._a_S("Feasible")
     elif (_6==mosek.fusion.SolutionStatus.Certificate): # src/fusion/Model.mbi:3510:20-56
      _5._a_S("Certificate")
     elif (_6==mosek.fusion.SolutionStatus.IllposedCert): # src/fusion/Model.mbi:3511:20-57
      _5._a_S("IllposedCert")
     _5._a_S(" but ")
     if (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Anything): # src/fusion/Model.mbi:3513:20-64
      _5._a_S("Anything")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Optimal): # src/fusion/Model.mbi:3514:20-63
      _5._a_S("Optimal")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Feasible): # src/fusion/Model.mbi:3515:20-64
      _5._a_S("at least Feasible")
     elif (self.__acceptable_sol==mosek.fusion.AccSolutionStatus.Certificate): # src/fusion/Model.mbi:3516:20-67
      _5._a_S("Certificate")
     _5._a_S(" is expected. Reason: Accessing ")
     if (_3 is self.__sol_itr): # src/fusion/Model.mbi:3518:20-34
      _5._a_S("interior-point solution")
     elif (_3 is self.__sol_bas): # src/fusion/Model.mbi:3519:20-34
      _5._a_S("basic solution")
     elif (_3 is self.__sol_itg): # src/fusion/Model.mbi:3520:20-34
      _5._a_S("integer solution")
     _5._a_S(" whose problem status is ")
     if (_7==mosek.fusion.ProblemStatus.Unknown): # src/fusion/Model.mbi:3522:20-52
      _5._a_S("Unknown")
     elif (_7==mosek.fusion.ProblemStatus.PrimalAndDualFeasible): # src/fusion/Model.mbi:3523:20-66
      _5._a_S("PrimalAndDualFeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalFeasible): # src/fusion/Model.mbi:3524:20-59
      _5._a_S("PrimalFeasible")
     elif (_7==mosek.fusion.ProblemStatus.DualFeasible): # src/fusion/Model.mbi:3525:20-57
      _5._a_S("DualFeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalInfeasible): # src/fusion/Model.mbi:3526:20-61
      _5._a_S("PrimalInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.DualInfeasible): # src/fusion/Model.mbi:3527:20-59
      _5._a_S("DualInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.PrimalAndDualInfeasible): # src/fusion/Model.mbi:3528:20-68
      _5._a_S("PrimalAndDualInfeasible")
     elif (_7==mosek.fusion.ProblemStatus.IllPosed): # src/fusion/Model.mbi:3529:20-53
      _5._a_S("IllPosed")
     elif (_7==mosek.fusion.ProblemStatus.PrimalInfeasibleOrUnbounded): # src/fusion/Model.mbi:3530:20-72
      _5._a_S("PrimalInfeasibleOrUnbounded")
     _5._a_S(".")
     raise mosek_fusion_SolutionError._ctor_S(_5._toString_())
  def _get_1sol_1cache_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   return (self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,False))
  def _setSolution_1xx_alt__3I_3D(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._setSolution_1xx__3I_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setSolution_1xx__3I_3D(self,_0,_1):
   self._ensure_1initsol_1xx_()
   for _2 in range(0,int((_0).shape[0])):
    self.__initsol_xx[_0[_2]] = _1[_2]
    self.__initsol_xx_flag[_0[_2]] = True
  def _ensure_1initsol_1xx_alt_(self,):
    return self._ensure_1initsol_1xx_()
  def _ensure_1initsol_1xx_(self,):
   _0=self._task_1numvar_()
   if (self.__initsol_xx is None): # src/fusion/Model.mbi:3431:12-30
    self.__initsol_xx = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.array([False for _1 in range(0,_0)], dtype=numpy.dtype(bool))
   elif (int((self.__initsol_xx).shape[0]) < _0): # src/fusion/Model.mbi:3435:16-47
    _2=self.__initsol_xx
    _3=self.__initsol_xx_flag
    self.__initsol_xx = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self.__initsol_xx_flag = numpy.zeros((_0,), dtype=numpy.dtype(bool))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_2,0,self.__initsol_xx,0,int((_2).shape[0]))
    for _4 in range(0,int((_2).shape[0])):
     self.__initsol_xx_flag[_4] = _3[_4]
  def _getSolution_1accptr_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1accptr_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1accptr_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,True,True).accptr))
  def _getSolution_1accy_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1accy_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1accy_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).accy))
  def _getSolution_1accx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1accx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1accx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).accx))
  def _getSolution_1bars_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1bars_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1bars_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).bars))
  def _getSolution_1barx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1barx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1barx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).barx))
  def _getSolution_1y_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1y_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1y_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).y))
  def _getSolution_1xc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xc))
  def _getSolution_1suc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1suc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1suc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).suc))
  def _getSolution_1slc_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slc_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slc_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slc))
  def _getSolution_1sux_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1sux_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1sux_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).sux))
  def _getSolution_1slx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1slx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1slx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).slx))
  def _getSolution_1yx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1yx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1yx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,False).yx))
  def _getSolution_1xx_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getSolution_1xx_Emosek_4fusion_4SolutionType_2(__0)
  def _getSolution_1xx_Emosek_4fusion_4SolutionType_2(self,_0):
   return ((self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2Z(_0,True).xx))
  @staticmethod
  def _match_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_selectedSolution_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _selectedSolution_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._selectedSolution_Emosek_4fusion_4SolutionType_2(__0)
  def _selectedSolution_Emosek_4fusion_4SolutionType_2(self,_0):
   self.__solutionptr = _0
  @staticmethod
  def _match_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAcceptedSolutionStatus_(*args):
    if len(args) != 0: return False
    return True
  def _getAcceptedSolutionStatus_alt_(self,):
    return self._getAcceptedSolutionStatus_()
  def _getAcceptedSolutionStatus_(self,):
   return (self.__acceptable_sol)
  @staticmethod
  def _match_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _acceptedSolutionStatus_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _acceptedSolutionStatus_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   self.__acceptable_sol = _0
  @staticmethod
  def _match_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getProblemStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getProblemStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getProblemStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getProblemStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   _1=None
   if (_0==mosek.fusion.SolutionType.Default): # src/fusion/Model.mbi:3303:12-41
    if (self.__sol_itg is not None): # src/fusion/Model.mbi:3305:18-33
     _1 = self.__sol_itg
    elif (self.__sol_bas is not None): # src/fusion/Model.mbi:3306:18-33
     _1 = self.__sol_bas
    else:
     _1 = self.__sol_itr
   elif (_0==mosek.fusion.SolutionType.Interior): # src/fusion/Model.mbi:3309:16-46
    _1 = self.__sol_itr
   elif (_0==mosek.fusion.SolutionType.Basic): # src/fusion/Model.mbi:3310:16-43
    _1 = self.__sol_bas
   elif (_0==mosek.fusion.SolutionType.Integer): # src/fusion/Model.mbi:3311:16-45
    _1 = self.__sol_itg
   if (_1 is None): # src/fusion/Model.mbi:3313:12-23
    return (mosek.fusion.ProblemStatus.Unknown)
   else:
    return ((_1.probstatus))
  @staticmethod
  def _match_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getDualSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getDualSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,False))
  @staticmethod
  def _match_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4SolutionType_2__(_0))
  @staticmethod
  def _match_alt_getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4SolutionType_2__(_0))
  def _getPrimalSolutionStatus_alt_Emosek_4fusion_4SolutionType_2(self,_t__0):
    return self._getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(__0)
  def _getPrimalSolutionStatus_Emosek_4fusion_4SolutionType_2(self,_0):
   return (self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(_0,True))
  def _getSolutionStatus_alt_Emosek_4fusion_4SolutionType_2Z(self,_t__0,_t__1):
    return self._getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(__0,_1)
  def _getSolutionStatus_Emosek_4fusion_4SolutionType_2Z(self,_0,_1):
   try:
    _2=self._get_1sol_1cache_Emosek_4fusion_4SolutionType_2ZZ(_0,_1,True)
    if _1: # src/fusion/Model.mbi:3273:14-20
     return ((_2.pstatus))
    else:
     return ((_2.dstatus))
   except mosek_fusion_SolutionError as _3:
    return (mosek.fusion.SolutionStatus.Undefined)
  def _update_alt__3ILmosek_4fusion_4Expression_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._update__3ILmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3ILmosek_4fusion_4Expression_2(self,_0,_1):
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   _2=(self.__ws.nd)
   _3=(self.__ws.shape_base)
   _4=(self.__ws.nelem)
   _5=(self.__ws.nnz)
   _6=(self.__ws.hassp)
   _7=(self.__ws.ncodeatom)
   _8=(self.__ws.ptr_base)
   _9=(self.__ws.sp_base)
   _10=(self.__ws.nidxs_base)
   _11=(self.__ws.cof_base)
   _12=(self.__ws.code_base)
   _13=(self.__ws.codeptr_base)
   _14=(self.__ws.cconst_base)
   _15=(self.__ws.i32)
   _16=(self.__ws.i64)
   _17=(self.__ws.f64)
   _18=0
   _18 = fragments._c_closure_26(_0,_4,_18) # src/fusion/Model.mbi:3154:28-85
   _18 = numpy.int32(_18) # postprocess
   _19=(_4 - _18)
   if (_18==_4): # src/fusion/Model.mbi:3157:16-35
    self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(_0,self.__ws,_4,_5,_8,_10,_11)
    if (_7 > 0): # src/fusion/Model.mbi:3159:14-27
     self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_0,_8,_10,_13,_12,_14)
    else:
     self.__con_blocks._clear_1row_1code__3I(_0)
   elif (_19==_4): # src/fusion/Model.mbi:3164:16-35
    self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(numpy.array([(- (1 + _0[_20])) for _20 in range(0,_4)], dtype=numpy.dtype(numpy.int32)),0,self.__ws,_4,_5,_8,_10,_11)
    if (_7 > 0): # src/fusion/Model.mbi:3166:14-27
     self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,numpy.array([(- (1 + _0[_21])) for _21 in range(0,_4)], dtype=numpy.dtype(numpy.int32)),_8,_10,_13,_12,_14)
    else:
     self.__afe_blocks._clear_1row_1code__3I(numpy.array([(- (1 + _0[_22])) for _22 in range(0,_4)], dtype=numpy.dtype(numpy.int32)))
   else:
    _23=0
    _24=0
    _25=0
    _26=0
    _25,_26 = fragments._c_closure_27(_25,_0,_26,_4,_8,_15) # src/fusion/Model.mbi:3173:10-3175:77
    _25 = numpy.int32(_25) # postprocess
    _26 = numpy.int32(_26) # postprocess
    _27=self.__xs._alloci32_I(_18)
    _28=self.__xs._alloci32_I(_19)
    _29=self.__xs._alloci32_I((_18 + 1))
    _30=self.__xs._alloci32_I((_19 + 1))
    _31=self.__xs._alloci64_I(_26)
    _32=self.__xs._alloci64_I(_25)
    _33=self.__xs._allocf64_I(_26)
    _34=self.__xs._allocf64_I(_25)
    _35=(self.__xs.f64)
    _36=(self.__xs.i64)
    _37=(self.__xs.i32)
    _37[_29] = 0
    _37[_30] = 0
    _38=0
    _39=0
    _40=0
    _41=0
    for _42 in range(0,_4):
     _43=_15[(_8 + _42)]
     _44=_15[((_8 + _42) + 1)]
     if (_0[_42] >= 0): # src/fusion/Model.mbi:3194:16-31
      mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_16,(_10 + _43),_36,(_31 + _41),(_44 - _43))
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_17,(_11 + _43),_35,(_33 + _41),(_44 - _43))
      _41 += (_44 - _43)
      _37[(_27 + _39)] = _0[_42]
      _37[((_29 + _39) + 1)] = _41
      _39 += 1
     else:
      mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_16,(_10 + _43),_36,(_32 + _40),(_44 - _43))
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_17,(_11 + _43),_35,(_34 + _40),(_44 - _43))
      _40 += (_44 - _43)
      _37[(_28 + _38)] = (- (1 + _0[_42]))
      _37[((_30 + _38) + 1)] = _40
      _38 += 1
    self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(numpy.array([_37[(_27 + _45)] for _45 in range(0,_18)], dtype=numpy.dtype(numpy.int32)),self.__xs,_18,_26,_29,_31,_33)
    self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_37,_28,self.__xs,_19,_25,_30,_32,_34)
    if (_7 > 0): # src/fusion/Model.mbi:3215:14-27
     _23,_24 = fragments._c_closure_28(_23,_13,_0,_24,_4,_8,_15) # src/fusion/Model.mbi:3216:12-3218:112
     _23 = numpy.int32(_23) # postprocess
     _24 = numpy.int32(_24) # postprocess
     _46=self.__xs._alloci32_I((_26 + 1))
     _47=self.__xs._alloci32_I((_25 + 1))
     _48=self.__xs._alloci32_I(_24)
     _49=self.__xs._alloci32_I(_23)
     _50=self.__xs._allocf64_I(_24)
     _51=self.__xs._allocf64_I(_23)
     _37[_46] = 0
     _37[_47] = 0
     _52=0
     _53=0
     _54=0
     _55=0
     for _56 in range(0,_4):
      _57=_15[(_8 + _56)]
      _58=_15[((_8 + _56) + 1)]
      if (_0[_56] >= 0): # src/fusion/Model.mbi:3236:18-33
       mosek.fusion.Utils.Tools._arraycopy__3II_3III(_15,(_12 + _15[(_13 + _57)]),_37,(_48 + _53),(_15[(_13 + _58)] - _15[(_13 + _57)]))
       mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_17,(_14 + _15[(_13 + _57)]),_35,(_50 + _53),(_15[(_13 + _58)] - _15[(_13 + _57)]))
       _53,_55 = fragments._c_closure_29(_13,_53,_46,_55,_57,_58,_15,_37) # src/fusion/Model.mbi:3239:16-3243:17
       _53 = numpy.int32(_53) # postprocess
       _55 = numpy.int32(_55) # postprocess
      else:
       mosek.fusion.Utils.Tools._arraycopy__3II_3III(_15,(_12 + _15[(_13 + _57)]),_37,(_49 + _52),(_15[(_13 + _58)] - _15[(_13 + _57)]))
       mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_17,(_14 + _15[(_13 + _57)]),_35,(_51 + _52),(_15[(_13 + _58)] - _15[(_13 + _57)]))
       _52,_40 = fragments._c_closure_30(_52,_47,_40,_13,_57,_58,_15,_37) # src/fusion/Model.mbi:3248:16-3252:17
       _52 = numpy.int32(_52) # postprocess
       _40 = numpy.int32(_40) # postprocess
     self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__xs,numpy.array([_37[(_27 + _59)] for _59 in range(0,_18)], dtype=numpy.dtype(numpy.int32)),_29,_31,_46,_48,_50)
     self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__xs,numpy.array([numpy.int32(_36[(_28 + _60)]) for _60 in range(0,_19)], dtype=numpy.dtype(numpy.int32)),_30,_32,_47,_49,_51)
    else:
     self.__con_blocks._clear_1row_1code__3I(numpy.array([_37[(_27 + _61)] for _61 in range(0,_18)], dtype=numpy.dtype(numpy.int32)))
     self.__afe_blocks._clear_1row_1code__3I(numpy.array([numpy.int32(_36[(_28 + _62)]) for _62 in range(0,_19)], dtype=numpy.dtype(numpy.int32)))
   self.__xs._clear_()
  def _update_alt__3ILmosek_4fusion_4Expression_2_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._update__3ILmosek_4fusion_4Expression_2_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3ILmosek_4fusion_4Expression_2_3I(self,_0,_1,_2):
   for _3 in range(0,int((_0).shape[0])):
    if ((_0[_3] >= 0) and self.__con_blocks._row_1is_1parameterized_I(_3)): # src/fusion/Model.mbi:2919:18-72
     raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized constraint")
    elif ((_0[_3] < 0) and self.__con_blocks._row_1is_1parameterized_I((- (_3 + 1)))): # src/fusion/Model.mbi:2921:18-77
     raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized constraint")
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   _4=(self.__ws.nd)
   _5=(self.__ws.nelem)
   _6=(self.__ws.nnz)
   _7=(self.__ws.hassp)
   _8=(self.__ws.ncodeatom)
   _9=(self.__ws.shape_base)
   _10=(self.__ws.ptr_base)
   _11=(self.__ws.sp_base)
   _12=(self.__ws.nidxs_base)
   _13=(self.__ws.cof_base)
   _14=(self.__ws.code_base)
   _15=(self.__ws.codeptr_base)
   _16=(self.__ws.cconst_base)
   _17=(self.__ws.i32)
   _18=(self.__ws.i64)
   _19=(self.__ws.f64)
   _20=0
   _20 = fragments._c_closure_31(_0,_5,_20) # src/fusion/Model.mbi:2947:28-85
   _20 = numpy.int32(_20) # postprocess
   _21=(_5 - _20)
   if ((_20==_5) or (_21==_5)): # src/fusion/Model.mbi:2950:16-58
    _22=(int((_0).shape[0]) * int((_2).shape[0]))
    _23=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
    _24=0
    _24 = fragments._c_closure_32(_23,_13,_5,_12,_24,_10,_2,_19,_17,_18) # src/fusion/Model.mbi:2955:10-2969:11
    _24 = numpy.int32(_24) # postprocess
    _25=numpy.array([_2[_27] for _26 in range(0,_5) for _27 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
    if (_20==_5): # src/fusion/Model.mbi:2972:14-33
     _28=numpy.array([_0[_29] for _29 in range(0,_5) for _30 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
     self._task_1putaijlist__3I_3I_3DJ(_28,_25,_23,_24)
     if (_8 > 0): # src/fusion/Model.mbi:2975:16-29
      self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_0,_10,_12,_15,_14,_16)
    else:
     _31=numpy.array([(- (_0[_32] + 1)) for _32 in range(0,_5) for _33 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
     self._task_1putafefijlist__3I_3I_3D(_31,_25,_23)
     if (_8 > 0): # src/fusion/Model.mbi:2981:16-29
      self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,numpy.array([(- (1 + _0[_34])) for _34 in range(0,_5)], dtype=numpy.dtype(numpy.int32)),_10,_12,_15,_14,_16)
   else:
    _35=(_21 * int((_2).shape[0]))
    _36=(_20 * int((_2).shape[0]))
    _37=numpy.zeros((_36,), dtype=numpy.dtype(numpy.float64))
    _38=numpy.zeros((_35,), dtype=numpy.dtype(numpy.float64))
    _39=numpy.array([_2[_41] for _40 in range(0,_20) for _41 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _42=numpy.array([_2[_44] for _43 in range(0,_21) for _44 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _45=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int32))
    _46=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int32))
    _47=0
    _48=0
    _49=0
    _50=0
    _51=0
    _52=0
    _51,_52 = fragments._c_closure_33(_38,_51,_13,_0,_46,_37,_52,_45,_5,_12,_10,_2,_19,_17,_18) # src/fusion/Model.mbi:2996:10-3025:11
    _51 = numpy.int32(_51) # postprocess
    _52 = numpy.int32(_52) # postprocess
    self._task_1putaijlist__3I_3I_3DJ(_45,_39,_37,_52)
    self._task_1putafefijlist__3I_3I_3D(_46,_42,_38)
    if (_8 > 0): # src/fusion/Model.mbi:3031:14-27
     _51,_52 = fragments._c_closure_34(_51,_0,_52,_5,_10,_17) # src/fusion/Model.mbi:3032:12-3034:79
     _51 = numpy.int32(_51) # postprocess
     _52 = numpy.int32(_52) # postprocess
     _53=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int32))
     _54=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int32))
     _55=self.__xs._alloci32_I((_20 + 1))
     _56=self.__xs._alloci32_I((_21 + 1))
     _57=self.__xs._alloci64_I(_52)
     _58=self.__xs._alloci64_I(_51)
     _59=(self.__xs.f64)
     _60=(self.__xs.i64)
     _61=(self.__xs.i32)
     _61[_55] = 0
     _61[_56] = 0
     _62=0
     _63=0
     _64=0
     _65=0
     _62,_64,_63,_65 = fragments._c_closure_35(_62,_64,_0,_56,_54,_63,_65,_55,_53,_5,_10,_17,_61) # src/fusion/Model.mbi:3047:12-3062:13
     _62 = numpy.int32(_62) # postprocess
     _64 = numpy.int32(_64) # postprocess
     _63 = numpy.int32(_63) # postprocess
     _65 = numpy.int32(_65) # postprocess
     _49,_50 = fragments._c_closure_36(_49,_15,_0,_50,_5,_10,_17) # src/fusion/Model.mbi:3064:12-3066:112
     _49 = numpy.int32(_49) # postprocess
     _50 = numpy.int32(_50) # postprocess
     _66=self.__xs._alloci32_I((_52 + 1))
     _67=self.__xs._alloci32_I((_51 + 1))
     _68=self.__xs._alloci32_I(_50)
     _69=self.__xs._alloci32_I(_49)
     _70=self.__xs._allocf64_I(_50)
     _71=self.__xs._allocf64_I(_49)
     _61[_66] = 0
     _61[_67] = 0
     _72=0
     _73=0
     _74=0
     _75=0
     for _76 in range(0,_5):
      _77=_17[(_10 + _76)]
      _78=_17[((_10 + _76) + 1)]
      if (_0[_76] >= 0): # src/fusion/Model.mbi:3084:18-33
       mosek.fusion.Utils.Tools._arraycopy__3II_3III(_17,(_14 + _17[(_15 + _77)]),_61,(_68 + _73),(_17[(_15 + _78)] - _17[(_15 + _77)]))
       mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_19,(_16 + _17[(_15 + _77)]),_59,(_70 + _73),(_17[(_15 + _78)] - _17[(_15 + _77)]))
       _73,_75 = fragments._c_closure_37(_15,_73,_66,_75,_77,_78,_17,_61) # src/fusion/Model.mbi:3087:16-3091:17
       _73 = numpy.int32(_73) # postprocess
       _75 = numpy.int32(_75) # postprocess
      else:
       mosek.fusion.Utils.Tools._arraycopy__3II_3III(_17,(_14 + _17[(_15 + _77)]),_61,(_69 + _72),(_17[(_15 + _78)] - _17[(_15 + _77)]))
       mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_19,(_16 + _17[(_15 + _77)]),_59,(_71 + _72),(_17[(_15 + _78)] - _17[(_15 + _77)]))
       _72,_64 = fragments._c_closure_38(_72,_67,_64,_15,_77,_78,_17,_61) # src/fusion/Model.mbi:3096:16-3100:17
       _72 = numpy.int32(_72) # postprocess
       _64 = numpy.int32(_64) # postprocess
     self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__xs,_53,_55,_57,_66,_68,_70)
     self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__xs,_54,_56,_58,_67,_69,_71)
    else:
     _79=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int32))
     _80=numpy.zeros((_21,), dtype=numpy.dtype(numpy.int32))
     _81=0
     _82=0
     _81,_82 = fragments._c_closure_39(_81,_0,_80,_82,_79,_5) # src/fusion/Model.mbi:3111:12-3120:13
     _81 = numpy.int32(_81) # postprocess
     _82 = numpy.int32(_82) # postprocess
     self.__con_blocks._clear_1row_1code__3I(_79)
     self.__afe_blocks._clear_1row_1code__3I(_80)
   self.__xs._clear_()
  @staticmethod
  def _match_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  def _updateObjective_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1):
    return self._updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  def _updateObjective_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_0,_1):
   if (_0._getSize_()!=1): # src/fusion/Model.mbi:2830:12-31
    raise mosek_fusion_DimensionError._ctor_S("Invalid expression size for objective")
   if ((self.__obj_blocks.code_used) > 0): # src/fusion/Model.mbi:2832:12-36
    raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized constraint")
   _2=_1._numInst_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   if (_2 < _1._getSize_()): # src/fusion/Model.mbi:2837:12-28
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _1._inst_I_3JI_3J(0,_4,0,_3)
   else:
    _1._inst_I_3J(0,_3)
   for _5 in range(0,_2):
    if (_3[_5] < 0): # src/fusion/Model.mbi:2845:14-29
     raise mosek_fusion_UpdateError._ctor_S("Updating semidefinite terms is currently not possible")
   _6=True
   _6 = fragments._c_closure_40(_2,_3,_6) # src/fusion/Model.mbi:2849:8-2850:78
   _7=None
   if _6: # src/fusion/Model.mbi:2852:12-28
    _7 = numpy.array([numpy.int32(_3[_8]) for _8 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   else:
    _9=numpy.array([_10 for _10 in range((- 1),_2)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_9,_3,None,0,_2)
    _7 = numpy.array([numpy.int32(_3[_9[_11]]) for _11 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _12=int((_7).shape[0])
   _13=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
   _14=_7
   mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_0))._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__ws,self.__rs,self.__xs)
   self.__ws._pop_1expr_()
   pass
   _15=(self.__ws.nd)
   _16=(self.__ws.nelem)
   _17=(self.__ws.nnz)
   _18=(self.__ws.hassp)
   _19=(self.__ws.ncodeatom)
   _20=(self.__ws.shape_base)
   _21=(self.__ws.ptr_base)
   _22=(self.__ws.sp_base)
   _23=(self.__ws.nidxs_base)
   _24=(self.__ws.cof_base)
   _25=(self.__ws.code_base)
   _26=(self.__ws.codeptr_base)
   _27=(self.__ws.cconst_base)
   pass
   if (_19 > 0): # src/fusion/Model.mbi:2882:12-25
    raise mosek_fusion_UpdateError._ctor_S("Cannot update parameterized objective")
   _28=(self.__ws.i32)
   _29=(self.__ws.i64)
   _30=(self.__ws.f64)
   _31=0
   _31 = fragments._c_closure_41(_13,_24,_31,_16,_23,_21,_7,_30,_28,_29) # src/fusion/Model.mbi:2890:8-2905:9
   _31 = numpy.int32(_31) # postprocess
   self._task_1putclist__3I_3D(_14,_13)
   if (_19 > 0): # src/fusion/Model.mbi:2910:12-25
    self.__obj_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,numpy.array([0], dtype=numpy.dtype(numpy.int32)),_21,_23,_26,_25,_27)
  def __parameter_1unchecked_alt_S_3I_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self.__parameter_1unchecked_S_3I_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __parameter_1unchecked_S_3I_3J(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self.__par_map._hasItem_S(_0)): # src/fusion/Model.mbi:2782:12-51
    raise mosek_fusion_NameError._ctor_S("Duplicate parameter name")
   _3=mosek.fusion.Set._size__3I(_1)
   _4=(int((_2).shape[0]) if ((_2 is not None) ) else numpy.int32(_3))
   if (self.__param_value is None): # src/fusion/Model.mbi:2788:12-31
    self.__param_value = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   else:
    if ((self.__param_num + _4) > int((self.__param_value).shape[0])): # src/fusion/Model.mbi:2791:17-51
     _5=self.__param_value
     _6=((2 * int((_5).shape[0])) if (((2 * int((_5).shape[0])) > (int((_5).shape[0]) + _4)) ) else (int((_5).shape[0]) + _4))
     self.__param_value = numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
     if (self.__param_num > 0): # src/fusion/Model.mbi:2795:14-27
      mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_5,0,self.__param_value,0,self.__param_num)
   _7=mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self,_1,_2,numpy.array([(self.__param_num + _8) for _8 in range(0,numpy.int32(_4))], dtype=numpy.dtype(numpy.int32)))
   self.__param_num += _4
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2802:12-25
    if ((self.__parameters is None) or (self.__numparameter==int((self.__parameters).shape[0]))): # src/fusion/Model.mbi:2803:14-67
     _9=self.__parameters
     self.__parameters = numpy.array([None for _10 in range(0,((self.__numparameter * 2) + 64))], dtype=numpy.dtype(object))
     for _11 in range(0,self.__numparameter):
      self.__parameters[_11] = _9[_11]
    self.__parameters[self.__numparameter] = _7
    self.__par_map._setItem_SI(_0,self.__numparameter)
    self.__numparameter += 1
   return (_7)
  def __parameter_1_alt_S_3I_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self.__parameter_1_S_3I_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __parameter_1_S_3I_3J(self,_0,_1,_2):
   _3=True
   _4=int((_1).shape[0])
   if ((_2 is not None) and (int((_2).shape[0]) > 0)): # src/fusion/Model.mbi:2769:12-36
    _5=(_2[(int((_2).shape[0]) - 1)] < mosek.fusion.Set._size__3I(_1))
    _5 = fragments._c_closure_42(_5,_2) # src/fusion/Model.mbi:2771:10-2772:40
    if (not _5): # src/fusion/Model.mbi:2774:14-20
     raise mosek_fusion_IndexError._ctor_S("Unordered sparsity pattern")
   return (self.__parameter_1unchecked_S_3I_3J(_0,_1,_2))
  def __parameter_1_alt_S_3I_3_5I(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,ndmin=_monty.checkShape(_t__2,2),dtype=numpy.dtype(numpy.int32))
   _1 = self.__parameter_1_S_3I_3_5I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __parameter_1_S_3I_3_5I(self,_0,_1,_2):
   _3=int((_2).shape[0])
   _4=int((_2).shape[1])
   if (int((_1).shape[0])!=_4): # src/fusion/Model.mbi:2746:12-27
    raise mosek_fusion_LengthError._ctor_S("Invalid sparsity")
   if (_2 is None): # src/fusion/Model.mbi:2749:12-28
    return (self.__parameter_1unchecked_S_3I_3J(_0,_1,None))
   else:
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
    _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
    _6[(_4 - 1)] = 1
    fragments._c_closure_43(_4,_1,_6) # src/fusion/Model.mbi:2755:10-72
    fragments._c_closure_44(_4,_3,_5,_2,_6) # src/fusion/Model.mbi:2756:10-2759:11
    return (self.__parameter_1_S_3I_3J(_0,_1,_5))
  @staticmethod
  def _match_parameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_parameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _parameter_alt_S(self,_t__0):
    return self._parameter_S(_0)
  def _parameter_S(self,_0):
   _1=None
   return (self.__parameter_1_S_3I_3J(_0,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_parameter_SIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_parameter_SIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3))
  def _parameter_alt_SIII(self,_t__0,_t__1,_t__2,_t__3):
    return self._parameter_SIII(_0,numpy.int32(__1),numpy.int32(__2),numpy.int32(__3))
  def _parameter_SIII(self,_0,_1,_2,_3):
   _4=None
   return (self.__parameter_1_S_3I_3J(_0,numpy.array([_1,_2,_3], dtype=numpy.dtype(numpy.int32)),_4))
  @staticmethod
  def _match_parameter_SII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_parameter_SII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _parameter_alt_SII(self,_t__0,_t__1,_t__2):
    return self._parameter_SII(_0,numpy.int32(__1),numpy.int32(__2))
  def _parameter_SII(self,_0,_1,_2):
   _3=None
   return (self.__parameter_1_S_3I_3J(_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_parameter_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_parameter_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _parameter_alt_SI(self,_t__0,_t__1):
    return self._parameter_SI(_0,numpy.int32(__1))
  def _parameter_SI(self,_0,_1):
   _2=None
   return (self.__parameter_1_S_3I_3J(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_parameter_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_parameter_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1))
  def _parameter_alt_S_3I(self,_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._parameter_S_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter_S_3I(self,_0,_1):
   _2=None
   return (self.__parameter_1_S_3I_3J(_0,_1,_2))
  @staticmethod
  def _match_parameter_S_3I_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_parameter_S_3I_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3J__(_2))
  def _parameter_alt_S_3I_3J(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._parameter_S_3I_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter_S_3I_3J(self,_0,_1,_2):
   return (self.__parameter_1_S_3I_3J(_0,_1,_2))
  @staticmethod
  def _match_parameter_S_3I_3_5I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match__3_5I__(_2))
  @staticmethod
  def _match_alt_parameter_S_3I_3_5I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3_5I__(_2))
  def _parameter_alt_S_3I_3_5I(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,ndmin=_monty.checkShape(_t__2,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._parameter_S_3I_3_5I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter_S_3I_3_5I(self,_0,_1,_2):
   return (self.__parameter_1_S_3I_3_5I(_0,_1,_2))
  @staticmethod
  def _match_parameter_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_parameter_(*args):
    if len(args) != 0: return False
    return True
  def _parameter_alt_(self,):
    return self._parameter_()
  def _parameter_(self,):
   _0=None
   return (self.__parameter_1_S_3I_3J("",numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),_0))
  @staticmethod
  def _match_parameter_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_parameter_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _parameter_alt_III(self,_t__0,_t__1,_t__2):
    return self._parameter_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _parameter_III(self,_0,_1,_2):
   _3=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_parameter_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_parameter_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _parameter_alt_II(self,_t__0,_t__1):
    return self._parameter_II(numpy.int32(__0),numpy.int32(__1))
  def _parameter_II(self,_0,_1):
   _2=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_parameter_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_parameter_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _parameter_alt_I(self,_t__0):
    return self._parameter_I(numpy.int32(__0))
  def _parameter_I(self,_0):
   _1=None
   return (self.__parameter_1_S_3I_3J("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_parameter__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_parameter__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _parameter_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._parameter__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter__3I(self,_0):
   _1=None
   return (self.__parameter_1_S_3I_3J("",_0,_1))
  @staticmethod
  def _match_parameter__3I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_parameter__3I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3J__(_1))
  def _parameter_alt__3I_3J(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._parameter__3I_3J(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter__3I_3J(self,_0,_1):
   return (self.__parameter_1_S_3I_3J("",_0,_1))
  @staticmethod
  def _match_parameter__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_parameter__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1))
  def _parameter_alt__3I_3_5I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._parameter__3I_3_5I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _parameter__3I_3_5I(self,_0,_1):
   return (self.__parameter_1_S_3I_3_5I("",_0,_1))
  def __objective_1_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def __objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self._task_1putobjectivename_S(_0)
   _3=mosek_fusion_WorkStack._ctor_()
   _4=mosek_fusion_WorkStack._ctor_()
   _5=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_2)))
   _5._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_3,_4,self.__xs)
   _3._pop_1expr_()
   _6=(_3.i32)
   _7=(_3.i64)
   _8=(_3.f64)
   _9=(_3.nd)
   _10=(_3.nelem)
   _11=(_3.nnz)
   _12=(_3.hassp)
   _13=(_3.ncodeatom)
   _14=(_3.ptr_base)
   _15=(_3.shape_base)
   _16=(_3.nidxs_base)
   _17=(_3.cof_base)
   _18=(_3.code_base)
   _19=(_3.codeptr_base)
   _20=(_3.cconst_base)
   _21=1
   _9 = fragments._c_closure_45(_9,_6,_15) # src/fusion/Model.mbi:2662:29-74
   _9 = numpy.int32(_9) # postprocess
   if (_21!=1): # src/fusion/Model.mbi:2664:12-26
    raise mosek_fusion_LengthError._ctor_S("Invalid expression size for objective")
   if (_10!=1): # src/fusion/Model.mbi:2666:12-22
    raise mosek_fusion_LengthError._ctor_S("Invalid expression for objective")
   _22=0
   _23=0
   _22,_23 = fragments._c_closure_46(_22,_16,_11,_23,_7) # src/fusion/Model.mbi:2672:8-2675:9
   _22 = numpy.int32(_22) # postprocess
   _23 = numpy.int32(_23) # postprocess
   _24=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   _25=numpy.zeros((_22,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_47(_25,_17,_16,_11,_8,_7,_24) # src/fusion/Model.mbi:2682:8-2691:9
   self._task_1putobjective_Z_3I_3DD((_1==mosek.fusion.ObjectiveSense.Maximize),_24,_25,0.0)
   if (_23 > 0): # src/fusion/Model.mbi:2696:12-21
    _26=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
    _27=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
    _28=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
    _29=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_48(self.__barvar_block_elm_barj,self.__barvar_block_elm_i,self.__barvar_block_elm_j,_17,_16,_23,_8,_7,_26,_27,_28,_29) # src/fusion/Model.mbi:2702:10-2708:11
    self._task_1putbarc__3I_3I_3I_3D(_26,_27,_28,_29)
   if (_13 > 0): # src/fusion/Model.mbi:2716:12-25
    self.__obj_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(_3,numpy.array([0], dtype=numpy.dtype(numpy.int32)),_14,_16,_19,_18,_20)
  @staticmethod
  def _match_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_objective_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _objective_alt_D(self,_t__0):
    return self._objective_D(numpy.float64(__0))
  def _objective_D(self,_0):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_0))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2D(__0,numpy.float64(__1))
  def _objective_Emosek_4fusion_4ObjectiveSense_2D(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  def _objective_alt_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1):
    return self._objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(__0,_1)
  def _objective_Emosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2("",_0,_1)
  @staticmethod
  def _match_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_objective_SD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_D__(_1))
  def _objective_alt_SD(self,_t__0,_t__1):
    return self._objective_SD(_0,numpy.float64(__1))
  def _objective_SD(self,_0,_1):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,mosek.fusion.ObjectiveSense.Minimize,mosek.fusion.Expr._constTerm_D(_1))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_D__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2D(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2D(_0,__1,numpy.float64(__2))
  def _objective_SEmosek_4fusion_4ObjectiveSense_2D(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,mosek.fusion.Expr._constTerm_D(_2))
  @staticmethod
  def _match_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  def _objective_alt_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_t__0,_t__1,_t__2):
    return self._objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,__1,_2)
  def _objective_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(self,_0,_1,_2):
   self.__objective_1_SEmosek_4fusion_4ObjectiveSense_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _constraint_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1)
  def _constraint_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2("",_0,_1))
  @staticmethod
  def _match_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _constraint_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def _constraint_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4PSDDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4PSDDomain_2(_0)
  def _variable_Lmosek_4fusion_4PSDDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",(_0._shape),_0))
  @staticmethod
  def _match_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_IILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_IILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_IILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),numpy.int32(__1),_2)
  def _variable_IILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",numpy.array([_1,_0,_0], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4PSDDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2("",numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4PSDDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4PSDDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  @staticmethod
  def _match_alt_variable_SIILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_3))
  def _variable_alt_SIILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2,_t__3):
    return self._variable_SIILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),numpy.int32(__2),_3)
  def _variable_SIILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2,_3):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,numpy.array([_2,_1,_1], dtype=numpy.dtype(numpy.int32)),_3))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4PSDDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,numpy.array([_1,_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4ConeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4ConeDomain_2(_0)
  def _variable_Lmosek_4fusion_4ConeDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4RangeDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4RangeDomain_2(_0)
  def _variable_Lmosek_4fusion_4RangeDomain_2(self,_0):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",None,_0))
  @staticmethod
  def _match_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_variable_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  def _variable_alt_Lmosek_4fusion_4LinearDomain_2(self,_t__0):
    return self._variable_Lmosek_4fusion_4LinearDomain_2(_0)
  def _variable_Lmosek_4fusion_4LinearDomain_2(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",None,_0))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4ConeDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4RangeDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable__3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt__3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _1 = self._variable__3ILmosek_4fusion_4LinearDomain_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",_0,_1))
  @staticmethod
  def _match_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_variable__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _variable_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable__3I(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",_0,mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4ConeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4RangeDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_ILmosek_4fusion_4LinearDomain_2(numpy.int32(__0),_1)
  def _variable_ILmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),_1))
  @staticmethod
  def _match_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_variable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _variable_alt_I(self,_t__0):
    return self._variable_I(numpy.int32(__0))
  def _variable_I(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.array([_0], dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_variable_(*args):
    if len(args) != 0: return False
    return True
  def _variable_alt_(self,):
    return self._variable_()
  def _variable_(self,):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2("",numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4ConeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4ConeDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4RangeDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4RangeDomain_2(self,_0,_1):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  @staticmethod
  def _match_alt_variable_SLmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_1))
  def _variable_alt_SLmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1):
    return self._variable_SLmosek_4fusion_4LinearDomain_2(_0,_1)
  def _variable_SLmosek_4fusion_4LinearDomain_2(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,None,_1))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_S_3ILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self._variable_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3ILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2))
  @staticmethod
  def _match_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_variable_S_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match__3I__(_1))
  def _variable_alt_S_3I(self,_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._variable_S_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _variable_S_3I(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4ConeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4RangeDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   return (self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1) and __arg_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  @staticmethod
  def _match_alt_variable_SILmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_2))
  def _variable_alt_SILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self._variable_SILmosek_4fusion_4LinearDomain_2(_0,numpy.int32(__1),_2)
  def _variable_SILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),_2))
  @staticmethod
  def _match_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_variable_SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_S__(_0) and __arg_alt_match_I__(_1))
  def _variable_alt_SI(self,_t__0,_t__1):
    return self._variable_SI(_0,numpy.int32(__1))
  def _variable_SI(self,_0,_1):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  @staticmethod
  def _match_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_variable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _variable_alt_S(self,_t__0):
    return self._variable_S(_0)
  def _variable_S(self,_0):
   return (self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),mosek.fusion.Domain._unbounded_()))
  def _removeConstraintBlock_alt_I(self,_t__0):
    return self._removeConstraintBlock_I(numpy.int32(__0))
  def _removeConstraintBlock_I(self,_0):
   if (_0 >= 0): # src/fusion/Model.mbi:2554:12-22
    self.__con_1release_I(_0)
   else:
    self.__acon_1release_I((- (1 + _0)))
  def _removeVariableBlock_alt_J(self,_t__0):
    return self._removeVariableBlock_J(numpy.int64(__0))
  def _removeVariableBlock_J(self,_0):
   if (self.__con_blocks._is_1parameterized_() or self.__afe_blocks._is_1parameterized_()): # src/fusion/Model.mbi:2526:12-2527:41
    raise mosek_fusion_DeletionError._ctor_S("Cannot remove variables in parameterized model")
   if (_0 < 0): # src/fusion/Model.mbi:2530:12-23
    raise mosek_fusion_DeletionError._ctor_S("PSD variables cannot be removed")
   else:
    _1=numpy.int32(_0)
    _2=self.__var_block_map._blocksize_I(_1)
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    self.__var_block_map._get_I_3II(_1,_3,0)
    self.__var_block_map._free_I(_1)
    _4=self.__var_block_acc_id[_1]
    if (_4 >= 0): # src/fusion/Model.mbi:2543:14-24
     self._removeConstraintBlock_I(_4)
    self._task_1var_1putboundlist_1fr__3I(_3)
    self._task_1clearacollist__3I(_3)
  def __ranged_1variable_alt_S_3ILmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __ranged_1variable_S_3ILmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:2447:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=_2._finalize_1and_1validate__3I(_1)
   _4=(_3._shape)
   _5=int((_4).shape[0])
   _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_49(_5,_4,_6) # src/fusion/Model.mbi:2454:36-135
   _7=(_3._domsize)
   _8=None
   if (_8 is not None): # src/fusion/Model.mbi:2460:12-28
    if (int(((_3._sparsity)).shape[1])!=_5): # src/fusion/Model.mbi:2461:14-39
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
    _8 = numpy.zeros((int(((_3._sparsity)).shape[0]),), dtype=numpy.dtype(numpy.int64))
    for _9 in range(0,int(((_3._sparsity)).shape[0])):
     for _10 in range(0,int(((_3._sparsity)).shape[1])):
      if (((_3._sparsity)[_9,_10] < 0) or ((_3._sparsity)[_9,_10] >= _4[_10])): # src/fusion/Model.mbi:2468:18-72
       raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
     _11=0
     for _12 in range(0,int(((_3._sparsity)).shape[1])):
      _11 += (_6[_12] * (_3._sparsity)[_9,_12])
     _8[_9] = _11
   _13=numpy.int32((_3._nelements))
   if (_3._scalable): # src/fusion/Model.mbi:2479:12-24
    _14 = numpy.array([(_3._lb)[0] for _16 in range(0,_13)], dtype=numpy.dtype(numpy.float64))
    _15 = numpy.array([(_3._ub)[0] for _17 in range(0,_13)], dtype=numpy.dtype(numpy.float64))
   else:
    _14 = (_3._lb)
    _15 = (_3._ub)
   _18=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _19=self.__linearvar_1alloc_I_3I(_13,_18)
   self._task_1var_1putboundlist_1ra__3I_3D_3D(_18,_14,_15)
   _20=mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,_0,_19,_4,_8,_18)
   if (_3._cardinal_flag): # src/fusion/Model.mbi:2497:12-29
    self._task_1var_1putintlist__3I(_18)
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2500:12-25
    _21=mosek.fusion.Utils.StringBuffer()
    _21._a_S(_0)._a_S("[")
    if (_5 > 0): # src/fusion/Model.mbi:2503:14-20
     _21._a_S("%0")
     for _22 in range(1,_5):
      _21._a_S(",%")._a_I(_22)
    _21._a_S("]")
    if ((_3._indexnames) is not None): # src/fusion/Model.mbi:2509:14-36
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_18,_21._toString_(),_4,_8,(_3._indexnames))
    else:
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_18,_21._toString_(),_4,_8,None)
    self.__var_map._setItem_SI(_0,_19)
   self.__vars[_19] = _20
   return (_20)
  def __variable_1_alt_S_3ILmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4ConeDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   _3=_2._finalize_1and_1validate__3I(_1)
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:2193:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _4=(_3._shape)
   _5=int((_4).shape[0])
   _6=_3._getAxis_()
   _7=_4[_6]
   _8=1
   _9=1
   _10=1
   _10 = fragments._c_closure_50(_10,_5,_4) # src/fusion/Model.mbi:2286:8-57
   _10 = numpy.int32(_10) # postprocess
   _9 = fragments._c_closure_51(_6,_9,_4) # src/fusion/Model.mbi:2287:8-57
   _9 = numpy.int32(_9) # postprocess
   _8 = fragments._c_closure_52(_6,_8,_5,_4) # src/fusion/Model.mbi:2288:8-57
   _8 = numpy.int32(_8) # postprocess
   _11=(_9 * _8)
   if ((_3._key)==mosek.fusion.QConeKey.InQCone): # src/fusion/Model.mbi:2294:16-43
    if (_7 < 2): # src/fusion/Model.mbi:2295:14-26
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for quadratic cone")._toString_())
    _12 = self._task_1append_1domain_1quad_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.InRotatedQCone): # src/fusion/Model.mbi:2298:16-50
    if (_7 < 3): # src/fusion/Model.mbi:2299:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for rotated quadratic cone")._toString_())
    _12 = self._task_1append_1domain_1rquad_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.InPExpCone): # src/fusion/Model.mbi:2302:16-46
    if (_7!=3): # src/fusion/Model.mbi:2303:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for exponential cone")._toString_())
    _12 = self._task_1append_1domain_1pexp_()
   elif ((_3._key)==mosek.fusion.QConeKey.InPPowCone): # src/fusion/Model.mbi:2306:16-46
    if (_7 < 2): # src/fusion/Model.mbi:2307:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for power cone")._toString_())
    _12 = self._task_1append_1domain_1ppow_I_3D(_7,(_3._alpha))
   elif ((_3._key)==mosek.fusion.QConeKey.InDExpCone): # src/fusion/Model.mbi:2310:16-46
    if (_7!=3): # src/fusion/Model.mbi:2311:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for dual exponential cone")._toString_())
    _12 = self._task_1append_1domain_1dexp_()
   elif ((_3._key)==mosek.fusion.QConeKey.InDPowCone): # src/fusion/Model.mbi:2314:16-46
    if (_7 < 2): # src/fusion/Model.mbi:2315:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for dual power cone")._toString_())
    _12 = self._task_1append_1domain_1dpow_I_3D(_7,(_3._alpha))
   elif ((_3._key)==mosek.fusion.QConeKey.InPGeoMeanCone): # src/fusion/Model.mbi:2326:16-50
    if (_7 < 2): # src/fusion/Model.mbi:2327:14-26
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for primal geometric mean cone")._toString_())
    _12 = self._task_1append_1domain_1pgeomean_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.InDGeoMeanCone): # src/fusion/Model.mbi:2330:16-50
    if (_7 < 2): # src/fusion/Model.mbi:2331:14-26
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for dual geometric mean cone")._toString_())
    _12 = self._task_1append_1domain_1dgeomean_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.Positive): # src/fusion/Model.mbi:2334:16-44
    _12 = self._task_1append_1domain_1rpos_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.InSVecPSDCone): # src/fusion/Model.mbi:2337:16-49
    _13=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _7))) - 1) / 2))
    if (((_13 * (_13 + 1)) // 2)!=_7): # src/fusion/Model.mbi:2339:14-37
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for vector positive semidefinite cone")._toString_())
    _12 = self._task_1append_1domain_1svec_1psd_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.Negative): # src/fusion/Model.mbi:2343:16-44
    _12 = self._task_1append_1domain_1rneg_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.Unbounded): # src/fusion/Model.mbi:2345:16-45
    _12 = self._task_1append_1domain_1r_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.Zero): # src/fusion/Model.mbi:2347:16-40
    _12 = self._task_1append_1domain_1rzero_I(_7)
   elif ((_3._key)==mosek.fusion.QConeKey.InPSDCone): # src/fusion/Model.mbi:2349:16-45
    if (_7 < 2): # src/fusion/Model.mbi:2350:14-26
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for positive semidefinite cone")._toString_())
    else:
     _14=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _7))) - 1) / 2))
     if (((_14 * (_14 + 1)) // 2)!=_7): # src/fusion/Model.mbi:2354:16-39
      raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_7)._a_S(") for positive semidefinite cone")._toString_())
    _12 = self._task_1append_1domain_1svec_1psd_I(_7)
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid cone type")
   _15=numpy.zeros(((_11 * _7),), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _17=self.__conicvar_1alloc_JII_3I_3I(_12,_7,_11,_16,_15)
   self._task_1var_1putboundlist_1fr__3I(_15)
   if (_3._int_flag): # src/fusion/Model.mbi:2367:12-24
    self._task_1var_1putintlist__3I(_15)
   _18=_15
   if (_6 < (int((_4).shape[0]) - 1)): # src/fusion/Model.mbi:2371:12-35
    _18 = numpy.zeros((int((_15).shape[0]),), dtype=numpy.dtype(numpy.int32))
    _19=0
    _19 = fragments._c_closure_53(_7,_9,_8,_15,_19,_18) # src/fusion/Model.mbi:2374:10-2380:13
    _19 = numpy.int32(_19) # postprocess
   _20=mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4Model_2SI_3I_3I(self,_0,_17,_4,_15)
   self.__vars[_17] = _20
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2388:12-25
    _21=mosek.fusion.Utils.StringBuffer()
    _21._a_S(_0)._a_S("[")
    if (_5 > 0): # src/fusion/Model.mbi:2392:16-22
     _21._a_S("%0")
     for _22 in range(1,_5):
      _21._a_S(",%")._a_I(_22)
    _21._a_S("]")
    if ((_3._indexnames) is not None): # src/fusion/Model.mbi:2398:16-38
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_18,_21._toString_(),_4,None,(_3._indexnames))
    else:
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_18,_21._toString_(),_4,None,None)
    _23=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    self.__acc_block_map._get_I_3II(self.__var_block_acc_id[_17],_23,0)
    _24=numpy.zeros(((int((_4).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_54(_24,_6,_4) # src/fusion/Model.mbi:2410:12-61
    fragments._c_closure_55(_24,_6,_5,_4) # src/fusion/Model.mbi:2410:62-116
    _25=mosek.fusion.Utils.StringBuffer()
    _25._a_S(_0)._a_S("[")
    if ((_5 - 1) > 0): # src/fusion/Model.mbi:2414:16-24
     _25._a_S("%0")
     for _26 in range(1,_5):
      _25._a_S(",%")._a_I(_26)
    _25._a_S("]")
    if ((_3._indexnames) is not None): # src/fusion/Model.mbi:2421:16-38
     _27=numpy.ndarray(((_5 - 1),), dtype=numpy.dtype(object))
     for _28 in range(0,_6):
      _27[_28] = (_3._indexnames)[_28]
     for _29 in range((_6 + 1),_5):
      _27[(_29 - 1)] = (_3._indexnames)[_29]
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([numpy.int64(_23[_30]) for _30 in range(0,_11)], dtype=numpy.dtype(numpy.int64)),_25._toString_(),_24,_27)
    else:
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([numpy.int64(_23[_31]) for _31 in range(0,_11)], dtype=numpy.dtype(numpy.int64)),_25._toString_(),_24,None)
    self.__var_map._setItem_SI(_0,_17)
   return (_20)
  def __variable_1_alt_S_3ILmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4LinearDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:1995:17-52
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=_2._finalize_1and_1validate__3I(_1)
   _4=(_3._shape)
   _5=int((_4).shape[0])
   _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_56(_5,_4,_6) # src/fusion/Model.mbi:2008:36-135
   _7=1
   _7 = fragments._c_closure_57(_7,_4) # src/fusion/Model.mbi:2009:25-73
   _7 = numpy.int32(_7) # postprocess
   _8=None
   _9=None
   _10=None
   _11=None
   _12=None
   _13=None
   if ((int(len(_0)) > 0) and ((_3._indexnames) is not None)): # src/fusion/Model.mbi:2019:12-52
    _14=mosek.fusion.Utils.StringBuffer()
    _15=mosek.fusion.Utils.StringBuffer()
    _16=0
    _17=0
    _18=0
    if (int(((_3._indexnames)).shape[0])!=_5): # src/fusion/Model.mbi:2025:14-39
     raise mosek_fusion_DomainError._ctor_S("Invalid index name definition")
    for _19 in range(0,int(((_3._indexnames)).shape[0])):
     if ((_3._indexnames)[_19] is not None): # src/fusion/Model.mbi:2028:16-41
      if (_4[_19]!=int(((_3._indexnames)[_19]).shape[0])): # src/fusion/Model.mbi:2029:18-52
       raise mosek_fusion_DomainError._ctor_S("Invalid index name definition")
      _18 += _4[_19]
    _9 = numpy.zeros(((_18 + 1),), dtype=numpy.dtype(numpy.int64))
    _8 = numpy.array([(- 1) for _20 in range(0,_5)], dtype=numpy.dtype(numpy.int32))
    for _21 in range(0,int(((_3._indexnames)).shape[0])):
     if ((_3._indexnames)[_21] is not None): # src/fusion/Model.mbi:2037:16-41
      _8[_21] = _16
      for _22 in range(0,_4[_21]):
       _14._a_S((_3._indexnames)[_21][_22])
       _16 += 1
       _17 += int(len((_3._indexnames)[_21][_22]))
       _9[_16] = _17
    _10 = _14
    _13 = _15
   _23=None
   _24=None
   if (_3._empty): # src/fusion/Model.mbi:2065:12-21
    _23 = numpy.zeros((0,), dtype=numpy.dtype(numpy.int64))
   elif ((_3._sparsity) is not None): # src/fusion/Model.mbi:2068:16-36
    if (int(((_3._sparsity)).shape[1])!=_5): # src/fusion/Model.mbi:2069:14-39
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is not correct")
    _25=int(((_3._sparsity)).shape[0])
    _23 = numpy.zeros((_25,), dtype=numpy.dtype(numpy.int64))
    _26=False
    _27=(_3._sparsity)
    _26 = fragments._c_closure_58(_26,_25,_4,_27,_23,_6) # src/fusion/Model.mbi:2078:12-2086:13
    if _26: # src/fusion/Model.mbi:2087:16-19
     raise mosek_fusion_SparseFormatError._ctor_S("Sparsity pattern is out of bounds")
    _28=(_3._sparsity)
    _29=0
    _29 = fragments._c_closure_59(_29,_5,_4) # src/fusion/Model.mbi:2093:26-87
    _29 = numpy.int32(_29) # postprocess
    _30=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_60(_30,_25) # src/fusion/Model.mbi:2094:37-71
    _31=numpy.zeros((_25,), dtype=numpy.dtype(numpy.int32))
    _32=numpy.zeros(((_29 + 1),), dtype=numpy.dtype(numpy.int32))
    for _33 in range(0,_5):
     fragments._c_closure_61(_30,_33,_28,_25,_5,_32,_4,_31) # src/fusion/Model.mbi:2099:12-2109:13
     _34=_30
     _30 = _31
     _31 = _34
    fragments._c_closure_62(_30,_28,_25,_5,_23,_6) # src/fusion/Model.mbi:2113:10-2118:11
   _35=(int((_23).shape[0]) if ((_23 is not None) ) else _7)
   _36=numpy.zeros((_35,), dtype=numpy.dtype(numpy.float64))
   if ((_3._bnd) is not None): # src/fusion/Model.mbi:2124:12-27
    if (int(((_3._bnd)).shape[0])==1): # src/fusion/Model.mbi:2125:14-31
     for _37 in range(0,_35):
      _36[_37] = (_3._bnd)[0]
    elif (int(((_3._bnd)).shape[0])==_35): # src/fusion/Model.mbi:2127:18-43
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_3._bnd),0,_36,0,_35)
    else:
     raise mosek_fusion_DimensionError._ctor_S("Invalid right hand side shape in domain")
   _38=numpy.zeros((_35,), dtype=numpy.dtype(numpy.int32))
   _39=self.__linearvar_1alloc_I_3I(_35,_38)
   if ((_3._key)==mosek.fusion.RelationKey.IsFree): # src/fusion/Model.mbi:2137:17-46
    self._task_1var_1putboundlist_1fr__3I(_38)
   if ((_3._key)==mosek.fusion.RelationKey.LessThan): # src/fusion/Model.mbi:2141:17-48
    self._task_1var_1putboundlist_1up__3I_3D(_38,_36)
   elif ((_3._key)==mosek.fusion.RelationKey.GreaterThan): # src/fusion/Model.mbi:2145:17-51
    self._task_1var_1putboundlist_1lo__3I_3D(_38,_36)
   elif ((_3._key)==mosek.fusion.RelationKey.EqualsTo): # src/fusion/Model.mbi:2149:17-48
    self._task_1var_1putboundlist_1fx__3I_3D(_38,_36)
   _40=mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,_0,_39,_4,_23,_38)
   self.__vars[_39] = _40
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:2158:12-25
    _41=mosek.fusion.Utils.StringBuffer()
    _41._a_S(_0)._a_S("[")
    if (_5 > 0): # src/fusion/Model.mbi:2161:14-20
     _41._a_S("%0")
     for _42 in range(1,_5):
      _41._a_S(",%")._a_I(_42)
    _41._a_S("]")
    if ((_3._indexnames) is not None): # src/fusion/Model.mbi:2167:14-36
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_38,_41._toString_(),_4,_23,(_3._indexnames))
    else:
     self._task_1format_1var_1names__3IS_3I_3J_3_3S(_38,_41._toString_(),_4,_23,None)
    self.__var_map._setItem_SI(_0,_39)
   if (_3._cardinal_flag): # src/fusion/Model.mbi:2177:12-29
    self._task_1var_1putintlist__3I(_38)
   return (_40)
  def __variable_1_alt_S_3ILmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=_t__2
   _1 = self.__variable_1_S_3ILmosek_4fusion_4PSDDomain_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __variable_1_S_3ILmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasVariable_S(_0)): # src/fusion/Model.mbi:1811:13-48
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate variable name '")._a_S(_0)._a_S("'")._toString_())
   _3=_2._finalize_1and_1validate__3I(_1)
   _4=(_3._shape)
   _5=(_3._conedim1)
   _6=(_3._conedim2)
   _7=int((_4).shape[0])
   _8=_4[_5]
   if (_5 > _6): # src/fusion/Model.mbi:1876:12-31
    _9=_5
    _5 = _6
    _6 = _9
   if ((_5==_6) or ((_5 < 0) or (_6 >= _7))): # src/fusion/Model.mbi:1877:12-66
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone order dimensions for semidefinite variables")
   if (_4[_5]!=_4[_6]): # src/fusion/Model.mbi:1879:12-46
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape in cone order dimensions")
   _10=1
   _10 = fragments._c_closure_63(_5,_10,_4) # src/fusion/Model.mbi:1883:8-63
   _10 = numpy.int32(_10) # postprocess
   _10 = fragments._c_closure_64(_5,_6,_10,_4) # src/fusion/Model.mbi:1884:8-63
   _10 = numpy.int32(_10) # postprocess
   _10 = fragments._c_closure_65(_6,_7,_10,_4) # src/fusion/Model.mbi:1885:8-63
   _10 = numpy.int32(_10) # postprocess
   _11=(((_10 * _8) * (_8 + 1)) // 2)
   _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
   _13=numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
   _14=self.__barvar_1alloc_II_3I_3J(_8,_10,_13,_12)
   _15=mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4Model_2SI_3III_3I_3J(self,_0,_14,_4,(_3._conedim1),(_3._conedim2),_13,_12)
   if ((_0!="") or True): # src/fusion/Model.mbi:1894:12-30
    _16=numpy.zeros(((_7 - 2),), dtype=numpy.dtype(numpy.int32))
    _17=(_5 if ((_5 < _6) ) else _6)
    _18=(_6 if ((_5 < _6) ) else _5)
    fragments._c_closure_66(_17,_16,_4) # src/fusion/Model.mbi:1898:10-65
    fragments._c_closure_67(_17,_18,_16,_4) # src/fusion/Model.mbi:1899:10-65
    fragments._c_closure_68(_18,_16,_7,_4) # src/fusion/Model.mbi:1900:10-65
    _19=mosek.fusion.Utils.StringBuffer()
    _19._a_S(_0)._a_S("[")
    if ((_7 - 2) > 0): # src/fusion/Model.mbi:1904:14-22
     _19._a_S("%0")
     for _20 in range(1,(_7 - 2)):
      _19._a_S(",%")._a_I(_20)
    _19._a_S("]")
    if ((_3._indexnames) is not None): # src/fusion/Model.mbi:1911:14-36
     _21=numpy.ndarray(((_7 - 2),), dtype=numpy.dtype(object))
     for _22 in range(0,_17):
      _21[_22] = (_3._indexnames)[_22]
     for _23 in range((_17 + 1),_18):
      _21[(_23 - 1)] = (_3._indexnames)[_23]
     for _24 in range((_18 + 1),_7):
      _21[(_24 - 2)] = (_3._indexnames)[_24]
     self._task_1format_1barvar_1names__3IS_3I_3_3S(_13,_19._toString_(),_16,_21)
    else:
     self._task_1format_1barvar_1names__3IS_3I_3_3S(_13,_19._toString_(),_16,None)
   self.__barvars[_14] = _15
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1924:12-25
    self.__var_map._setItem_SI(_0,(- (_14 + 1)))
   return (_15)
  def __putfrows_alt__3IILmosek_4fusion_4WorkStack_2IIIII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=_t__2
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.int32(_t__6)
   _7=numpy.int32(_t__7)
   _1 = self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(self,_0,_1,_2,_3,_4,_5,_6,_7):
   _8=(_2.i32)
   _9=(_2.i64)
   _10=(_2.f64)
   _11=0
   _12=0
   _13=0
   _12,_11,_13 = fragments._c_closure_69(_12,self.__barvar_block_elm_barj,_11,_3,_6,_5,_8,_9,_13) # src/fusion/Model.mbi:1692:8-1708:9
   _12 = numpy.int32(_12) # postprocess
   _11 = numpy.int32(_11) # postprocess
   _13 = numpy.int32(_13) # postprocess
   if (_3 > (int((_0).shape[0]) - _1)): # src/fusion/Model.mbi:1710:12-49
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Mismatching sizes")
   _14=_3
   _15=numpy.zeros(((_14 + 1),), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
   _17=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
   _18=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_70(_18,_17,_7,_3,_6,_5,_15,_10,_8,_9,_16) # src/fusion/Model.mbi:1723:8-1742:9
   self._task_1putafeflist__3J_3I_3I_3D_3D(numpy.array([_0[(_19 + _1)] for _19 in range(0,_3)], dtype=numpy.dtype(numpy.int64)),_15,_16,_17,_18)
   if (_12 > 0): # src/fusion/Model.mbi:1754:12-22
    _20=_0
    _21=numpy.zeros(((_14 + 1),), dtype=numpy.dtype(numpy.int32))
    _22=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    _23=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    _24=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
    _25=numpy.array([(- 1) for _26 in range(0,_13)], dtype=numpy.dtype(numpy.int32))
    _27=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _28=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _29=0
    _30=0
    _30,_29 = fragments._c_closure_71(_30,_29,_22,self.__barvar_block_elm_barj,self.__barvar_block_elm_i,self.__barvar_block_elm_j,self.__barvar_dim,_7,_28,_23,_24,_25,_27,_6,_14,_21,_5,_10,_8,_9) # src/fusion/Model.mbi:1769:10-1794:11
    _30 = numpy.int32(_30) # postprocess
    _29 = numpy.int32(_29) # postprocess
    _31=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_23,_24,_25,_27,_28)
    self._task_1putafebarfrowlist__3I_3I_3I_3J(_20,_21,_22,_31)
  def __putarows_alt__3ILmosek_4fusion_4WorkStack_2IIIII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=_t__1
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.int32(_t__6)
   _1 = self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __putarows__3ILmosek_4fusion_4WorkStack_2IIIII(self,_0,_1,_2,_3,_4,_5,_6):
   _7=(_1.i32)
   _8=(_1.i64)
   _9=(_1.f64)
   _10=0
   _11=0
   _12=0
   _11,_10,_12 = fragments._c_closure_72(_11,self.__barvar_block_elm_barj,_10,_2,_5,_4,_7,_8,_12) # src/fusion/Model.mbi:1588:8-1601:9
   _11 = numpy.int32(_11) # postprocess
   _10 = numpy.int32(_10) # postprocess
   _12 = numpy.int32(_12) # postprocess
   _10 += _2
   _13=int((_0).shape[0])
   _14=numpy.zeros(((_13 + 1),), dtype=numpy.dtype(numpy.int64))
   _15=numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_10,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_73(_16,_6,_2,_5,_4,_14,_9,_7,_8,_15) # src/fusion/Model.mbi:1608:8-1624:9
   self._task_1putarowlist__3I_3J_3I_3D(_0,_14,_15,_16)
   if (_11 > 0): # src/fusion/Model.mbi:1630:12-22
    _17=_0
    _18=numpy.zeros(((_13 + 1),), dtype=numpy.dtype(numpy.int64))
    _19=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    _20=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    _21=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
    _22=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    _23=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int32))
    _24=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
    _25=0
    _26=0
    _26,_25 = fragments._c_closure_74(_26,_25,_19,self.__barvar_block_elm_barj,self.__barvar_block_elm_i,self.__barvar_block_elm_j,self.__barvar_dim,_6,_24,_20,_21,_22,_23,_5,_13,_18,_4,_9,_7,_8) # src/fusion/Model.mbi:1644:10-1667:11
    _26 = numpy.int32(_26) # postprocess
    _25 = numpy.int32(_25) # postprocess
    _27=self._task_1appendsymmatlist__3I_3J_3I_3I_3D(_20,_21,_22,_23,_24)
    self._task_1putbararowlist__3I_3J_3I_3J(_17,_18,_19,_27)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4RangeDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:1449:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._cardinal_flag): # src/fusion/Model.mbi:1452:12-30
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))
   _3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.shape_base)
   _9=(self.__rs.nelem)
   _10=(self.__rs.nnz)
   _11=(self.__rs.ncodeatom)
   _12=(self.__rs.hassp)
   _13=(self.__rs.ptr_base)
   _14=(self.__rs.nidxs_base)
   _15=(self.__rs.cof_base)
   _16=(self.__rs.codeptr_base)
   _17=(self.__rs.code_base)
   _18=(self.__rs.cconst_base)
   _19=numpy.array([_4[(_8 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   _21=_2._finalize_1and_1validate__3I(_19)
   if ((_21._shape) is not None): # src/fusion/Model.mbi:1481:13-30
    if (int(((_21._shape)).shape[0])!=_7): # src/fusion/Model.mbi:1482:14-34
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
    else:
     for _22 in range(0,_7):
      if ((_21._shape)[_22]!=_4[(_8 + _22)]): # src/fusion/Model.mbi:1486:18-52
       raise mosek_fusion_DimensionError._ctor_S("Mismatching expression and domain")
   _23=1
   _23 = fragments._c_closure_75(_7,_23,_4,_8) # src/fusion/Model.mbi:1489:24-73
   _23 = numpy.int32(_23) # postprocess
   _24=numpy.zeros((_23,), dtype=numpy.dtype(numpy.int32))
   _25=self.__con_1allocate__3I(_24)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(_24,self.__rs,_9,_10,_13,_14,_15)
   self.__xs._clear_()
   _26=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
   _27=numpy.zeros((_23,), dtype=numpy.dtype(numpy.float64))
   _28=(_21._lb)
   _29=(_21._ub)
   _30=(_21._empty)
   _31=(_21._scalable)
   _32=(_21._sparsity)
   fragments._c_closure_76(_26,_27,_30,_28,_31,_32,_29,_7,_23,_4,_8) # src/fusion/Model.mbi:1506:8-1530:9
   self._task_1con_1putboundlist_1ra__3I_3D_3D(_24,_26,_27)
   if (_11 > 0): # src/fusion/Model.mbi:1534:12-25
    self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_24,_13,_14,_16,_17,_18)
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1537:12-25
    _33=mosek.fusion.Utils.StringBuffer()
    _33._a_S(_0)._a_S("[")
    if (int((_19).shape[0]) > 0): # src/fusion/Model.mbi:1540:14-28
     _33._a_S("%0")
    for _34 in range(1,int((_19).shape[0])):
     _33._a_S(",%")._a_I(_34)
    _33._a_S("]")
    if ((_21._indexnames) is not None): # src/fusion/Model.mbi:1544:14-36
     self._task_1format_1con_1names__3IS_3I_3J_3_3S(_24,_33._toString_(),_19,None,(_21._indexnames))
    else:
     self._task_1format_1con_1names__3IS_3I_3J_3_3S(_24,_33._toString_(),_19,None,None)
   _35=mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4Model_2S_3I_3II(self,_0,numpy.array([_4[(_8 + _36)] for _36 in range(0,_7)], dtype=numpy.dtype(numpy.int32)),_24,_25)
   self.__cons[_25] = _35
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1552:12-25
    self.__con_map._setItem_SI(_0,_25)
   return (_35)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4PSDDomain_2(self,_0,_1,_2):
   _3=_1._getShape_()
   _4=_2._finalize_1and_1validate__3I(_3)
   _5=((_4._conedim1) < (_4._conedim2))
   _6=((_4._conedim2) if (((_4._conedim1) < (_4._conedim2)) ) else (_4._conedim1))
   _7=((_4._conedim1) if (((_4._conedim1) < (_4._conedim2)) ) else (_4._conedim2))
   _8=mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprScaleVecPSD._ctor_IILmosek_4fusion_4BaseExpression_2(_7,_6,mosek_fusion_ExprDenseTril._ctor_IILmosek_4fusion_4Expression_2(_7,_6,(mosek_fusion_ExprSymmetrize._ctor_IILmosek_4fusion_4Expression_2(_7,_6,_1) if (((_4._key)==mosek.fusion.PSDKey.IsSymPSD) ) else _1)))))
   _8._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   _9=(self.__rs.i32)
   _10=(self.__rs.i64)
   _11=(self.__rs.f64)
   _12=(self.__rs.nd)
   _13=(self.__rs.nelem)
   _14=(self.__rs.nnz)
   _15=(self.__rs.hassp)
   _16=(self.__rs.ncodeatom)
   _17=(self.__rs.shape_base)
   _18=(self.__rs.ptr_base)
   _19=(self.__rs.nidxs_base)
   _20=(self.__rs.sp_base)
   _21=(self.__rs.cof_base)
   _22=(self.__rs.codeptr_base)
   _23=(self.__rs.code_base)
   _24=(self.__rs.cconst_base)
   _25=_3[_6]
   _26=((_25 * (_25 + 1)) // 2)
   _27=1
   _27 = fragments._c_closure_77(_7,_6,_12,_27,_3) # src/fusion/Model.mbi:1291:8-1293:32
   _27 = numpy.int32(_27) # postprocess
   _28=self._task_1append_1domain_1svec_1psd_I(_26)
   _29=(_26 * _27)
   _30=numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
   _31=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
   _32=numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
   _33=numpy.zeros((_29,), dtype=numpy.dtype(numpy.float64))
   _34=self.__acon_1allocate_JII_3D_3I_3I(_28,_26,_27,_33,_30,_31)
   _35=numpy.zeros((_29,), dtype=numpy.dtype(numpy.int32))
   self.__acon_block_map._get_I_3II(_34,_35,0)
   _36=1
   _37=_3[_6]
   _38=1
   _39=_3[_7]
   _40=1
   _40 = fragments._c_closure_78(_7,_40,_3) # src/fusion/Model.mbi:1312:8-58
   _40 = numpy.int64(_40) # postprocess
   _38 = fragments._c_closure_79(_7,_6,_38,_3) # src/fusion/Model.mbi:1313:8-58
   _38 = numpy.int64(_38) # postprocess
   _36 = fragments._c_closure_80(_6,_36,_12,_3) # src/fusion/Model.mbi:1314:8-58
   _36 = numpy.int64(_36) # postprocess
   _41=0
   _42=(1.0 / mosek.fusion.Utils.Tools._sqrt_D(2))
   _41 = fragments._c_closure_81(self.__acon_elm_scale,_35,_40,_39,_38,_37,_36,_41,_42) # src/fusion/Model.mbi:1320:10-1330:13
   _41 = numpy.int32(_41) # postprocess
   _43=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _44=0
   _44 = fragments._c_closure_82(_30,_43,_26,_40,_39,_38,_37,_36,_44,_5) # src/fusion/Model.mbi:1337:10-1358:21
   _44 = numpy.int32(_44) # postprocess
   self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_43,0,self.__rs,_13,_14,_18,_19,_21)
   if (_16 > 0): # src/fusion/Model.mbi:1360:14-27
    self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_43,_18,_19,_22,_23,_24)
   _45=numpy.zeros((((_27 * _39) * _39),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_83(_30,_26,_40,_39,_38,_37,_36,_45,_5) # src/fusion/Model.mbi:1366:8-1390:9
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1393:12-25
    _46=numpy.zeros(((int((_3).shape[0]) - 2),), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_84(_7,_46,_3) # src/fusion/Model.mbi:1395:10-60
    fragments._c_closure_85(_7,_6,_46,_3) # src/fusion/Model.mbi:1396:10-71
    fragments._c_closure_86(_6,_46,_12,_3) # src/fusion/Model.mbi:1397:10-65
    _47=mosek.fusion.Utils.StringBuffer()
    _47._a_S(_0)._a_S("[")
    if (_12 > 2): # src/fusion/Model.mbi:1401:14-20
     _47._a_S("%0")
     for _48 in range(1,(_12 - 2)):
      _47._a_S(",%")._a_I(_48)
    _47._a_S("]")
    if ((_4._indexnames) is not None): # src/fusion/Model.mbi:1406:14-36
     _49=(_4._indexnames)
     _50=numpy.ndarray(((_12 - 2),), dtype=numpy.dtype(object))
     for _51 in range(0,_7):
      _50[_51] = _49[_51]
     for _52 in range((_7 + 1),_6):
      _50[(_52 - 1)] = _49[_52]
     for _53 in range((_6 + 1),_12):
      _50[(_53 - 2)] = _49[_53]
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([_31[_54] for _54 in range(0,int((_31).shape[0]))], dtype=numpy.dtype(numpy.int64)),_47._toString_(),_46,_50)
    else:
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([_31[_55] for _55 in range(0,int((_31).shape[0]))], dtype=numpy.dtype(numpy.int64)),_47._toString_(),_46,None)
   _56=mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(self,_0,None,_3,_34,_45,None)
   self.__acons[_34] = _56
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1420:12-25
    self.__con_map._setItem_SI(_0,(- (1 + _34)))
   return (_56)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4ConeDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:828:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:831:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._int_flag): # src/fusion/Model.mbi:834:12-25
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))
   _3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.shape_base)
   _9=(self.__rs.nelem)
   _10=(self.__rs.nnz)
   _11=(self.__rs.ncodeatom)
   _12=(self.__rs.hassp)
   _13=(self.__rs.ptr_base)
   _14=(self.__rs.nidxs_base)
   _15=(self.__rs.cof_base)
   _16=(self.__rs.code_base)
   _17=(self.__rs.codeptr_base)
   _18=(self.__rs.cconst_base)
   _19=numpy.array([_4[(_8 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   _21=_2._finalize_1and_1validate__3I(_19)
   _22=(_21._getAxis_() if (_21._axisIsSet_() ) else (_7 - 1))
   _23=_19[_22]
   _24=1
   _25=1
   _26=1
   _26 = fragments._c_closure_87(_26,_7,_19) # src/fusion/Model.mbi:884:8-57
   _26 = numpy.int32(_26) # postprocess
   _25 = fragments._c_closure_88(_22,_25,_19) # src/fusion/Model.mbi:885:8-57
   _25 = numpy.int32(_25) # postprocess
   _24 = fragments._c_closure_89(_22,_24,_7,_19) # src/fusion/Model.mbi:886:8-57
   _24 = numpy.int32(_24) # postprocess
   _27=(_25 * _24)
   if ((_21._key)==mosek.fusion.QConeKey.InQCone): # src/fusion/Model.mbi:891:16-43
    if (_23 < 2): # src/fusion/Model.mbi:892:14-26
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for quadratic cone")._toString_())
    _28 = self._task_1append_1domain_1quad_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.InRotatedQCone): # src/fusion/Model.mbi:895:16-50
    if (_23 < 3): # src/fusion/Model.mbi:896:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for rotated quadratic cone")._toString_())
    _28 = self._task_1append_1domain_1rquad_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.InPExpCone): # src/fusion/Model.mbi:899:16-46
    if (_23!=3): # src/fusion/Model.mbi:900:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for exponential cone")._toString_())
    _28 = self._task_1append_1domain_1pexp_()
   elif ((_21._key)==mosek.fusion.QConeKey.InPPowCone): # src/fusion/Model.mbi:903:16-46
    if (_23 < 2): # src/fusion/Model.mbi:904:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for power cone")._toString_())
    if (int(((_21._alpha)).shape[0]) < 2): # src/fusion/Model.mbi:905:14-33
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Power cone requires at least two parameters")._toString_())
    _28 = self._task_1append_1domain_1ppow_I_3D(_23,(_21._alpha))
   elif ((_21._key)==mosek.fusion.QConeKey.InDExpCone): # src/fusion/Model.mbi:908:16-46
    if (_23!=3): # src/fusion/Model.mbi:909:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for dual exponential cone")._toString_())
    _28 = self._task_1append_1domain_1dexp_()
   elif ((_21._key)==mosek.fusion.QConeKey.InDPowCone): # src/fusion/Model.mbi:912:16-46
    if (_23 < 2): # src/fusion/Model.mbi:913:14-27
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for dual power cone")._toString_())
    if (int(((_21._alpha)).shape[0]) < 2): # src/fusion/Model.mbi:914:14-33
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Power cone requires at least two parameters")._toString_())
    _28 = self._task_1append_1domain_1dpow_I_3D(_23,(_21._alpha))
   elif ((_21._key)==mosek.fusion.QConeKey.InPGeoMeanCone): # src/fusion/Model.mbi:925:16-50
    if (_23 < 2): # src/fusion/Model.mbi:926:14-26
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for primal geometric mean cone")._toString_())
    _28 = self._task_1append_1domain_1pgeomean_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.InDGeoMeanCone): # src/fusion/Model.mbi:929:16-50
    if (_23 < 2): # src/fusion/Model.mbi:930:14-26
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for dual geometric mean cone")._toString_())
    _28 = self._task_1append_1domain_1dgeomean_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.InSVecPSDCone): # src/fusion/Model.mbi:933:16-49
    _29=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _23))) - 1) / 2))
    if (((_29 * (_29 + 1)) // 2)!=_23): # src/fusion/Model.mbi:935:14-37
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for vector positive semidefinite cone")._toString_())
    _28 = self._task_1append_1domain_1svec_1psd_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.Positive): # src/fusion/Model.mbi:939:16-44
    _28 = self._task_1append_1domain_1rpos_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.Negative): # src/fusion/Model.mbi:942:16-44
    _28 = self._task_1append_1domain_1rneg_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.Unbounded): # src/fusion/Model.mbi:944:16-45
    _28 = self._task_1append_1domain_1r_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.Zero): # src/fusion/Model.mbi:946:16-40
    _28 = self._task_1append_1domain_1rzero_I(_23)
   elif ((_21._key)==mosek.fusion.QConeKey.InPSDCone): # src/fusion/Model.mbi:948:16-45
    if (_23 < 2): # src/fusion/Model.mbi:949:14-26
     raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for positive semidefinite cone")._toString_())
    else:
     _30=numpy.int32(((mosek.fusion.Utils.Tools._sqrt_D((1 + (8 * _23))) - 1) / 2))
     if (((_30 * (_30 + 1)) // 2)!=_23): # src/fusion/Model.mbi:953:16-39
      raise mosek_fusion_DimensionError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Invalid size (")._a_I(_23)._a_S(") for positive semidefinite cone")._toString_())
    _28 = self._task_1append_1domain_1svec_1psd_I(_23)
   else:
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid cone type")
   _31=numpy.zeros((_26,), dtype=numpy.dtype(numpy.float64))
   _32=numpy.zeros((_26,), dtype=numpy.dtype(numpy.int32))
   _33=numpy.zeros((_27,), dtype=numpy.dtype(numpy.int32))
   _34=self.__acon_1allocate_JII_3D_3I_3I(_28,_23,_27,_31,_32,_33)
   _35=numpy.zeros((_26,), dtype=numpy.dtype(numpy.int32))
   _36=0
   _37=(_21._domofs)
   _36 = fragments._c_closure_90(_23,_25,_24,_26,_31,_36,_37,_35) # src/fusion/Model.mbi:971:10-982:11
   _36 = numpy.int32(_36) # postprocess
   _38=numpy.array([_32[_35[_39]] for _39 in range(0,_26)], dtype=numpy.dtype(numpy.int32))
   self.__putfrows__3IILmosek_4fusion_4WorkStack_2IIIII(_38,0,self.__rs,_9,_10,_13,_14,_15)
   if (_11 > 0): # src/fusion/Model.mbi:990:12-25
    self.__afe_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_38,_13,_14,_17,_16,_18)
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:993:12-25
    _40=numpy.zeros(((int((_19).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_91(_40,_22,_19) # src/fusion/Model.mbi:995:10-59
    fragments._c_closure_92(_40,_22,_7,_19) # src/fusion/Model.mbi:996:10-64
    _41=mosek.fusion.Utils.StringBuffer()
    _41._a_S(_0)._a_S("[")
    if (_7 > 1): # src/fusion/Model.mbi:1000:14-20
     _41._a_S("%0")
     for _42 in range(1,(_7 - 1)):
      _41._a_S(",%")._a_I(_42)
    _41._a_S("]")
    if ((_21._indexnames) is not None): # src/fusion/Model.mbi:1005:14-36
     _43=(_21._indexnames)
     _44=numpy.ndarray(((_7 - 1),), dtype=numpy.dtype(object))
     for _45 in range(0,_22):
      _44[_45] = _43[_45]
     for _46 in range((_22 + 1),_7):
      _44[(_46 - 1)] = _43[_46]
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([_33[_47] for _47 in range(0,int((_33).shape[0]))], dtype=numpy.dtype(numpy.int64)),_41._toString_(),_40,_44)
    else:
     self._task_1format_1acc_1names__3JS_3I_3_3S(numpy.array([_33[_48] for _48 in range(0,int((_33).shape[0]))], dtype=numpy.dtype(numpy.int64)),_41._toString_(),_40,None)
   _49=mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(self,_0,_21,_19,_34,_32,(_21._indexnames))
   self.__acons[_34] = _49
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:1020:12-25
    self.__con_map._setItem_SI(_0,(- (_34 + 1)))
   return (_49)
  def __constraint_1_alt_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_t__0,_t__1,_t__2):
    return self.__constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(_0,_1,_2)
  def __constraint_1_SLmosek_4fusion_4Expression_2Lmosek_4fusion_4LinearDomain_2(self,_0,_1,_2):
   if ((int(len(_0)) > 0) and self._hasConstraint_S(_0)): # src/fusion/Model.mbi:701:12-49
    raise mosek_fusion_NameError._ctor_S(mosek.fusion.Utils.StringBuffer()._a_S("Duplicate constraint name '")._a_S(_0)._a_S("'")._toString_())
   if (_2._cardinal_flag): # src/fusion/Model.mbi:704:12-30
    raise mosek_fusion_DomainError._ctor_S("Integer domain not allowed in a constraint")
   _3=mosek_fusion_ExprDense._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprOptimizeCode._ctor_Lmosek_4fusion_4Expression_2(mosek_fusion_ExprCompress._ctor_Lmosek_4fusion_4Expression_2(_1)))
   _3._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self.__rs,self.__ws,self.__xs)
   self.__rs._pop_1expr_()
   _4=(self.__rs.i32)
   _5=(self.__rs.i64)
   _6=(self.__rs.f64)
   _7=(self.__rs.nd)
   _8=(self.__rs.nelem)
   _9=(self.__rs.nnz)
   _10=(self.__rs.hassp)
   _11=(self.__rs.ncodeatom)
   _12=(self.__rs.shape_base)
   _13=(self.__rs.ptr_base)
   _14=(self.__rs.nidxs_base)
   _15=(self.__rs.cof_base)
   _16=(self.__rs.codeptr_base)
   _17=(self.__rs.code_base)
   _18=(self.__rs.cconst_base)
   _19=numpy.array([_4[(_12 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
   _21=_2._finalize_1and_1validate__3I(_19)
   _22=(_21._domsize)
   _23=(_21._indexnames)
   _25=numpy.zeros((_22,), dtype=numpy.dtype(numpy.int32))
   _26=self.__con_1allocate__3I(_25)
   self.__putarows__3ILmosek_4fusion_4WorkStack_2IIIII(_25,self.__rs,_8,_9,_13,_14,_15)
   _27=(_21._sparsity)
   _28=(_21._empty)
   _29=(_21._bnd)
   _30=(_21._scalable)
   if (_29 is None): # src/fusion/Model.mbi:750:16-30
    _24 = numpy.zeros((int((_25).shape[0]),), dtype=numpy.dtype(numpy.float64))
   elif _30: # src/fusion/Model.mbi:752:20-31
    _24 = numpy.array([_29[0] for _31 in range(0,int((_25).shape[0]))], dtype=numpy.dtype(numpy.float64))
   elif (_27 is not None): # src/fusion/Model.mbi:754:20-33
    _32=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
    _32[(_7 - 1)] = 1
    fragments._c_closure_93(_7,_19,_32) # src/fusion/Model.mbi:755:59-121
    _24 = numpy.zeros((int((_25).shape[0]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_94(_24,_29,_27,_7,_32) # src/fusion/Model.mbi:758:14-761:15
   elif _28: # src/fusion/Model.mbi:763:20-28
    _24 = numpy.zeros((int((_25).shape[0]),), dtype=numpy.dtype(numpy.float64))
   else:
    _24 = numpy.array([_29[_33] for _33 in range(0,int((_25).shape[0]))], dtype=numpy.dtype(numpy.float64))
   if ((_21._key)==mosek.fusion.RelationKey.IsFree): # src/fusion/Model.mbi:778:17-46
    self._task_1con_1putboundlist_1fr__3I(_25)
   if ((_21._key)==mosek.fusion.RelationKey.LessThan): # src/fusion/Model.mbi:782:17-48
    self._task_1con_1putboundlist_1up__3I_3D(_25,_24)
   elif ((_21._key)==mosek.fusion.RelationKey.GreaterThan): # src/fusion/Model.mbi:786:17-51
    self._task_1con_1putboundlist_1lo__3I_3D(_25,_24)
   elif ((_21._key)==mosek.fusion.RelationKey.EqualsTo): # src/fusion/Model.mbi:790:17-48
    self._task_1con_1putboundlist_1fx__3I_3D(_25,_24)
   if (_11 > 0): # src/fusion/Model.mbi:796:12-25
    self.__con_blocks._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self.__rs,_25,_13,_14,_16,_17,_18)
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:800:12-25
    _34=mosek.fusion.Utils.StringBuffer()
    _34._a_S(_0)._a_S("[")
    if (int((_19).shape[0]) > 0): # src/fusion/Model.mbi:803:14-28
     _34._a_S("%0")
    for _35 in range(1,int((_19).shape[0])):
     _34._a_S(",%")._a_I(_35)
    _34._a_S("]")
    if ((_21._indexnames) is not None): # src/fusion/Model.mbi:807:14-36
     self._task_1format_1con_1names__3IS_3I_3J_3_3S(_25,_34._toString_(),_19,None,(_21._indexnames))
    else:
     self._task_1format_1con_1names__3IS_3I_3J_3_3S(_25,_34._toString_(),_19,None,None)
   _36=mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(self,_0,_26,_19,_25,_23)
   self.__cons[_26] = _36
   if (int(len(_0)) > 0): # src/fusion/Model.mbi:815:12-25
    self.__con_map._setItem_SI(_0,_26)
   return (_36)
  @staticmethod
  def _match_getVersion_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getVersion_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _getVersion_alt_():
    return mosek_fusion_Model._getVersion_()
  @staticmethod
  def _getVersion_():
   return (mosek.fusion.BaseModel._env_1getversion_())
  @staticmethod
  def _match_hasParameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasParameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasParameter_alt_S(self,_t__0):
    return self._hasParameter_S(_0)
  def _hasParameter_S(self,_0):
   return (self.__par_map._hasItem_S(_0))
  @staticmethod
  def _match_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasConstraint_alt_S(self,_t__0):
    return self._hasConstraint_S(_0)
  def _hasConstraint_S(self,_0):
   return (self.__con_map._hasItem_S(_0))
  @staticmethod
  def _match_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_hasVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _hasVariable_alt_S(self,_t__0):
    return self._hasVariable_S(_0)
  def _hasVariable_S(self,_0):
   return (self.__var_map._hasItem_S(_0))
  @staticmethod
  def _match_getParameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getParameter_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getParameter_alt_S(self,_t__0):
    return self._getParameter_S(_0)
  def _getParameter_S(self,_0):
   return ((self.__parameters[self.__par_map._getItem_S(_0)] if (self.__par_map._hasItem_S(_0) ) else None))
  @staticmethod
  def _match_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getConstraint_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getConstraint_alt_I(self,_t__0):
    return self._getConstraint_I(numpy.int32(__0))
  def _getConstraint_I(self,_0):
   if (_0 >= 0): # src/fusion/Model.mbi:680:92-102
    _1 = self.__cons[_0]
   else:
    _1 = self.__acons[(- (1 + _0))]
   return (_1)
  @staticmethod
  def _match_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getConstraint_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getConstraint_alt_S(self,_t__0):
    return self._getConstraint_S(_0)
  def _getConstraint_S(self,_0):
   _1=None
   if self.__con_map._hasItem_S(_0): # src/fusion/Model.mbi:672:12-33
    _2=self.__con_map._getItem_S(_0)
    if (_2 >= 0): # src/fusion/Model.mbi:675:14-22
     _1 = self.__cons[_2]
    else:
     _1 = self.__acons[(- (1 + _2))]
   return (_1)
  @staticmethod
  def _match_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getVariable_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getVariable_alt_I(self,_t__0):
    return self._getVariable_I(numpy.int32(__0))
  def _getVariable_I(self,_0):
   return (self.__vars[_0])
  @staticmethod
  def _match_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_S__(_0))
  @staticmethod
  def _match_alt_getVariable_S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_S__(_0))
  def _getVariable_alt_S(self,_t__0):
    return self._getVariable_S(_0)
  def _getVariable_S(self,_0):
   if self.__var_map._hasItem_S(_0): # src/fusion/Model.mbi:658:12-33
    _1=self.__var_map._getItem_S(_0)
    if (_1 < 0): # src/fusion/Model.mbi:660:14-23
     return (self.__barvars[(- (_1 + 1))])
    else:
     return (self.__vars[_1])
   else:
    return (None)
  @staticmethod
  def _match_getName_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getName_(*args):
    if len(args) != 0: return False
    return True
  def _getName_alt_(self,):
    return self._getName_()
  def _getName_(self,):
   return (self.__model_name)
  def _getParameterValue_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._getParameterValue__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getParameterValue__3I(self,_0):
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_95(_0,self.__param_value,_1) # src/fusion/Model.mbi:649:8-650:40
   return (_1)
  def _setParameterValue_alt__3I_3D(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._setParameterValue__3I_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setParameterValue__3I_3D(self,_0,_1):
   fragments._c_closure_96(_0,self.__param_value,_1) # src/fusion/Model.mbi:642:77-645:7
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_Model._ctor_Lmosek_4fusion_4Model_2(self))
 return Model
mosek_fusion_Model=__mk_mosek_fusion_Model()
del __mk_mosek_fusion_Model
def __mk_mosek_fusion_Debug():
  import sys
  class Debug:
    @staticmethod
    def _o_(): return Debug()
    def p(self,v):
      sys.stdout.write(str(v))
      return self
    _p_S = p
    _p_I = p
    _p_J = p
    _p_D = p
    _p_Z = p
  
    def p_array (self,v):
      if v is None:
          sys.stdout.write('None')
      else:
          sys.stdout.write('[ %s ]' % ','.join([str(i) for i in v]))
      return self
  
    _p__3I = p_array
    _p__3J = p_array
    _p__3D = p_array
  
    def _lf_(self):
      sys.stdout.write("\n")
      return self
  return Debug
mosek_fusion_Debug=__mk_mosek_fusion_Debug()
#BEFORE CLASS
def __mk_mosek_fusion_Sort():
 class Sort(object):
  @staticmethod
  def argTransposeSort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(*args)
    elif mosek_fusion_Sort._match_alt_argTransposeSort__3J_3JIII_3J(*args): # []int64,[]int64,int32,int32,int32,[]int64
      return mosek_fusion_Sort._argTransposeSort_alt__3J_3JIII_3J(*args)
    else:
      raise ValueError('Invalid argument list argTransposeSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argTransposeSort(array(int64,ndim=1),array(int64,ndim=1),int32,int32,int32,array(int64,ndim=1))')
  @staticmethod
  def argbucketsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3IJJII(*args): # []int64,[]int32,int64,int64,int32,int32
      return mosek_fusion_Sort._argbucketsort_alt__3J_3IJJII(*args)
    elif mosek_fusion_Sort._match_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(*args)
    elif mosek_fusion_Sort._match_alt_argbucketsort__3J_3JJJJJ(*args): # []int64,[]int64,int64,int64,int64,int64
      return mosek_fusion_Sort._argbucketsort_alt__3J_3JJJJJ(*args)
    else:
      raise ValueError('Invalid argument list argbucketsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,int32,int32)\n\tmosek.fusion.Sort.argbucketsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,int64,int64)')
  @staticmethod
  def getminmax(*args):
    if False: pass
    elif mosek_fusion_Sort._match_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3I_3IJJ_3I(*args): # []int64,[]int32,[]int32,int64,int64,[]int32
      return mosek_fusion_Sort._getminmax_alt__3J_3I_3IJJ_3I(*args)
    elif mosek_fusion_Sort._match_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(*args)
    elif mosek_fusion_Sort._match_alt_getminmax__3J_3J_3JJJ_3J(*args): # []int64,[]int64,[]int64,int64,int64,[]int64
      return mosek_fusion_Sort._getminmax_alt__3J_3J_3JJJ_3J(*args)
    else:
      raise ValueError('Invalid argument list getminmax('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,array(int32,ndim=1))\n\tmosek.fusion.Sort.getminmax(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,array(int64,ndim=1))')
  @staticmethod
  def argsort(*args):
    if False: pass
    elif mosek_fusion_Sort._match_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J(*args): # []int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort__3J_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I(*args): # []int64,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3I(*args): # []int64,[]int32,[]int32
      return mosek_fusion_Sort._argsort_alt__3J_3I_3I(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3J(*args): # []int64,[]int64,[]int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3J(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJ(*args): # []int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJ(*args): # []int64,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_argsort__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._argsort_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list argsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.argsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  @staticmethod
  def issorted(*args):
    if False: pass
    elif mosek_fusion_Sort._match_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3IJJZ(*args): # []int64,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3JJJZ(*args): # []int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3I_3IJJZ(*args): # []int64,[]int32,[]int32,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3I_3IJJZ(*args)
    elif mosek_fusion_Sort._match_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted__3J_3J_3JJJZ(*args)
    elif mosek_fusion_Sort._match_alt_issorted__3J_3J_3JJJZ(*args): # []int64,[]int64,[]int64,int64,int64,bool
      return mosek_fusion_Sort._issorted_alt__3J_3J_3JJJZ(*args)
    else:
      raise ValueError('Invalid argument list issorted('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64,bool)\n\tmosek.fusion.Sort.issorted(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64,bool)')
  def __repr__(self): return 'mosek.fusion.Sort'
  @staticmethod
  def _match_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_argTransposeSort__3J_3JIII_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _argTransposeSort_alt__3J_3JIII_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argTransposeSort__3J_3JIII_3J(_0,_1,_2,_3,_4,_5):
   fragments._c_closure_97(_2,_3,_4,_0,_1,_5) # src/fusion/Sort.mbi:250:6-261:7
  @staticmethod
  def _match_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1))
  @staticmethod
  def _argsort_alt__3J_3J(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J(_0,_1):
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argsort__3J_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argsort_alt__3J_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I(_0,_1):
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2))
  @staticmethod
  def _argsort_alt__3J_3J_3J(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._argsort__3J_3J_3J(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3J(_0,_1,_2):
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_argsort__3J_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _argsort_alt__3J_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._argsort__3J_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3I(_0,_1,_2):
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,0,int((_0).shape[0]),False)
  @staticmethod
  def _match_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3JJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3JJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3JJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJ(_0,_1,_2,_3):
   mosek.fusion.Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3))
  @staticmethod
  def _match_alt_argsort__3J_3IJJ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3))
  @staticmethod
  def _argsort_alt__3J_3IJJ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _1 = mosek_fusion_Sort._argsort__3J_3IJJ(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJ(_0,_1,_2,_3):
   mosek.fusion.Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,False)
  @staticmethod
  def _match_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   mosek.fusion.Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   mosek.fusion.Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,False)
  @staticmethod
  def _match_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3JJJZ(_0,_1,_2,_3,_4):
   if ((not _4) or ((_3 - _2) < 16)): # src/fusion/Sort.mbi:158:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)): # src/fusion/Sort.mbi:160:16-56
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))): # src/fusion/Sort.mbi:166:14-54
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_argsort__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _argsort_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._argsort__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3IJJZ(_0,_1,_2,_3,_4):
   if ((not _4) or ((_3 - _2) < 16)): # src/fusion/Sort.mbi:139:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
   elif (not mosek.fusion.Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)): # src/fusion/Sort.mbi:141:16-56
    _5=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _6=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,None,_2,_3,_5)
    if ((_5[1] - _5[0]) < (_6 * (_3 - _2))): # src/fusion/Sort.mbi:147:14-54
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_5[0],_5[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_2,_3)
  @staticmethod
  def _match_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   if ((not _5) or ((_4 - _3) < 16)): # src/fusion/Sort.mbi:118:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)): # src/fusion/Sort.mbi:120:16-62
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int64))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))): # src/fusion/Sort.mbi:126:14-127:54
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3JJJJJ(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_argsort__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _argsort_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argsort__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   if ((not _5) or ((_4 - _3) < 16)): # src/fusion/Sort.mbi:97:12-40
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   elif (not mosek.fusion.Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)): # src/fusion/Sort.mbi:99:16-62
    _6=numpy.zeros((4,), dtype=numpy.dtype(numpy.int32))
    _7=2
    mosek.fusion.Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_6)
    if (((_6[1] - _6[0]) < (_7 * (_4 - _3))) and ((_6[3] - _6[2]) < (_7 * (_4 - _3)))): # src/fusion/Sort.mbi:105:14-106:54
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_2,_3,_4,_6[2],_6[3])
     mosek.fusion.Sort._argbucketsort__3J_3IJJII(_0,_1,_3,_4,_6[0],_6[1])
    else:
     mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_J__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3JJJJJ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_J__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3JJJJJ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.int64(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3JJJJJ(_0,_1,_2,_3,_4,_5):
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3JJJ(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5))
  @staticmethod
  def _match_alt_argbucketsort__3J_3IJJII(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5))
  @staticmethod
  def _argbucketsort_alt__3J_3IJJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_Sort._argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argbucketsort__3J_3IJJII(_0,_1,_2,_3,_4,_5):
   mosek.fusion.Utils.Tools._bucketsort__3JJJ_3III(_0,_2,_3,_1,_4,_5)
  @staticmethod
  def _match_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3J__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3J_3JJJ_3J(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3J__(_5))
  @staticmethod
  def _getminmax_alt__3J_3J_3JJJ_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Sort._getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3J_3JJJ_3J(_0,_1,_2,_3,_4,_5):
   fragments._c_closure_98(_3,_0,_4,_5,_1,_2) # src/fusion/Sort.mbi:62:6-80:7
  @staticmethod
  def _match_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match__3I__(_5))
  @staticmethod
  def _match_alt_getminmax__3J_3I_3IJJ_3I(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match__3I__(_5))
  @staticmethod
  def _getminmax_alt__3J_3I_3IJJ_3I(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Sort._getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _getminmax__3J_3I_3IJJ_3I(_0,_1,_2,_3,_4,_5):
   fragments._c_closure_99(_3,_0,_4,_5,_1,_2) # src/fusion/Sort.mbi:41:6-59:7
  @staticmethod
  def _match_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3JJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3JJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3JJJZ(_0,_1,_2,_3,_4):
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]): # src/fusion/Sort.mbi:35:14-45
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match_J__(_2) and __arg_match_J__(_3) and __arg_match_Z__(_4))
  @staticmethod
  def _match_alt_issorted__3J_3IJJZ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_Z__(_4))
  @staticmethod
  def _issorted_alt__3J_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int64(_t__2)
   _3=numpy.int64(_t__3)
   _4=_t__4
   _1 = mosek_fusion_Sort._issorted__3J_3IJJZ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3IJJZ(_0,_1,_2,_3,_4):
   for _5 in range(_2,(_3 - 1)):
    if (_1[_0[_5]] > _1[_0[(_5 + 1)]]): # src/fusion/Sort.mbi:27:14-45
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3J_3JJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3J_3JJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3J_3JJJZ(_0,_1,_2,_3,_4,_5):
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[(_6 + 1)]]==_1[_0[_6]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))): # src/fusion/Sort.mbi:19:14-119
     return (False)
   return (True)
  @staticmethod
  def _match_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4) and __arg_match_Z__(_5))
  @staticmethod
  def _match_alt_issorted__3J_3I_3IJJZ(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4) and __arg_alt_match_Z__(_5))
  @staticmethod
  def _issorted_alt__3J_3I_3IJJZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Sort._issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _issorted__3J_3I_3IJJZ(_0,_1,_2,_3,_4,_5):
   for _6 in range(_3,(_4 - 1)):
    if ((_1[_0[_6]] > _1[_0[(_6 + 1)]]) or ((_1[_0[_6]]==_1[_0[(_6 + 1)]]) and (_2[_0[_6]] > _2[_0[(_6 + 1)]]))): # src/fusion/Sort.mbi:11:14-119
     return (False)
   return (True)
 return Sort
mosek_fusion_Sort=__mk_mosek_fusion_Sort()
del __mk_mosek_fusion_Sort
#BEFORE CLASS
def __mk_mosek_fusion_IndexCounter():
 class IndexCounter(object):
  __slots__ = ['_IndexCounter__start','_IndexCounter__dims','_IndexCounter__strides','_IndexCounter__st','_IndexCounter__ii','_IndexCounter__n']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args): # []int32
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):# []int32
      self._ctor_alt_init__3I(*args)
    elif self.__match_ctor_J_3I_3I(*args): # int64,[]int32,[]int32
      self._ctor_init_J_3I_3I(*args)
    elif self.__match_alt_ctor_J_3I_3I(*args):# int64,[]int32,[]int32
      self._ctor_alt_init_J_3I_3I(*args)
    elif self.__match_ctor_J_3I_3J(*args): # int64,[]int32,[]int64
      self._ctor_init_J_3I_3J(*args)
    elif self.__match_alt_ctor_J_3I_3J(*args):# int64,[]int32,[]int64
      self._ctor_alt_init_J_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.IndexCounter.ctor(array(int32,ndim=1))\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.IndexCounter.ctor(int64,array(int32,ndim=1),array(int64,ndim=1))')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_get_(*args): # 
      return self._get_(*args)
    elif mosek_fusion_IndexCounter._match_alt_get_(*args): # 
      return self._get_alt_(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.get()')
  def reset(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_reset_(*args): # 
      return self._reset_(*args)
    elif mosek_fusion_IndexCounter._match_alt_reset_(*args): # 
      return self._reset_alt_(*args)
    else:
      raise ValueError('Invalid argument list reset('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.reset()')
  def inc(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_inc_(*args): # 
      return self._inc_(*args)
    elif mosek_fusion_IndexCounter._match_alt_inc_(*args): # 
      return self._inc_alt_(*args)
    else:
      raise ValueError('Invalid argument list inc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.inc()')
  def atEnd(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_atEnd_(*args): # 
      return self._atEnd_(*args)
    elif mosek_fusion_IndexCounter._match_alt_atEnd_(*args): # 
      return self._atEnd_alt_(*args)
    else:
      raise ValueError('Invalid argument list atEnd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.atEnd()')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_getIndex_(*args): # 
      return self._getIndex_(*args)
    elif mosek_fusion_IndexCounter._match_alt_getIndex_(*args): # 
      return self._getIndex_alt_(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.getIndex()')
  def next(self,*args):
    if False: pass
    elif mosek_fusion_IndexCounter._match_next_(*args): # 
      return self._next_(*args)
    elif mosek_fusion_IndexCounter._match_alt_next_(*args): # 
      return self._next_alt_(*args)
    else:
      raise ValueError('Invalid argument list next('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.IndexCounter.next()')
  def __repr__(self): return 'mosek.fusion.IndexCounter'
  @staticmethod
  def _ctor__3I(shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   self.__n = int((shape).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   self.__start = 0
   self.__strides = mosek.fusion.Set._strides__3I(shape)
   self.__dims = numpy.array([shape[_0] for _0 in range(0,int((shape).shape[0]))], dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_J_3I_3I(start_,dims_,shape):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3I(start_,dims_,shape)
    return o
  @staticmethod
  def __match_ctor_J_3I_3I(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor_J_3I_3I(*args):
    if len(args) != 3: return False
    start_,dims_,shape, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3I__(shape))
  def _ctor_alt_init_J_3I_3I(self,start_,dims_,shape):
    self._ctor_init_J_3I_3I(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_J_3I_3I(self,start_,dims_,shape):
   _0=int((shape).shape[0])
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_100(self.__n,self.__st,start_) # src/fusion/CommonUtil.mbi:481:21-56
   self.__strides = mosek.fusion.Set._strides__3I(shape)
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _ctor_J_3I_3J(start_,dims_,strides_):
    o = IndexCounter.__new__(IndexCounter)
    o._ctor_init_J_3I_3J(start_,dims_,strides_)
    return o
  @staticmethod
  def __match_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_match_J__(start_) and __arg_match__3I__(dims_) and __arg_match__3J__(strides_))
  @staticmethod
  def __match_alt_ctor_J_3I_3J(*args):
    if len(args) != 3: return False
    start_,dims_,strides_, = args
    return (__arg_alt_match_J__(start_) and __arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(strides_))
  def _ctor_alt_init_J_3I_3J(self,start_,dims_,strides_):
    self._ctor_init_J_3I_3J(numpy.int64(start_),numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(strides_,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_J_3I_3J(self,start_,dims_,strides_):
   self.__n = int((dims_).shape[0])
   self.__ii = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int32))
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_101(self.__n,self.__st,start_) # src/fusion/CommonUtil.mbi:466:21-56
   self.__strides = strides_
   self.__dims = dims_
   self.__start = start_
  @staticmethod
  def _match_atEnd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_atEnd_(*args):
    if len(args) != 0: return False
    return True
  def _atEnd_alt_(self,):
    return self._atEnd_()
  def _atEnd_(self,):
   return ((self.__ii[(self.__n - 1)] >= self.__dims[(self.__n - 1)]))
  @staticmethod
  def _match_getIndex_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getIndex_(*args):
    if len(args) != 0: return False
    return True
  def _getIndex_alt_(self,):
    return self._getIndex_()
  def _getIndex_(self,):
   return (self.__ii)
  @staticmethod
  def _match_next_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_next_(*args):
    if len(args) != 0: return False
    return True
  def _next_alt_(self,):
    return self._next_()
  def _next_(self,):
   _0=self._get_()
   self._inc_()
   return numpy.int64(_0)
  @staticmethod
  def _match_get_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_(*args):
    if len(args) != 0: return False
    return True
  def _get_alt_(self,):
    return self._get_()
  def _get_(self,):
   return numpy.int64(self.__st[0])
  @staticmethod
  def _match_inc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inc_(*args):
    if len(args) != 0: return False
    return True
  def _inc_alt_(self,):
    return self._inc_()
  def _inc_(self,):
   fragments._c_closure_102(self.__dims,self.__ii,self.__n,self.__st,self.__strides) # src/fusion/CommonUtil.mbi:506:6-517:7
  @staticmethod
  def _match_reset_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_reset_(*args):
    if len(args) != 0: return False
    return True
  def _reset_alt_(self,):
    return self._reset_()
  def _reset_(self,):
   self.__st = numpy.zeros((self.__n,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_103(self.__n,self.__st,self.__start) # src/fusion/CommonUtil.mbi:502:21-55
 return IndexCounter
mosek_fusion_IndexCounter=__mk_mosek_fusion_IndexCounter()
del __mk_mosek_fusion_IndexCounter
#BEFORE CLASS
def __mk_mosek_fusion_CommonTools():
 class CommonTools(object):
  @staticmethod
  def tripletSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list tripletSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.tripletSort(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def argQsort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3I_3IJJ(*args): # []int64,[]int32,[]int32,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3I_3IJJ(*args)
    elif mosek_fusion_CommonTools._match_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(*args)
    elif mosek_fusion_CommonTools._match_alt_argQsort__3J_3J_3JJJ(*args): # []int64,[]int64,[]int64,int64,int64
      return mosek_fusion_CommonTools._argQsort_alt__3J_3J_3JJJ(*args)
    else:
      raise ValueError('Invalid argument list argQsort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int32,ndim=1),array(int32,ndim=1),int64,int64)\n\tmosek.fusion.CommonTools.argQsort(array(int64,ndim=1),array(int64,ndim=1),array(int64,ndim=1),int64,int64)')
  @staticmethod
  def binarySearchR(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearchR__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchR__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearchR__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchR_alt__3JJ(*args)
    else:
      raise ValueError('Invalid argument list binarySearchR('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearchR(array(int64,ndim=1),int64)')
  @staticmethod
  def binarySearch(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearch__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearch__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearch__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearch_alt__3JJ(*args)
    elif mosek_fusion_CommonTools._match_binarySearch__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._binarySearch__3II(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearch__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._binarySearch_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list binarySearch('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearch(array(int64,ndim=1),int64)\n\tmosek.fusion.CommonTools.binarySearch(array(int32,ndim=1),int32)')
  @staticmethod
  def binarySearchL(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_binarySearchL__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchL__3JJ(*args)
    elif mosek_fusion_CommonTools._match_alt_binarySearchL__3JJ(*args): # []int64,int64
      return mosek_fusion_CommonTools._binarySearchL_alt__3JJ(*args)
    else:
      raise ValueError('Invalid argument list binarySearchL('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.binarySearchL(array(int64,ndim=1),int64)')
  @staticmethod
  def argMSort(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort__3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_argMSort__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_CommonTools._argMSort_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list argMSort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.argMSort(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def resize(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_resize__3DI(*args): # []double,int32
      return mosek_fusion_CommonTools._resize__3DI(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3DI(*args): # []double,int32
      return mosek_fusion_CommonTools._resize_alt__3DI(*args)
    elif mosek_fusion_CommonTools._match_resize__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._resize__3II(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3II(*args): # []int32,int32
      return mosek_fusion_CommonTools._resize_alt__3II(*args)
    elif mosek_fusion_CommonTools._match_resize__3JI(*args): # []int64,int32
      return mosek_fusion_CommonTools._resize__3JI(*args)
    elif mosek_fusion_CommonTools._match_alt_resize__3JI(*args): # []int64,int32
      return mosek_fusion_CommonTools._resize_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.resize(array(double,ndim=1),int32)\n\tmosek.fusion.CommonTools.resize(array(int32,ndim=1),int32)\n\tmosek.fusion.CommonTools.resize(array(int64,ndim=1),int32)')
  @staticmethod
  def transposeTriplets(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args): # []int32,[]int32,[]double,[][]int32,[][]int32,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    elif mosek_fusion_CommonTools._match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args): # []int32,[]int32,[]double,[][]int64,[][]int64,[][]double,int64,int32,int32
      return mosek_fusion_CommonTools._transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(*args)
    else:
      raise ValueError('Invalid argument list transposeTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int32,ndim=1),ndim=1),array(array(int32,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)\n\tmosek.fusion.CommonTools.transposeTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(array(int64,ndim=1),ndim=1),array(array(int64,ndim=1),ndim=1),array(array(double,ndim=1),ndim=1),int64,int32,int32)')
  @staticmethod
  def ndIncr(*args):
    if False: pass
    elif mosek_fusion_CommonTools._match_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr__3I_3I_3I(*args)
    elif mosek_fusion_CommonTools._match_alt_ndIncr__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return mosek_fusion_CommonTools._ndIncr_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list ndIncr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.CommonTools.ndIncr(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.CommonTools'
  @staticmethod
  def _match_resize__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3JI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3JI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3JI(_0,_1):
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:434:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:438:14-35
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_resize__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3II(_0,_1):
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:422:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:426:14-35
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_resize__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_resize__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _resize_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._resize__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _resize__3DI(_0,_1):
   if (_1==int((_0).shape[0])): # src/fusion/CommonUtil.mbi:410:12-34
    return (_0)
   else:
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    if (_1 > int((_0).shape[0])): # src/fusion/CommonUtil.mbi:414:14-35
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_0,0,_2,0,int((_0).shape[0]))
    else:
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_0,0,_2,0,_1)
    return (_2)
  @staticmethod
  def _match_binarySearch__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_binarySearch__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _binarySearch_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearch__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearch__3II(_0,_1):
   _2=0
   _3=int((_0).shape[0])
   if (_0[_2]==_1): # src/fusion/CommonUtil.mbi:395:12-32
    return numpy.int32(_2)
   elif (_0[(_3 - 1)]==_1): # src/fusion/CommonUtil.mbi:396:16-38
    return numpy.int32((_3 - 1))
   while (_2 < (_3 - 1)):
    _4=((_3 - _2) // 2)
    if (_1 < _0[_4]): # src/fusion/CommonUtil.mbi:399:14-32
     _2 = (_4 + 1)
    elif (_1 > _0[_4]): # src/fusion/CommonUtil.mbi:401:18-36
     _3 = _4
    else:
     return numpy.int32(_4)
   return numpy.int32((- 1))
  @staticmethod
  def _match_binarySearch__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearch__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearch_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearch__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearch__3JJ(_0,_1):
   _2=mosek.fusion.CommonTools._binarySearchL__3JJ(_0,_1)
   if ((_2 < int((_0).shape[0])) and (_0[_2]==_1)): # src/fusion/CommonUtil.mbi:385:12-51
    return numpy.int32(_2)
   else:
    return numpy.int32((- 1))
  @staticmethod
  def _match_binarySearchR__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearchR__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearchR_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearchR__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearchR__3JJ(_0,_1):
   _2=0
   _3=int((_0).shape[0])
   if (_0[_2] > _1): # src/fusion/CommonUtil.mbi:371:12-31
    return numpy.int32(_2)
   _2,_3 = fragments._c_closure_104(_2,_3,_1,_0) # src/fusion/CommonUtil.mbi:373:8-379:9
   _2 = numpy.int32(_2) # postprocess
   _3 = numpy.int32(_3) # postprocess
   return numpy.int32(_3)
  @staticmethod
  def _match_binarySearchL__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_binarySearchL__3JJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _binarySearchL_alt__3JJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_CommonTools._binarySearchL__3JJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binarySearchL__3JJ(_0,_1):
   _2=0
   _3=int((_0).shape[0])
   if (_1 <= _0[_2]): # src/fusion/CommonUtil.mbi:354:12-32
    return numpy.int32(_2)
   _2,_3 = fragments._c_closure_105(_2,_3,_1,_0) # src/fusion/CommonUtil.mbi:356:8-362:9
   _2 = numpy.int32(_2) # postprocess
   _3 = numpy.int32(_3) # postprocess
   return numpy.int32(_3)
  @staticmethod
  def _match_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_ndIncr__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _ndIncr_alt__3I_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._ndIncr__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ndIncr__3I_3I_3I(_0,_1,_2):
   fragments._c_closure_106(_1,_2,_0) # src/fusion/CommonUtil.mbi:338:6-346:7
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3J__(_3) and __arg_match__3_3J__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3J__(_3) and __arg_alt_match__3_3J__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3J_3_3J_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int64))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int64))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3J_3_3J_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_107(_10,_6,_9,_0,_1) # src/fusion/CommonUtil.mbi:305:8-309:9
   fragments._c_closure_108(_7,_9) # src/fusion/CommonUtil.mbi:311:8-78
   fragments._c_closure_109(_10,_8) # src/fusion/CommonUtil.mbi:312:8-78
   _11=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
   _13=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_110(_10,_7,_9,_1,_11,_12,_13,_2) # src/fusion/CommonUtil.mbi:318:8-330:9
   _3[0] = _12
   _4[0] = _11
   _5[0] = _13
  @staticmethod
  def _match_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _transposeTriplets_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _transposeTriplets__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   _9=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_111(_10,_6,_9,_0,_1) # src/fusion/CommonUtil.mbi:257:8-261:9
   fragments._c_closure_112(_7,_9) # src/fusion/CommonUtil.mbi:263:8-78
   fragments._c_closure_113(_10,_8) # src/fusion/CommonUtil.mbi:264:8-78
   _11=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_114(_10,_7,_9,_1,_11,_12,_13,_2) # src/fusion/CommonUtil.mbi:270:8-282:9
   _3[0] = _12
   _4[0] = _11
   _5[0] = _13
  @staticmethod
  def _match_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3_3I__(_3) and __arg_match__3_3I__(_4) and __arg_match__3_3D__(_5) and __arg_match_J__(_6) and __arg_match_I__(_7) and __arg_match_I__(_8))
  @staticmethod
  def _match_alt_tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(*args):
    if len(args) != 9: return False
    _0,_1,_2,_3,_4,_5,_6,_7,_8, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3_3I__(_3) and __arg_alt_match__3_3I__(_4) and __arg_alt_match__3_3D__(_5) and __arg_alt_match_J__(_6) and __arg_alt_match_I__(_7) and __arg_alt_match_I__(_8))
  @staticmethod
  def _tripletSort_alt__3I_3I_3D_3_3I_3_3I_3_3DJII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=_monty.makeJaggedArray(_t__3,(1,1),numpy.dtype(numpy.int32))
   _4=_monty.makeJaggedArray(_t__4,(1,1),numpy.dtype(numpy.int32))
   _5=_monty.makeJaggedArray(_t__5,(1,1),numpy.dtype(numpy.float64))
   _6=numpy.int64(_t__6)
   _7=numpy.int32(_t__7)
   _8=numpy.int32(_t__8)
   _1 = mosek_fusion_CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(_0,_1,_2,_3,_4,_5,_6,_7,_8):
   _9=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros(((_8 + 2),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_115(_10,_6,_1) # src/fusion/CommonUtil.mbi:132:8-75
   fragments._c_closure_116(_10,_8) # src/fusion/CommonUtil.mbi:133:8-69
   fragments._c_closure_117(_9,_10,_6,_1) # src/fusion/CommonUtil.mbi:134:8-139:9
   _11=numpy.zeros(((_7 + 2),), dtype=numpy.dtype(numpy.int64))
   _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_118(_6,_11,_0) # src/fusion/CommonUtil.mbi:145:8-82
   fragments._c_closure_119(_7,_11) # src/fusion/CommonUtil.mbi:146:8-78
   fragments._c_closure_120(_9,_10,_8,_12,_11,_0) # src/fusion/CommonUtil.mbi:147:8-155:9
   _13=1
   _13 = fragments._c_closure_121(_6,_13,_12,_0,_1) # src/fusion/CommonUtil.mbi:161:8-177:9
   _13 = numpy.int32(_13) # postprocess
   _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
   _17=_12[0]
   _14[0] = _0[_17]
   _15[0] = _1[_17]
   _16[0] = _2[_17]
   _18=1
   _18 = fragments._c_closure_122(_18,_6,_12,_0,_1,_14,_15,_16,_2) # src/fusion/CommonUtil.mbi:192:8-209:9
   _18 = numpy.int32(_18) # postprocess
   _3[0] = _14
   _4[0] = _15
   _5[0] = _16
  @staticmethod
  def _match_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_argMSort__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _argMSort_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_CommonTools._argMSort__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argMSort__3I_3I(_0,_1):
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _3=False
   _4=1
   while (_4 < int((_0).shape[0])):
    _3 = (not _3)
    for _5 in range(0,int((_0).shape[0]),(_4 * 2)):
     if _3: # src/fusion/CommonUtil.mbi:79:16-19
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_0,_2,_1,_5,(_5 + _4),(_5 + (2 * _4)))
     else:
      mosek.fusion.CommonTools.__mergeInto__3I_3I_3IIII(_2,_0,_1,_5,(_5 + _4),(_5 + (2 * _4)))
    _4 *= 2
   if _3: # src/fusion/CommonUtil.mbi:85:12-15
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_2,0,_0,0,int((_0).shape[0]))
  @staticmethod
  def __mergeInto_alt__3I_3I_3IIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _1 = mosek_fusion_CommonTools.__mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mergeInto__3I_3I_3IIII(_0,_1,_2,_3,_4,_5):
   _6=(int((_0).shape[0]) if ((_5 > int((_0).shape[0])) ) else _5)
   _7=(_6 if ((_4 > _6) ) else _4)
   if (_7==_6): # src/fusion/CommonUtil.mbi:39:12-22
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,_3,_1,_3,(_7 - _3))
   else:
    fragments._c_closure_123(_3,_7,_6,_0,_1,_2) # src/fusion/CommonUtil.mbi:42:8-53:9
  @staticmethod
  def _match_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3J_3JJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3J_3JJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3J_3JJJ(_0,_1,_2,_3,_4):
   if (_2 is None): # src/fusion/CommonUtil.mbi:18:12-25
    mosek.fusion.Utils.Tools._argsort__3J_3JJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3J_3JJJ(_0,_1,_2,_3,_4)
  @staticmethod
  def _match_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match__3J__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2) and __arg_match_J__(_3) and __arg_match_J__(_4))
  @staticmethod
  def _match_alt_argQsort__3J_3I_3IJJ(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_J__(_3) and __arg_alt_match_J__(_4))
  @staticmethod
  def _argQsort_alt__3J_3I_3IJJ(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int64(_t__3)
   _4=numpy.int64(_t__4)
   _1 = mosek_fusion_CommonTools._argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _argQsort__3J_3I_3IJJ(_0,_1,_2,_3,_4):
   if (_2 is None): # src/fusion/CommonUtil.mbi:10:12-25
    mosek.fusion.Utils.Tools._argsort__3J_3IJJ(_0,_1,_3,_4)
   else:
    mosek.fusion.Utils.Tools._argsort__3J_3I_3IJJ(_0,_1,_2,_3,_4)
 return CommonTools
mosek_fusion_CommonTools=__mk_mosek_fusion_CommonTools()
del __mk_mosek_fusion_CommonTools
#BEFORE CLASS
def __mk_mosek_fusion_SolutionStruct():
 class SolutionStruct(object):
  __slots__ = ['accy','accx','accptr','yx','sux','slx','bars','barx','y','suc','slc','xx','xc','dobj','pobj','probstatus','dstatus','pstatus','sol_numbarvar','sol_numaccelm','sol_numacc','sol_numvar','sol_numcon']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args): # mosek.fusion.SolutionStruct
      self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):# mosek.fusion.SolutionStruct
      self._ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(*args)
    elif self.__match_ctor_IIIII(*args): # int32,int32,int32,int32,int32
      self._ctor_init_IIIII(*args)
    elif self.__match_alt_ctor_IIIII(*args):# int32,int32,int32,int32,int32
      self._ctor_alt_init_IIIII(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.SolutionStruct.ctor(mosek.fusion.SolutionStruct)\n\tmosek.fusion.SolutionStruct.ctor(int32,int32,int32,int32,int32)')
  def isPrimalAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isPrimalAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isPrimalAcceptable(mosek.fusion.AccSolutionStatus)')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_clone_(*args): # 
      return self._clone_(*args)
    elif mosek_fusion_SolutionStruct._match_alt_clone_(*args): # 
      return self._clone_alt_(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.clone()')
  def isDualAcceptable(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args)
    elif mosek_fusion_SolutionStruct._match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args): # mosek.fusion.AccSolutionStatus
      return self._isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(*args)
    else:
      raise ValueError('Invalid argument list isDualAcceptable('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.isDualAcceptable(mosek.fusion.AccSolutionStatus)')
  def resize(self,*args):
    if False: pass
    elif mosek_fusion_SolutionStruct._match_resize_IIIII(*args): # int32,int32,int32,int32,int32
      return self._resize_IIIII(*args)
    elif mosek_fusion_SolutionStruct._match_alt_resize_IIIII(*args): # int32,int32,int32,int32,int32
      return self._resize_alt_IIIII(*args)
    else:
      raise ValueError('Invalid argument list resize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SolutionStruct.resize(int32,int32,int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.SolutionStruct'
  @staticmethod
  def _ctor_IIIII(numvar,numcon,numbarvar,numacc,numaccelm):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_IIIII(numvar,numcon,numbarvar,numacc,numaccelm)
    return o
  @staticmethod
  def __match_ctor_IIIII(*args):
    if len(args) != 5: return False
    numvar,numcon,numbarvar,numacc,numaccelm, = args
    return (__arg_match_I__(numvar) and __arg_match_I__(numcon) and __arg_match_I__(numbarvar) and __arg_match_I__(numacc) and __arg_match_I__(numaccelm))
  @staticmethod
  def __match_alt_ctor_IIIII(*args):
    if len(args) != 5: return False
    numvar,numcon,numbarvar,numacc,numaccelm, = args
    return (__arg_alt_match_I__(numvar) and __arg_alt_match_I__(numcon) and __arg_alt_match_I__(numbarvar) and __arg_alt_match_I__(numacc) and __arg_alt_match_I__(numaccelm))
  def _ctor_alt_init_IIIII(self,numvar,numcon,numbarvar,numacc,numaccelm):
    self._ctor_init_IIIII(numpy.int32(numvar),numpy.int32(numcon),numpy.int32(numbarvar),numpy.int32(numacc),numpy.int32(numaccelm))
  def _ctor_init_IIIII(self,numvar,numcon,numbarvar,numacc,numaccelm):
   self.pobj = 0.0
   self.dobj = 0.0
   self.pstatus = mosek.fusion.SolutionStatus.Unknown
   self.dstatus = mosek.fusion.SolutionStatus.Unknown
   self.probstatus = mosek.fusion.ProblemStatus.Unknown
   self.sol_numvar = numvar
   self.sol_numcon = numcon
   self.sol_numbarvar = numbarvar
   self.sol_numacc = numacc
   self.sol_numaccelm = numaccelm
   self.slx = None
   self.sux = None
   self.xx = None
   self.yx = None
   self.slc = None
   self.suc = None
   self.y = None
   self.xc = None
   self.barx = None
   self.bars = None
   self.accx = None
   self.accy = None
   self.accptr = None
   if (numvar > 0): # src/fusion/Model.mbi:5635:12-22
    self.slx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.sux = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.xx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
    self.yx = numpy.zeros((numvar,), dtype=numpy.dtype(numpy.float64))
   if (numbarvar > 0): # src/fusion/Model.mbi:5644:12-25
    self.barx = numpy.zeros((numbarvar,), dtype=numpy.dtype(numpy.float64))
    self.bars = numpy.zeros((numbarvar,), dtype=numpy.dtype(numpy.float64))
   if (numcon > 0): # src/fusion/Model.mbi:5650:12-22
    self.slc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.suc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.y = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
    self.xc = numpy.zeros((numcon,), dtype=numpy.dtype(numpy.float64))
   if (numacc > 0): # src/fusion/Model.mbi:5659:12-22
    self.accx = numpy.zeros((numaccelm,), dtype=numpy.dtype(numpy.float64))
    self.accy = numpy.zeros((numaccelm,), dtype=numpy.dtype(numpy.float64))
    self.accptr = numpy.zeros(((numacc + 1),), dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_Lmosek_4fusion_4SolutionStruct_2(that):
    o = SolutionStruct.__new__(SolutionStruct)
    o._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SolutionStruct_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(that))
  def _ctor_alt_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
    self._ctor_init_Lmosek_4fusion_4SolutionStruct_2(that)
  def _ctor_init_Lmosek_4fusion_4SolutionStruct_2(self,that):
   self.sol_numcon = (that.sol_numcon)
   self.sol_numvar = (that.sol_numvar)
   self.sol_numbarvar = (that.sol_numbarvar)
   self.sol_numacc = (that.sol_numacc)
   self.sol_numaccelm = (that.sol_numaccelm)
   self.pstatus = (that.pstatus)
   self.dstatus = (that.dstatus)
   self.probstatus = (that.probstatus)
   self.pobj = (that.pobj)
   self.dobj = (that.dobj)
   self.xc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xc)) if (((that.xc) is not None) ) else None)
   self.xx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.xx)) if (((that.xx) is not None) ) else None)
   self.yx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.yx)) if (((that.yx) is not None) ) else None)
   self.slc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slc)) if (((that.slc) is not None) ) else None)
   self.suc = (mosek.fusion.Utils.Tools._arraycopy__3D((that.suc)) if (((that.suc) is not None) ) else None)
   self.y = (mosek.fusion.Utils.Tools._arraycopy__3D((that.y)) if (((that.y) is not None) ) else None)
   self.barx = mosek.fusion.Utils.Tools._arraycopy__3D((that.barx))
   self.bars = mosek.fusion.Utils.Tools._arraycopy__3D((that.bars))
   self.slx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.slx)) if (((that.slx) is not None) ) else None)
   self.sux = (mosek.fusion.Utils.Tools._arraycopy__3D((that.sux)) if (((that.sux) is not None) ) else None)
   self.accptr = (mosek.fusion.Utils.Tools._arraycopy__3I((that.accptr)) if (((that.accptr) is not None) ) else None)
   self.accx = (mosek.fusion.Utils.Tools._arraycopy__3D((that.accx)) if (((that.accx) is not None) ) else None)
   self.accy = (mosek.fusion.Utils.Tools._arraycopy__3D((that.accy)) if (((that.accy) is not None) ) else None)
  @staticmethod
  def _match_clone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clone_(*args):
    if len(args) != 0: return False
    return True
  def _clone_alt_(self,):
    return self._clone_()
  def _clone_(self,):
   return (mosek_fusion_SolutionStruct._ctor_Lmosek_4fusion_4SolutionStruct_2(self))
  @staticmethod
  def _match_resize_IIIII(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4))
  @staticmethod
  def _match_alt_resize_IIIII(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4))
  def _resize_alt_IIIII(self,_t__0,_t__1,_t__2,_t__3,_t__4):
    return self._resize_IIIII(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),numpy.int32(__3),numpy.int32(__4))
  def _resize_IIIII(self,_0,_1,_2,_3,_4):
   if (_3 <= 0): # src/fusion/Model.mbi:5406:12-23
    self.sol_numacc = 0
   elif (_3 <= (int((self.accptr).shape[0]) - 1)): # src/fusion/Model.mbi:5409:16-39
    self.sol_numacc = _3
   else:
    _5=((int((self.accptr).shape[0]) - 1) * 2)
    if (_5 < _3): # src/fusion/Model.mbi:5413:46-61
     _5 = _3
    _6=numpy.zeros(((_5 + 1),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.accptr,0,_6,0,(_3 + 1))
    self.accptr = _6
    self.sol_numacc = _3
   if (_4 <= 0): # src/fusion/Model.mbi:5420:12-26
    self.sol_numaccelm = 0
   elif (_4 > int((self.accx).shape[0])): # src/fusion/Model.mbi:5423:16-37
    self.sol_numaccelm = _4
   else:
    _7=(int((self.accx).shape[0]) * 2)
    if (_7 < _4): # src/fusion/Model.mbi:5427:40-58
     _7 = _4
    _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
    _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.accx,0,_8,0,_4)
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.accy,0,_9,0,_4)
    self.accx = _8
    self.accy = _9
    self.sol_numaccelm = _4
   if (_2 < 0): # src/fusion/Model.mbi:5438:14-27
    pass
   elif (_2 <= self.sol_numbarvar): # src/fusion/Model.mbi:5440:18-44
    self.sol_numbarvar = _2
   elif (_2 <= int((self.barx).shape[0])): # src/fusion/Model.mbi:5443:18-40
    pass
   else:
    if ((self.sol_numbarvar * 2) > (_2 + 100)): # src/fusion/Model.mbi:5448:18-53
     _10 = (self.sol_numbarvar * 2)
    else:
     _10 = (_2 + 100)
    self.barx = mosek.fusion.CommonTools._resize__3DI(self.barx,_10)
    self.bars = mosek.fusion.CommonTools._resize__3DI(self.bars,_10)
    self.sol_numbarvar = _10
   if (_0 < 0): # src/fusion/Model.mbi:5457:14-24
    pass
   elif (_0 <= self.sol_numvar): # src/fusion/Model.mbi:5461:18-38
    self.sol_numvar = _0
   elif (_0 <= int((self.xx).shape[0])): # src/fusion/Model.mbi:5466:18-35
    self.sol_numvar = fragments._c_closure_124(_0,self.slx,self.sol_numvar,self.sux,self.xx,self.yx) # src/fusion/Model.mbi:5467:10-5477:11
    self.sol_numvar = numpy.int32(self.sol_numvar) # postprocess
   else:
    if ((self.sol_numvar * 2) > (_0 + 100)): # src/fusion/Model.mbi:5482:18-47
     _11 = (self.sol_numvar * 2)
    else:
     _11 = (_0 + 100)
    _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slx,0,_12,0,int((self.slx).shape[0]))
    self.slx = _12
    _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.sux,0,_13,0,int((self.sux).shape[0]))
    self.sux = _13
    _14=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xx,0,_14,0,int((self.xx).shape[0]))
    self.xx = _14
    _15=numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.yx,0,_15,0,int((self.yx).shape[0]))
    self.yx = _15
    fragments._c_closure_125(_0,self.slx,self.sol_numvar,self.sux,self.xx) # src/fusion/Model.mbi:5501:14-5507:15
    self.sol_numvar = _0
   if (_1 < 0): # src/fusion/Model.mbi:5512:14-24
    pass
   elif (_1 <= self.sol_numcon): # src/fusion/Model.mbi:5516:18-38
    self.sol_numcon = _1
   elif (_1 <= int((self.xx).shape[0])): # src/fusion/Model.mbi:5521:18-35
    self.sol_numcon = fragments._c_closure_126(_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) # src/fusion/Model.mbi:5522:10-5533:11
    self.sol_numcon = numpy.int32(self.sol_numcon) # postprocess
   else:
    if ((self.sol_numcon * 2) > (_1 + 100)): # src/fusion/Model.mbi:5538:18-47
     _16 = (self.sol_numcon * 2)
    else:
     _16 = (_1 + 100)
    _17=numpy.zeros((_16,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.slc,0,_17,0,int((self.slc).shape[0]))
    self.slc = _17
    _18=numpy.zeros((_16,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.suc,0,_18,0,int((self.suc).shape[0]))
    self.suc = _18
    _19=numpy.zeros((_16,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.xc,0,_19,0,int((self.xc).shape[0]))
    self.xc = _19
    _20=numpy.zeros((_16,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.y,0,_20,0,int((self.y).shape[0]))
    self.y = _20
    fragments._c_closure_127(_1,self.slc,self.sol_numcon,self.suc,self.xc,self.y) # src/fusion/Model.mbi:5557:14-5563:15
    self.sol_numcon = _1
  @staticmethod
  def _match_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isDualAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isDualAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.dstatus,_0))
  @staticmethod
  def _match_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  @staticmethod
  def _match_alt_isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(_0))
  def _isPrimalAcceptable_alt_Emosek_4fusion_4AccSolutionStatus_2(self,_t__0):
    return self._isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(__0)
  def _isPrimalAcceptable_Emosek_4fusion_4AccSolutionStatus_2(self,_0):
   return (self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self.pstatus,_0))
  def __isAcceptable_alt_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_t__0,_t__1):
    return self.__isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(__0,__1)
  def __isAcceptable_Emosek_4fusion_4SolutionStatus_2Emosek_4fusion_4AccSolutionStatus_2(self,_0,_1):
   if (_1==mosek.fusion.AccSolutionStatus.Anything): # src/fusion/Model.mbi:5367:16-53
    return (True)
   elif (_1==mosek.fusion.AccSolutionStatus.Optimal): # src/fusion/Model.mbi:5371:16-52
    return ((_0==mosek.fusion.SolutionStatus.Optimal))
   elif (_1==mosek.fusion.AccSolutionStatus.Feasible): # src/fusion/Model.mbi:5375:16-53
    return (((_0==mosek.fusion.SolutionStatus.Optimal) or (_0==mosek.fusion.SolutionStatus.Feasible)))
   elif (_1==mosek.fusion.AccSolutionStatus.Certificate): # src/fusion/Model.mbi:5381:16-56
    return ((_0==mosek.fusion.SolutionStatus.Certificate))
   return (False)
 return SolutionStruct
mosek_fusion_SolutionStruct=__mk_mosek_fusion_SolutionStruct()
del __mk_mosek_fusion_SolutionStruct
#BEFORE CLASS
def __mk_mosek_fusion_RowBlockManager():
 class RowBlockManager(object):
  __slots__ = ['varidx_used','code_used','cconst','code','first_free_codeitem','param_code_sizes','param_varidx','first_free_entry','row_code_ptr','row_param_ptre','row_param_ptrb','blocks']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_Lmosek_4fusion_4RowBlockManager_2(*args): # mosek.fusion.RowBlockManager
      self._ctor_init_Lmosek_4fusion_4RowBlockManager_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4RowBlockManager_2(*args):# mosek.fusion.RowBlockManager
      self._ctor_alt_init_Lmosek_4fusion_4RowBlockManager_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.RowBlockManager.ctor()\n\tmosek.fusion.RowBlockManager.ctor(mosek.fusion.RowBlockManager)')
  def is_parameterized(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_is_1parameterized_(*args): # 
      return self._is_1parameterized_(*args)
    elif mosek_fusion_RowBlockManager._match_alt_is_1parameterized_(*args): # 
      return self._is_1parameterized_alt_(*args)
    else:
      raise ValueError('Invalid argument list is_parameterized('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.is_parameterized()')
  def block_capacity(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_block_1capacity_(*args): # 
      return self._block_1capacity_(*args)
    elif mosek_fusion_RowBlockManager._match_alt_block_1capacity_(*args): # 
      return self._block_1capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list block_capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.block_capacity()')
  def replace_row_code(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args): # mosek.fusion.WorkStack,[]int32,int32,int32,int32,int32,int32
      return self._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args)
    elif mosek_fusion_RowBlockManager._match_alt_replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args): # mosek.fusion.WorkStack,[]int32,int32,int32,int32,int32,int32
      return self._replace_1row_1code_alt_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args)
    else:
      raise ValueError('Invalid argument list replace_row_code('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.replace_row_code(mosek.fusion.WorkStack,array(int32,ndim=1),int32,int32,int32,int32,int32)')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_get_I_3II(*args): # int32,[]int32,int32
      return self._get_I_3II(*args)
    elif mosek_fusion_RowBlockManager._match_alt_get_I_3II(*args): # int32,[]int32,int32
      return self._get_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.get(int32,array(int32,ndim=1),int32)')
  def blocksize(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_blocksize_I(*args): # int32
      return self._blocksize_I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_blocksize_I(*args): # int32
      return self._blocksize_alt_I(*args)
    else:
      raise ValueError('Invalid argument list blocksize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.blocksize(int32)')
  def evaluate(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args): # mosek.fusion.WorkStack,[]double,[]int32,[]int32,[]double
      return self._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args)
    elif mosek_fusion_RowBlockManager._match_alt_evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args): # mosek.fusion.WorkStack,[]double,[]int32,[]int32,[]double
      return self._evaluate_alt_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list evaluate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.evaluate(mosek.fusion.WorkStack,array(double,ndim=1),array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def clear_row_code(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_clear_1row_1code__3I(*args): # []int32
      return self._clear_1row_1code__3I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_clear_1row_1code__3I(*args): # []int32
      return self._clear_1row_1code_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list clear_row_code('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.clear_row_code(array(int32,ndim=1))')
  def num_parameterized(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_num_1parameterized_(*args): # 
      return self._num_1parameterized_(*args)
    elif mosek_fusion_RowBlockManager._match_alt_num_1parameterized_(*args): # 
      return self._num_1parameterized_alt_(*args)
    else:
      raise ValueError('Invalid argument list num_parameterized('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.num_parameterized()')
  def row_is_parameterized(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_row_1is_1parameterized_I(*args): # int32
      return self._row_1is_1parameterized_I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_row_1is_1parameterized_I(*args): # int32
      return self._row_1is_1parameterized_alt_I(*args)
    else:
      raise ValueError('Invalid argument list row_is_parameterized('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.row_is_parameterized(int32)')
  def allocate(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_allocate__3I(*args): # []int32
      return self._allocate__3I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_allocate__3I(*args): # []int32
      return self._allocate_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list allocate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.allocate(array(int32,ndim=1))')
  def release(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_release_I_3I(*args): # int32,[]int32
      return self._release_I_3I(*args)
    elif mosek_fusion_RowBlockManager._match_alt_release_I_3I(*args): # int32,[]int32
      return self._release_alt_I_3I(*args)
    else:
      raise ValueError('Invalid argument list release('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.release(int32,array(int32,ndim=1))')
  def capacity(self,*args):
    if False: pass
    elif mosek_fusion_RowBlockManager._match_capacity_(*args): # 
      return self._capacity_(*args)
    elif mosek_fusion_RowBlockManager._match_alt_capacity_(*args): # 
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RowBlockManager.capacity()')
  def __repr__(self): return 'mosek.fusion.RowBlockManager'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RowBlockManager_2(that):
    o = RowBlockManager.__new__(RowBlockManager)
    o._ctor_init_Lmosek_4fusion_4RowBlockManager_2(that)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RowBlockManager_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_match_Lmosek_4fusion_4RowBlockManager_2__(that))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RowBlockManager_2(*args):
    if len(args) != 1: return False
    that, = args
    return (__arg_alt_match_Lmosek_4fusion_4RowBlockManager_2__(that))
  def _ctor_alt_init_Lmosek_4fusion_4RowBlockManager_2(self,that):
    self._ctor_init_Lmosek_4fusion_4RowBlockManager_2(that)
  def _ctor_init_Lmosek_4fusion_4RowBlockManager_2(self,that):
   self.blocks = mosek_fusion_LinkedBlocks._ctor_Lmosek_4fusion_4LinkedBlocks_2((that.blocks))
   self.row_param_ptrb = (mosek.fusion.Utils.Tools._arraycopy__3I((that.row_param_ptrb)) if (((that.row_param_ptrb) is not None) ) else None)
   self.row_param_ptre = (mosek.fusion.Utils.Tools._arraycopy__3I((that.row_param_ptre)) if (((that.row_param_ptre) is not None) ) else None)
   self.row_code_ptr = (mosek.fusion.Utils.Tools._arraycopy__3I((that.row_code_ptr)) if (((that.row_code_ptr) is not None) ) else None)
   self.first_free_entry = (that.first_free_entry)
   self.param_varidx = (mosek.fusion.Utils.Tools._arraycopy__3J((that.param_varidx)) if (((that.param_varidx) is not None) ) else None)
   self.param_code_sizes = (mosek.fusion.Utils.Tools._arraycopy__3I((that.param_code_sizes)) if (((that.param_code_sizes) is not None) ) else None)
   self.first_free_codeitem = (that.first_free_codeitem)
   self.code = (mosek.fusion.Utils.Tools._arraycopy__3I((that.code)) if (((that.code) is not None) ) else None)
   self.cconst = (mosek.fusion.Utils.Tools._arraycopy__3D((that.cconst)) if (((that.cconst) is not None) ) else None)
   self.code_used = (that.code_used)
   self.varidx_used = (that.varidx_used)
  @staticmethod
  def _ctor_():
    o = RowBlockManager.__new__(RowBlockManager)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   self.blocks = mosek_fusion_LinkedBlocks._ctor_()
   self.row_param_ptrb = None
   self.row_param_ptre = None
   self.row_code_ptr = None
   self.first_free_entry = 0
   self.param_varidx = None
   self.param_code_sizes = None
   self.first_free_codeitem = 0
   self.code = None
   self.cconst = None
   self.code_used = 0
   self.varidx_used = 0
  @staticmethod
  def _match_num_1parameterized_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_num_1parameterized_(*args):
    if len(args) != 0: return False
    return True
  def _num_1parameterized_alt_(self,):
    return self._num_1parameterized_()
  def _num_1parameterized_(self,):
   return numpy.int32(self.varidx_used)
  @staticmethod
  def _match_is_1parameterized_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_is_1parameterized_(*args):
    if len(args) != 0: return False
    return True
  def _is_1parameterized_alt_(self,):
    return self._is_1parameterized_()
  def _is_1parameterized_(self,):
   return ((self.code_used > 0))
  @staticmethod
  def _match_blocksize_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_blocksize_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _blocksize_alt_I(self,_t__0):
    return self._blocksize_I(numpy.int32(__0))
  def _blocksize_I(self,_0):
   return numpy.int32(self.blocks._blocksize_I(_0))
  @staticmethod
  def _match_block_1capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_block_1capacity_(*args):
    if len(args) != 0: return False
    return True
  def _block_1capacity_alt_(self,):
    return self._block_1capacity_()
  def _block_1capacity_(self,):
   return numpy.int32(self.blocks._block_1capacity_())
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(self.blocks._capacity_())
  @staticmethod
  def _match_get_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_get_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _get_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._get_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _get_I_3II(self,_0,_1,_2):
   self.blocks._get_I_3II(_0,_1,_2)
  @staticmethod
  def _match_evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match__3D__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3D__(_4))
  @staticmethod
  def _match_alt_evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3D__(_4))
  def _evaluate_alt_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self._evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _evaluate_Lmosek_4fusion_4WorkStack_2_3D_3I_3I_3D(self,_0,_1,_2,_3,_4):
   _5=_0._allocf64_I(self.code_used)
   _6=0
   _7=(_0.f64)
   _8=0
   _8,_6 = fragments._c_closure_128(self.cconst,self.code,_8,self.param_code_sizes,_1,self.param_varidx,self.row_code_ptr,self.row_param_ptrb,self.row_param_ptre,_5,_6,_2,_3,_4,_7) # src/fusion/Model.mbi:5268:8-5317:9
   _8 = numpy.int32(_8) # postprocess
   _6 = numpy.int32(_6) # postprocess
   _0._popf64_I(self.code_used)
  @staticmethod
  def _match_replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5) and __arg_match_I__(_6))
  @staticmethod
  def _match_alt_replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5) and __arg_alt_match_I__(_6))
  def _replace_1row_1code_alt_Lmosek_4fusion_4WorkStack_2_3IIIIII(self,_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.int32(_t__6)
   _1 = self._replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _replace_1row_1code_Lmosek_4fusion_4WorkStack_2_3IIIIII(self,_0,_1,_2,_3,_4,_5,_6):
   _7=int((_1).shape[0])
   _8=(_0.i32)
   _9=(_0.i64)
   _10=(_0.f64)
   _11=True
   _12=0
   _13=0
   _13,_12 = fragments._c_closure_129(_5,_4,_7,_13,_12,_2,_8) # src/fusion/Model.mbi:5168:12-5176:13
   _13 = numpy.int32(_13) # postprocess
   _12 = numpy.int32(_12) # postprocess
   self._clear_1row_1code__3I(_1)
   self.__ensure_1code_1cap_II(_13,_12)
   self.code_used += _12
   self.varidx_used += _13
   if (self.first_free_codeitem > (self.code_used * 2)): # src/fusion/Model.mbi:5185:12-45
    self.__compress_()
   self.first_free_codeitem,self.first_free_entry = fragments._c_closure_130(_5,_4,self.first_free_codeitem,self.first_free_entry,_1,_7,_2,_8,self.row_code_ptr,self.row_param_ptrb,self.row_param_ptre) # src/fusion/Model.mbi:5188:8-5211:9
   self.first_free_codeitem = numpy.int32(self.first_free_codeitem) # postprocess
   self.first_free_entry = numpy.int32(self.first_free_entry) # postprocess
   _11 = fragments._c_closure_131(self.cconst,_6,self.code,_5,_4,_1,_7,_3,_11,self.param_code_sizes,self.param_varidx,_2,_10,_8,_9,self.row_code_ptr,self.row_param_ptrb) # src/fusion/Model.mbi:5213:8-5235:9
   if (not _11): # src/fusion/Model.mbi:5249:12-18
    raise mosek_fusion_ParameterError._ctor_S("Expression contains parameterized SDP non-zero")
  @staticmethod
  def _match_clear_1row_1code__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_clear_1row_1code__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _clear_1row_1code_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._clear_1row_1code__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _clear_1row_1code__3I(self,_0):
   self.code_used,self.varidx_used = fragments._c_closure_132(self.code_used,_0,self.param_code_sizes,self.row_param_ptrb,self.row_param_ptre,self.varidx_used) # src/fusion/Model.mbi:5114:32-5129:7
   self.code_used = numpy.int32(self.code_used) # postprocess
   self.varidx_used = numpy.int32(self.varidx_used) # postprocess
  def __compress_alt_(self,):
    return self.__compress_()
  def __compress_(self,):
   _0=numpy.zeros((self.code_used,), dtype=numpy.dtype(numpy.int32))
   _1=numpy.zeros((self.code_used,), dtype=numpy.dtype(numpy.float64))
   _2=numpy.zeros((self.first_free_entry,), dtype=numpy.dtype(numpy.int64))
   _3=numpy.zeros((self.first_free_entry,), dtype=numpy.dtype(numpy.int32))
   _4=0
   _5=0
   for _6 in range(0,int((self.row_param_ptrb).shape[0])):
    _7=0
    _8=(self.row_param_ptre[_6] - self.row_param_ptrb[_6])
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.param_varidx,self.row_param_ptrb[_6],_2,_4,_8)
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.param_code_sizes,self.row_param_ptrb[_6],_3,_4,_8)
    _7 = fragments._c_closure_133(_7,_6,self.param_code_sizes,self.row_param_ptrb,self.row_param_ptre) # src/fusion/Model.mbi:5086:10-93
    _7 = numpy.int32(_7) # postprocess
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.code,self.row_code_ptr[_6],_0,_5,_7)
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.cconst,self.row_code_ptr[_6],_1,_5,_7)
    self.row_param_ptrb[_6] = _4
    self.row_param_ptre[_6] = (_4 + _8)
    self.row_code_ptr[_6] = _5
    _5 += _7
    _4 += _8
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_2,0,self.param_varidx,0,_4)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_3,0,self.param_code_sizes,0,_4)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_0,0,self.code,0,_5)
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_1,0,self.cconst,0,_5)
   self.first_free_codeitem = _5
   self.first_free_entry = _4
  def __ensure_1code_1cap_alt_II(self,_t__0,_t__1):
    return self.__ensure_1code_1cap_II(numpy.int32(__0),numpy.int32(__1))
  def __ensure_1code_1cap_II(self,_0,_1):
   if (self.row_code_ptr is None): # src/fusion/Model.mbi:5034:12-32
    _2=1024
    _2 = fragments._c_closure_134(_2,_0) # src/fusion/Model.mbi:5035:24-52
    _2 = numpy.int32(_2) # postprocess
    _3=1024
    _3 = fragments._c_closure_135(_1,_3) # src/fusion/Model.mbi:5036:24-52
    _3 = numpy.int32(_3) # postprocess
    self.row_param_ptrb = numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    self.row_param_ptre = numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    self.row_code_ptr = numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    self.param_varidx = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    self.param_code_sizes = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    self.code = numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    self.cconst = numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   else:
    if (_0 > (int((self.param_varidx).shape[0]) - self.first_free_entry)): # src/fusion/Model.mbi:5048:14-59
     _4=int((self.param_varidx).shape[0])
     _4 = fragments._c_closure_136(self.first_free_entry,_4,_0) # src/fusion/Model.mbi:5049:39-84
     _4 = numpy.int32(_4) # postprocess
     _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
     _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
     _7=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
     mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.param_varidx,0,_6,0,self.first_free_entry)
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.param_code_sizes,0,_7,0,self.first_free_entry)
     self.param_varidx = _6
     self.param_code_sizes = _7
    if (_1 > (int((self.code).shape[0]) - self.first_free_codeitem)): # src/fusion/Model.mbi:5059:14-56
     _8=int((self.code).shape[0])
     _8 = fragments._c_closure_137(_1,self.first_free_codeitem,_8) # src/fusion/Model.mbi:5060:31-81
     _8 = numpy.int32(_8) # postprocess
     _9=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
     mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.code,0,_9,0,self.first_free_codeitem)
     _10=numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
     mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.cconst,0,_10,0,self.first_free_codeitem)
     self.code = _9
     self.cconst = _10
  @staticmethod
  def _match_release_I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_release_I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1))
  def _release_alt_I_3I(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._release_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _release_I_3I(self,_0,_1):
   _2=self.blocks._blocksize_I(_0)
   self.blocks._get_I_3II(_0,_1,0)
   self.blocks._free_I(_0)
   self.code_used = fragments._c_closure_138(self.code_used,_1,_2,self.row_code_ptr,self.row_param_ptrb,self.row_param_ptre) # src/fusion/Model.mbi:5024:8-5030:11
   self.code_used = numpy.int32(self.code_used) # postprocess
  @staticmethod
  def _match_allocate__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_allocate__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _allocate_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._allocate__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _allocate__3I(self,_0):
   _1=int((_0).shape[0])
   _2=self.blocks._alloc_I(_1)
   self.blocks._get_I_3II(_2,_0,0)
   if ((self.row_code_ptr is not None) and (self.blocks._capacity_() > int((self.row_param_ptrb).shape[0]))): # src/fusion/Model.mbi:5007:12-5008:51
    _3=numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.row_param_ptrb,0,_3,0,int((self.row_param_ptrb).shape[0]))
    _4=numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.row_param_ptre,0,_4,0,int((self.row_param_ptre).shape[0]))
    _5=numpy.zeros((self.blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.row_code_ptr,0,_5,0,int((self.row_code_ptr).shape[0]))
    self.row_param_ptrb = _3
    self.row_param_ptre = _4
    self.row_code_ptr = _5
   return numpy.int32(_2)
  @staticmethod
  def _match_row_1is_1parameterized_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_row_1is_1parameterized_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _row_1is_1parameterized_alt_I(self,_t__0):
    return self._row_1is_1parameterized_I(numpy.int32(__0))
  def _row_1is_1parameterized_I(self,_0):
   return (((self.row_param_ptrb is not None) and (self.row_param_ptrb[_0] < self.row_param_ptre[_0])))
 return RowBlockManager
mosek_fusion_RowBlockManager=__mk_mosek_fusion_RowBlockManager()
del __mk_mosek_fusion_RowBlockManager
#BEFORE CLASS
def __mk_mosek_fusion_BaseVariable():
 class BaseVariable(mosek_fusion_Variable,object):
  __slots__ = ['_BaseVariable__sparsity','_BaseVariable__basevar_nativeidxs','_BaseVariable__model','_BaseVariable__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args): # mosek.fusion.Model,[]int32,[]int64,[]int64
      self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):# mosek.fusion.Model,[]int32,[]int64,[]int64
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseVariable.ctor(mosek.fusion.Model,array(int32,ndim=1),array(int64,ndim=1),array(int64,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_BaseVariable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.transpose()')
  def makeContinuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeContinuous_(*args): # 
      return self._makeContinuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeContinuous_(*args): # 
      return self._makeContinuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeContinuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeContinuous()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getModel()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_BaseVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.toString()')
  def setLevel(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_setLevel__3D(*args): # []double
      return self._setLevel__3D(*args)
    elif mosek_fusion_BaseVariable._match_alt_setLevel__3D(*args): # []double
      return self._setLevel_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list setLevel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.setLevel(array(double,ndim=1))')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_reshape_I(*args): # int32
      return self._reshape_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_I(*args): # int32
      return self._reshape_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_reshape_II(*args): # int32,int32
      return self._reshape_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_II(*args): # int32,int32
      return self._reshape_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_reshape_III(*args): # int32,int32,int32
      return self._reshape_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_reshape_III(*args): # int32,int32,int32
      return self._reshape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.reshape(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.reshape(int32)\n\tmosek.fusion.BaseVariable.reshape(int32,int32)\n\tmosek.fusion.BaseVariable.reshape(int32,int32,int32)')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getND()')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getDim(int32)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_BaseVariable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_BaseVariable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.BaseVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_integer()')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_BaseVariable._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.remove()')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.set_values(array(double,ndim=1),bool)')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getSize()')
  def makeInteger(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_makeInteger_(*args): # 
      return self._makeInteger_(*args)
    elif mosek_fusion_BaseVariable._match_alt_makeInteger_(*args): # 
      return self._makeInteger_alt_(*args)
    else:
      raise ValueError('Invalid argument list makeInteger('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.makeInteger()')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_BaseVariable._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.level()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_BaseVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.index(int32)\n\tmosek.fusion.BaseVariable.index(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.index(int32,int32)\n\tmosek.fusion.BaseVariable.index(int32,int32,int32)')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_BaseVariable._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.asExpr()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BaseVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.dual()')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_BaseVariable._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.getShape()')
  def fromTril(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_fromTril_I(*args): # int32
      return self._fromTril_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_fromTril_I(*args): # int32
      return self._fromTril_alt_I(*args)
    elif mosek_fusion_BaseVariable._match_fromTril_II(*args): # int32,int32
      return self._fromTril_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_fromTril_II(*args): # int32,int32
      return self._fromTril_alt_II(*args)
    else:
      raise ValueError('Invalid argument list fromTril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.fromTril(int32)\n\tmosek.fusion.BaseVariable.fromTril(int32,int32)')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BaseVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.diag()\n\tmosek.fusion.BaseVariable.diag(int32)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_BaseVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.make_continuous()')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_BaseVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.values(int32,array(double,ndim=1),bool)')
  def tril(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_tril_(*args): # 
      return self._tril_(*args)
    elif mosek_fusion_BaseVariable._match_alt_tril_(*args): # 
      return self._tril_alt_(*args)
    elif mosek_fusion_BaseVariable._match_tril_II(*args): # int32,int32
      return self._tril_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_tril_II(*args): # int32,int32
      return self._tril_alt_II(*args)
    else:
      raise ValueError('Invalid argument list tril('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.tril()\n\tmosek.fusion.BaseVariable.tril(int32,int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.slice(int32,int32)\n\tmosek.fusion.BaseVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_BaseVariable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.numInst()')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BaseVariable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_BaseVariable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.antidiag()\n\tmosek.fusion.BaseVariable.antidiag(int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_BaseVariable._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_BaseVariable._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseVariable.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.BaseVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   self.__model = m
   self.__shape = (v.__shape)
   self.__sparsity = (v.__sparsity)
   self.__basevar_nativeidxs = (v.__basevar_nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,basevar_nativeidxs):
    o = BaseVariable.__new__(BaseVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,basevar_nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,basevar_nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(basevar_nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,basevar_nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(basevar_nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,basevar_nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(basevar_nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,basevar_nativeidxs):
   self.__model = m
   (self.__shape) = shape
   (self.__sparsity) = sparsity
   (self.__basevar_nativeidxs) = basevar_nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Variable((")
   if (int((self.__shape).shape[0]) > 0): # src/fusion/BaseVariable.monty:962:12-26
    _0._a_I(self.__shape[0])
    for _1 in range(1,int((self.__shape).shape[0])):
     _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S("))")
   return (_0._toString_())
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__basevar_nativeidxs).shape[0])
   _4=_3
   _5=int((self.__shape).shape[0])
   _6=(self.__sparsity is not None)
   _0._alloc_1expr_IIIZ(_5,_4,_3,_6)
   _7=(_0.ptr_base)
   _8=(_0.nidxs_base)
   _9=(_0.sp_base)
   _10=(_0.cof_base)
   _11=(_0.shape_base)
   _12=(_0.i32)
   _13=(_0.i64)
   _14=(_0.f64)
   fragments._c_closure_139(_5,_12,self.__shape,_11) # src/fusion/BaseVariable.monty:944:8-945:40
   fragments._c_closure_140(self.__basevar_nativeidxs,_10,_6,_8,_3,_7,_14,_12,_13,_9,self.__sparsity) # src/fusion/BaseVariable.monty:947:8-953:9
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   raise mosek_fusion_DeletionError._ctor_S("Only original variables can be removed")
  @staticmethod
  def _match_fromTril_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_fromTril_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _fromTril_alt_II(self,_t__0,_t__1):
    return self._fromTril_II(numpy.int32(__0),numpy.int32(__1))
  def _fromTril_II(self,_0,_1):
   if ((_0 < 0) or (_0 >= int((self.__shape).shape[0]))): # src/fusion/BaseVariable.monty:845:16-46
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension")
   elif (self.__shape[_0]!=((_1 * (_1 + 1)) // 2)): # src/fusion/BaseVariable.monty:846:16-40
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   _2=1
   _2 = fragments._c_closure_141(_2,_0,self.__shape) # src/fusion/BaseVariable.monty:848:20-57
   _2 = numpy.int32(_2) # postprocess
   _3=self.__shape[_0]
   _4=1
   _4 = fragments._c_closure_142(_4,_0,self.__shape) # src/fusion/BaseVariable.monty:850:20-68
   _4 = numpy.int32(_4) # postprocess
   _5=numpy.zeros(((int((self.__shape).shape[0]) + 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_143(_0,_5,self.__shape) # src/fusion/BaseVariable.monty:853:8-51
   _5[_0] = _1
   _5[(_0 + 1)] = _1
   fragments._c_closure_144(_0,_5,self.__shape) # src/fusion/BaseVariable.monty:856:8-64
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:858:12-28
    _6=numpy.zeros(((((_2 * _1) * _1) * _4),), dtype=numpy.dtype(numpy.int64))
    _7=0
    _7 = fragments._c_closure_145(self.__basevar_nativeidxs,_1,_2,_3,_4,_6,_7) # src/fusion/BaseVariable.monty:861:10-870:17
    _7 = numpy.int32(_7) # postprocess
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_5,None,_6))
   else:
    _8=0
    for _9 in range(0,int((self.__sparsity).shape[0])):
     _10=((self.__sparsity[_9] // _4) % _3)
     _11=numpy.int32((((- 1) + mosek.fusion.Utils.Tools._sqrt_D(((1 + (2 * _10)) * (1 + (2 * _10))))) / 4))
     _12=(self.__sparsity[_9] - ((_11 * (_11 + 1)) // 2))
     if (_11==_12): # src/fusion/BaseVariable.monty:883:16-24
      _8 += 1
     else:
      _8 += 2
    _13=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    _15=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_146(_8,_15) # src/fusion/BaseVariable.monty:890:38-72
    _16=0
    for _17 in range(0,int((self.__sparsity).shape[0])):
     _18=(self.__sparsity[_17] // (_3 * _4))
     _19=((self.__sparsity[_17] // _4) % _3)
     _20=(self.__sparsity[_17] % _4)
     _21=numpy.int32((((- 1) + mosek.fusion.Utils.Tools._sqrt_D(((1 + (2 * _19)) * (1 + (2 * _19))))) / 4))
     _22=(self.__sparsity[_17] - ((_21 * (_21 + 1)) // 2))
     if (_21==_22): # src/fusion/BaseVariable.monty:901:16-26
      _13[_16] = self.__basevar_nativeidxs[_17]
      _14[_16] = (((((_18 * _1) * _1) * _4) + (((_21 * _1) + _22) * _4)) + _20)
      _16 += 1
     else:
      _13[_16] = self.__basevar_nativeidxs[_17]
      _13[(_16 + 1)] = self.__basevar_nativeidxs[_17]
      _14[_16] = (((((_18 * _1) * _1) * _4) + (((_21 * _1) + _22) * _4)) + _20)
      _14[(_16 + 1)] = (((((_18 * _1) * _1) * _4) + (((_22 * _1) + _21) * _4)) + _20)
      _16 += 2
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_15,_13,None,0,_8)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_5,numpy.array([_14[_15[_23]] for _23 in range(0,_8)], dtype=numpy.dtype(numpy.int64)),numpy.array([_13[_15[_24]] for _24 in range(0,_8)], dtype=numpy.dtype(numpy.int64))))
  @staticmethod
  def _match_fromTril_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_fromTril_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _fromTril_alt_I(self,_t__0):
    return self._fromTril_I(numpy.int32(__0))
  def _fromTril_I(self,_0):
   return (self._fromTril_II(0,_0))
  @staticmethod
  def _match_tril_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_tril_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _tril_alt_II(self,_t__0,_t__1):
    return self._tril_II(numpy.int32(__0),numpy.int32(__1))
  def _tril_II(self,_0,_1):
   if ((_0 < 0) or ((_0 >= _1) or (_1 >= int((self.__shape).shape[0])))): # src/fusion/BaseVariable.monty:739:17-63
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension specification")
   else:
    if (self.__shape[_0]!=self.__shape[_1]): # src/fusion/BaseVariable.monty:740:17-43
     raise mosek_fusion_DimensionError._ctor_S("Operation only valid for square variables")
   _2=numpy.zeros(((int((self.__shape).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_147(_0,_2,self.__shape) # src/fusion/BaseVariable.monty:743:8-51
   _2[_0] = ((self.__shape[_0] * (self.__shape[_0] + 1)) // 2)
   fragments._c_closure_148(_0,_1,_2,self.__shape) # src/fusion/BaseVariable.monty:745:8-56
   fragments._c_closure_149(_1,_2,self.__shape) # src/fusion/BaseVariable.monty:746:8-64
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:748:12-28
    _3=1
    _3 = fragments._c_closure_150(_3,_0,self.__shape) # src/fusion/BaseVariable.monty:749:22-59
    _3 = numpy.int32(_3) # postprocess
    _4=self.__shape[_0]
    _5=1
    _5 = fragments._c_closure_151(_5,_0,_1,self.__shape) # src/fusion/BaseVariable.monty:751:22-64
    _5 = numpy.int32(_5) # postprocess
    _6=self.__shape[_1]
    _7=1
    _7 = fragments._c_closure_152(_7,_1,self.__shape) # src/fusion/BaseVariable.monty:753:22-70
    _7 = numpy.int32(_7) # postprocess
    _8=numpy.zeros(((((((_3 * _5) * _7) * _4) * (_4 + 1)) // 2),), dtype=numpy.dtype(numpy.int64))
    _9=0
    _9 = fragments._c_closure_153(self.__basevar_nativeidxs,_3,_4,_5,_6,_7,_9,_8) # src/fusion/BaseVariable.monty:757:10-764:19
    _9 = numpy.int32(_9) # postprocess
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_2,None,_8))
   else:
    _10=1
    _10 = fragments._c_closure_154(_10,_0,self.__shape) # src/fusion/BaseVariable.monty:769:22-59
    _10 = numpy.int32(_10) # postprocess
    _11=self.__shape[_0]
    _12=1
    _12 = fragments._c_closure_155(_12,_0,_1,self.__shape) # src/fusion/BaseVariable.monty:771:22-64
    _12 = numpy.int32(_12) # postprocess
    _13=self.__shape[_1]
    _14=1
    _14 = fragments._c_closure_156(_14,_1,self.__shape) # src/fusion/BaseVariable.monty:773:22-70
    _14 = numpy.int32(_14) # postprocess
    _15=1
    _16=_14
    _17=(_16 * _13)
    _18=(_17 * _12)
    _19=(_18 * _11)
    _20=0
    _20 = fragments._c_closure_157(_11,_13,_20,_18,_16,self.__sparsity) # src/fusion/BaseVariable.monty:783:10-784:63
    _20 = numpy.int32(_20) # postprocess
    _21=1
    _22=_14
    _23=(_22 * _12)
    _24=(((_23 * _11) * (_11 + 1)) // 2)
    _25=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _26=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _27=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _28=0
    _28 = fragments._c_closure_158(self.__basevar_nativeidxs,_11,_12,_13,_14,_28,_20,_25,_26,_24,_23,_22,_21,_27,_19,_18,_17,_16,_15,self.__sparsity) # src/fusion/BaseVariable.monty:796:10-814:11
    _28 = numpy.int32(_28) # postprocess
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_25,_26,None,0,_20)
    _29=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    _30=numpy.zeros((_20,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_159(_20,_29,_25,_26) # src/fusion/BaseVariable.monty:820:10-63
    fragments._c_closure_160(_20,_25,_27,_30) # src/fusion/BaseVariable.monty:821:10-60
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_2,_30,_29))
  @staticmethod
  def _match_tril_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_tril_(*args):
    if len(args) != 0: return False
    return True
  def _tril_alt_(self,):
    return self._tril_()
  def _tril_(self,):
   return (self._tril_II(0,1))
  @staticmethod
  def _match_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _reshape_alt_III(self,_t__0,_t__1,_t__2):
    return self._reshape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _reshape_III(self,_0,_1,_2):
   return (self._reshape__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _reshape_alt_II(self,_t__0,_t__1):
    return self._reshape_II(numpy.int32(__0),numpy.int32(__1))
  def _reshape_II(self,_0,_1):
   return (self._reshape__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_reshape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _reshape_alt_I(self,_t__0):
    return self._reshape_I(numpy.int32(__0))
  def _reshape_I(self,_0):
   return (self._reshape__3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   _1=1
   for _2 in range(0,int((_0).shape[0])):
    if (_0[_2] < 0): # src/fusion/BaseVariable.monty:722:14-26
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape")
    _1 *= _0[_2]
   if (_1!=self._getSize_()): # src/fusion/BaseVariable.monty:726:12-34
    raise mosek_fusion_LengthError._ctor_S("Shape size does not match variable size")
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_0[_3] for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)),self.__sparsity,self.__basevar_nativeidxs))
  @staticmethod
  def _match_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setLevel__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setLevel_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setLevel__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setLevel__3D(self,_0):
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:707:12-28
    if (int((_0).shape[0])!=int((self.__basevar_nativeidxs).shape[0])): # src/fusion/BaseVariable.monty:708:14-47
     raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
    self.__model._setVariableValues_Z_3J_3D(True,self.__basevar_nativeidxs,_0)
   else:
    if (int((_0).shape[0])!=self._getSize_()): # src/fusion/BaseVariable.monty:712:14-33
     raise mosek_fusion_LengthError._ctor_S("Invalid length of solution values vector")
    _1=numpy.array([_0[self.__sparsity[_2]] for _2 in range(0,int((self.__basevar_nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.float64))
    self.__model._setVariableValues_Z_3J_3D(True,self.__basevar_nativeidxs,_1)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   return numpy.int32(self.__shape[_0])
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   _0=1
   _0 = fragments._c_closure_161(self.__shape,_0) # src/fusion/BaseVariable.monty:699:51-94
   _0 = numpy.int64(_0) # postprocess
   return numpy.int64(_0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((int((self.__basevar_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__model._getVariableValues_Z_3J_3DI(False,self.__basevar_nativeidxs,_0,0)
   if (self.__sparsity is not None): # src/fusion/BaseVariable.monty:690:12-28
    _1=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_162(self.__basevar_nativeidxs,_0,self.__sparsity,_1) # src/fusion/BaseVariable.monty:692:10-84
    _0 = _1
   return (_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros((int((self.__basevar_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__model._getVariableValues_Z_3J_3DI(True,self.__basevar_nativeidxs,_0,0)
   if (self.__sparsity is not None): # src/fusion/BaseVariable.monty:678:12-28
    _1=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_163(self.__basevar_nativeidxs,_0,self.__sparsity,_1) # src/fusion/BaseVariable.monty:680:10-84
    _0 = _1
   return (_0)
  @staticmethod
  def _match_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeContinuous_(*args):
    if len(args) != 0: return False
    return True
  def _makeContinuous_alt_(self,):
    return self._makeContinuous_()
  def _makeContinuous_(self,):
   self._make_1continuous_()
  @staticmethod
  def _match_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_makeInteger_(*args):
    if len(args) != 0: return False
    return True
  def _makeInteger_alt_(self,):
    return self._makeInteger_()
  def _makeInteger_(self,):
   self._make_1integer_()
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   if (int((self.__shape).shape[0])==1): # src/fusion/BaseVariable.monty:632:12-27
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([1,self.__shape[0]], dtype=numpy.dtype(numpy.int32)),self.__sparsity,self.__basevar_nativeidxs))
   elif (int((self.__shape).shape[0]) > 2): # src/fusion/BaseVariable.monty:635:16-30
    raise mosek_fusion_DimensionError._ctor_S("Invalid shape for operation")
   else:
    _0=numpy.zeros((int((self.__basevar_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.int64))
    _1=(None if ((self.__sparsity is None) ) else numpy.zeros((int((self.__basevar_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.int64)))
    fragments._c_closure_164(self.__basevar_nativeidxs,_0,self.__shape,_1,self.__sparsity) # src/fusion/BaseVariable.monty:640:10-661:11
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([self.__shape[1],self.__shape[0]], dtype=numpy.dtype(numpy.int32)),_1,_0))
  @staticmethod
  def _match_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_index_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _index_alt_III(self,_t__0,_t__1,_t__2):
    return self._index_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _index_III(self,_0,_1,_2):
   return (self._index__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_index_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _index_alt_II(self,_t__0,_t__1):
    return self._index_II(numpy.int32(__0),numpy.int32(__1))
  def _index_II(self,_0,_1):
   return (self._index__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   _1=numpy.zeros((1,int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_165(_0,_1) # src/fusion/BaseVariable.monty:609:8-57
   return (self._pick__3_5I(_1)._reshape__3I(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (self._pick__3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32)))._reshape__3I(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   if (int((self.__shape).shape[0])!=3): # src/fusion/BaseVariable.monty:584:12-27
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((_2).shape[0]))): # src/fusion/BaseVariable.monty:586:12-52
    raise mosek_fusion_LengthError._ctor_S("Mismatching argument lengths")
   _3=numpy.zeros((int((_0).shape[0]),3,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_166(_0,_1,_2,_3) # src/fusion/BaseVariable.monty:590:8-594:9
   return (self._pick__3_5I(_3))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   if ((int((self.__shape).shape[0])!=2) or (int((_0).shape[0])!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:567:12-49
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _2=numpy.zeros((int((_0).shape[0]),2,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_167(_0,_1,_2) # src/fusion/BaseVariable.monty:571:8-574:9
   return (self._pick__3_5I(_2))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   if (int((self.__shape).shape[0])!=int((_0).shape[1])): # src/fusion/BaseVariable.monty:504:12-38
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _1=False
   _1 = fragments._c_closure_168(_1,_0,self.__shape) # src/fusion/BaseVariable.monty:508:8-511:34
   if _1: # src/fusion/BaseVariable.monty:512:12-24
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _2=int((self.__shape).shape[0])
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _3[(_2 - 1)] = 1
   fragments._c_closure_169(_2,self.__shape,_3) # src/fusion/BaseVariable.monty:518:8-74
   _4=numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))
   _6=None
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:524:12-28
    _5 = numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_170(self.__basevar_nativeidxs,_5,_0,_2,_3) # src/fusion/BaseVariable.monty:526:10-532:11
   else:
    _7=0
    for _8 in range(0,int((_0).shape[0])):
     _9=0
     _9 = fragments._c_closure_171(_8,_9,_0,_2,_3) # src/fusion/BaseVariable.monty:537:12-60
     _9 = numpy.int64(_9) # postprocess
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_9) >= 0): # src/fusion/BaseVariable.monty:538:16-59
      _7 += 1
    _5 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _6 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _10=0
    for _11 in range(0,int((_0).shape[0])):
     _12=0
     _12 = fragments._c_closure_172(_11,_12,_0,_2,_3) # src/fusion/BaseVariable.monty:547:14-62
     _12 = numpy.int64(_12) # postprocess
     _13=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_12)
     if (_13 >= 0): # src/fusion/BaseVariable.monty:549:18-27
      _5[_10] = self.__basevar_nativeidxs[_13]
      _6[_10] = _11
      _10 += 1
    if (_7==int((_0).shape[0])): # src/fusion/BaseVariable.monty:556:14-33
     _6 = None
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_4,_6,_5))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   if (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:462:12-27
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _1=False
   _1 = fragments._c_closure_173(_0,_1,self.__shape) # src/fusion/BaseVariable.monty:466:8-468:32
   if _1: # src/fusion/BaseVariable.monty:469:12-24
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _3=None
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:474:12-28
    _2 = numpy.array([self.__basevar_nativeidxs[_0[_4]] for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64))
   else:
    _5=0
    for _6 in range(0,int((_0).shape[0])):
     if (mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_0[_6]) >= 0): # src/fusion/BaseVariable.monty:480:16-64
      _5 += 1
    _2 = numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _3 = numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
    _7=0
    for _8 in range(0,int((_0).shape[0])):
     _9=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_0[_8])
     if (_9 >= 0): # src/fusion/BaseVariable.monty:489:16-22
      _3[_7] = _8
      _2[_7] = self.__basevar_nativeidxs[_9]
      _7 += 1
    if (_5==int((_0).shape[0])): # src/fusion/BaseVariable.monty:495:14-30
     _3 = None
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)),_3,_2))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:448:12-27
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   elif ((_0 >= self.__shape[1]) or ((- _0) >= self.__shape[2])): # src/fusion/BaseVariable.monty:450:16-55
    raise mosek_fusion_IndexError._ctor_S("Diagonal index out of bounds")
   if (_0 >= 0): # src/fusion/BaseVariable.monty:453:12-22
    return (self.__general_1diag__3I_3II(numpy.array([0,((self.__shape[1] - 1) - _0)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < (self.__shape[1] - _0)) ) else (self.__shape[1] - _0))))
   else:
    return (self.__general_1diag__3I_3II(numpy.array([(- _0),(self.__shape[1] - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[1] if ((self.__shape[1] < (self.__shape[0] + _0)) ) else (self.__shape[0] + _0))))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:440:12-27
    raise mosek_fusion_DimensionError._ctor_S("antidiag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3II(numpy.array([0,(self.__shape[1] - 1)], dtype=numpy.dtype(numpy.int32)),numpy.array([1,(- 1)], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < self.__shape[1]) ) else self.__shape[1])))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:427:12-27
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   elif ((_0 >= self.__shape[1]) or ((- _0) >= self.__shape[2])): # src/fusion/BaseVariable.monty:429:16-55
    raise mosek_fusion_IndexError._ctor_S("Diagonal index out of bounds")
   if (_0 >= 0): # src/fusion/BaseVariable.monty:432:12-22
    return (self.__general_1diag__3I_3II(numpy.array([0,_0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < (self.__shape[1] - _0)) ) else (self.__shape[1] - _0))))
   else:
    return (self.__general_1diag__3I_3II(numpy.array([(- _0),0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[1] if ((self.__shape[1] < (self.__shape[0] + _0)) ) else (self.__shape[0] + _0))))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   if (int((self.__shape).shape[0])!=2): # src/fusion/BaseVariable.monty:420:12-27
    raise mosek_fusion_DimensionError._ctor_S("diag() only works on two-dimensional objects")
   return (self.__general_1diag__3I_3II(numpy.array([0,0], dtype=numpy.dtype(numpy.int32)),numpy.array([1,1], dtype=numpy.dtype(numpy.int32)),(self.__shape[0] if ((self.__shape[0] < self.__shape[1]) ) else self.__shape[1])))
  def __general_1diag_alt__3I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self.__general_1diag__3I_3II(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __general_1diag__3I_3II(self,_0,_1,_2):
   _3=int((self.__shape).shape[0])
   if ((_3!=int((_0).shape[0])) or (_3!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:371:13-372:28
    raise mosek_fusion_DimensionError._ctor_S("Invalid start or step definition")
   for _4 in range(0,_3):
    if ((_0[_4] < 0) or (_0[_4] >= self.__shape[_4])): # src/fusion/BaseVariable.monty:375:15-57
     raise mosek_fusion_LengthError._ctor_S("Start element is out of bounds")
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _5[(_3 - 1)] = 1
   fragments._c_closure_174(_3,self.__shape,_5) # src/fusion/BaseVariable.monty:379:27-93
   _6=0
   _6 = fragments._c_closure_175(_0,_6,_1,_5) # src/fusion/BaseVariable.monty:381:29-95
   _6 = numpy.int64(_6) # postprocess
   _7=0
   _7 = fragments._c_closure_176(_1,_7,_5) # src/fusion/BaseVariable.monty:382:29-91
   _7 = numpy.int64(_7) # postprocess
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:384:12-28
    _8=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_177(self.__basevar_nativeidxs,_2,_8,_6,_7) # src/fusion/BaseVariable.monty:386:10-387:67
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),None,_8))
   else:
    _9=0
    for _10 in range(0,_2):
     _11=(_6 + (_7 * _10))
     _12=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_11)
     if (_12 >= 0): # src/fusion/BaseVariable.monty:395:16-26
      _9 += 1
    _13=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_9,), dtype=numpy.dtype(numpy.int64))
    _15=0
    for _16 in range(0,_2):
     _13[_16] = self.__basevar_nativeidxs[(_6 + (_7 * _16))]
     _17=(_6 + (_7 * _16))
     _18=mosek.fusion.CommonTools._binarySearch__3JJ(self.__sparsity,_17)
     if (_18 >= 0): # src/fusion/BaseVariable.monty:405:16-26
      _14[_15] = _16
      _13[_15] = self.__basevar_nativeidxs[_18]
      _15 += 1
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),_14,_13))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/BaseVariable.monty:263:12-35
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   elif (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/BaseVariable.monty:265:16-40
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   else:
    for _2 in range(0,int((self.__shape).shape[0])):
     if ((_0[_2] < 0) or (_1[_2] > self.__shape[_2])): # src/fusion/BaseVariable.monty:269:16-50
      raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
     elif (_0[_2] > _1[_2]): # src/fusion/BaseVariable.monty:271:20-38
      raise mosek_fusion_SliceError._ctor_S("Invalid slice")
    _3=int((self.__shape).shape[0])
    _4=numpy.array([(_1[_5] - _0[_5]) for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _6=1
    _6 = fragments._c_closure_178(_0,_1,_3,_6) # src/fusion/BaseVariable.monty:277:29-79
    _6 = numpy.int32(_6) # postprocess
    if (_6==0): # src/fusion/BaseVariable.monty:278:14-28
     return (mosek_fusion_NilVariable._ctor_())
    elif (self.__sparsity is not None): # src/fusion/BaseVariable.monty:280:18-34
     _7=0
     _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
     _7 = fragments._c_closure_179(_0,_8,_1,_3,_7,self.__shape,self.__sparsity) # src/fusion/BaseVariable.monty:284:12-295:13
     _7 = numpy.int32(_7) # postprocess
     _9=0
     _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _11=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _9 = fragments._c_closure_180(self.__basevar_nativeidxs,_0,_9,_10,_8,_1,_3,self.__shape,_4,_11,self.__sparsity) # src/fusion/BaseVariable.monty:300:12-320:13
     _9 = numpy.int32(_9) # postprocess
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_4,_11,_10))
    else:
     _12=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
     fragments._c_closure_181(self.__basevar_nativeidxs,_0,_1,_3,self.__shape,_12,_6) # src/fusion/BaseVariable.monty:326:12-353:13
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),_4,None,_12))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:230:12-27
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   if ((_0==0) and (_1==self.__shape[0])): # src/fusion/BaseVariable.monty:232:12-43
    return (self)
   elif ((_0 < 0) or (_1 > self.__shape[0])): # src/fusion/BaseVariable.monty:234:16-44
    raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   elif (_0 > _1): # src/fusion/BaseVariable.monty:236:16-28
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   elif (_0==_1): # src/fusion/BaseVariable.monty:238:16-29
    return (mosek_fusion_NilVariable._ctor_())
   elif (self.__sparsity is not None): # src/fusion/BaseVariable.monty:240:16-32
    _2=(_1 - _0)
    _3=0
    _4=mosek.fusion.CommonTools._binarySearchL__3JJ(self.__sparsity,_0)
    _5=mosek.fusion.CommonTools._binarySearchL__3JJ(self.__sparsity,_1)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_2], dtype=numpy.dtype(numpy.int32)),numpy.array([(self.__sparsity[_6] - _0) for _6 in range(_4,_5)], dtype=numpy.dtype(numpy.int64)),numpy.array([self.__basevar_nativeidxs[_7] for _7 in range(_4,_5)], dtype=numpy.dtype(numpy.int64))))
   else:
    _8=(_1 - _0)
    _9=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.__basevar_nativeidxs,_0,_9,0,_8)
    return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(self._getModel_(),numpy.array([_8], dtype=numpy.dtype(numpy.int32)),None,_9))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_ExprFromVar._ctor_Lmosek_4fusion_4Variable_2(self))
  @staticmethod
  def _match_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2) and __arg_match__3J__(_3))
  @staticmethod
  def _match_alt_inst_I_3JI_3J(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match__3J__(_3))
  def _inst_alt_I_3JI_3J(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3JI_3J(_0,_1,_2,_3)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3JI_3J(self,_0,_1,_2,_3):
   _4=(self.__basevar_nativeidxs)
   _5=(self.__sparsity)
   if (_5 is None): # src/fusion/BaseVariable.monty:194:12-26
    fragments._c_closure_182(_3,_2,_1,_0,_4) # src/fusion/BaseVariable.monty:194:28-199:9
   else:
    for _6 in range(0,int(((self.__sparsity)).shape[0])):
     _1[(_0 + _6)] = _5[_6]
     _3[(_6 + _2)] = _4[_6]
   return numpy.int32(int(((self.__basevar_nativeidxs)).shape[0]))
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   return numpy.int32(int((self.__basevar_nativeidxs).shape[0]))
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:169:17-33
    fragments._c_closure_183(self.__basevar_nativeidxs,_1,_0) # src/fusion/BaseVariable.monty:170:10-171:53
   else:
    _2=self._getShape_()
    _3=1
    _3 = fragments._c_closure_184(_3,_2) # src/fusion/BaseVariable.monty:174:27-75
    _3 = numpy.int32(_3) # postprocess
    fragments._c_closure_185(_3,_1,_0) # src/fusion/BaseVariable.monty:175:10-56
    fragments._c_closure_186(self.__basevar_nativeidxs,_1,_0,self.__sparsity) # src/fusion/BaseVariable.monty:176:10-177:63
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:151:12-28
    self._getModel_()._setVariableValues_Z_3J_3D(_1,self.__basevar_nativeidxs,_0)
   else:
    _2=1
    _2 = fragments._c_closure_187(self.__shape,_2) # src/fusion/BaseVariable.monty:155:27-75
    _2 = numpy.int32(_2) # postprocess
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_188(self.__basevar_nativeidxs,_3,self.__sparsity) # src/fusion/BaseVariable.monty:158:10-159:54
    self._getModel_()._setVariableValues_Z_3J_3D(_1,_3,_0)
  def _dual_1lu_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._dual_1lu_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1lu_I_3DZ(self,_0,_1,_2):
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:136:12-28
    self.__model._getVariableDuals_Z_3J_3DI(_2,self.__basevar_nativeidxs,_1,_0)
   else:
    _3=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_189(self.__basevar_nativeidxs,_3,self.__sparsity) # src/fusion/BaseVariable.monty:140:10-141:54
    self.__model._getVariableDuals_Z_3J_3DI(_2,_3,_1,_0)
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   if (self.__sparsity is None): # src/fusion/BaseVariable.monty:121:12-28
    self.__model._getVariableValues_Z_3J_3DI(_2,self.__basevar_nativeidxs,_1,_0)
   else:
    _3=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_190(self.__basevar_nativeidxs,_3,self.__sparsity) # src/fusion/BaseVariable.monty:125:10-126:54
    self.__model._getVariableValues_Z_3J_3DI(_2,_3,_1,_0)
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   self._getModel_()._make_1continuous__3J(self.__basevar_nativeidxs)
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   self._getModel_()._make_1integer__3J(self.__basevar_nativeidxs)
 return BaseVariable
mosek_fusion_BaseVariable=__mk_mosek_fusion_BaseVariable()
del __mk_mosek_fusion_BaseVariable
#BEFORE CLASS
def __mk_mosek_fusion_SliceVariable():
 class SliceVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_SliceVariable__shape','_SliceVariable__sparsity','_SliceVariable__nativeidxs']
  def __repr__(self): return 'mosek.fusion.SliceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(*args):
    if len(args) != 4: return False
    m,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs)
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__shape) = shape
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceVariable_2(v):
    o = SliceVariable.__new__(SliceVariable)
    o._ctor_init_Lmosek_4fusion_4SliceVariable_2(v)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceVariable_2(*args):
    if len(args) != 1: return False
    v, = args
    return (__arg_match_Lmosek_4fusion_4SliceVariable_2__(v))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceVariable_2(*args):
    if len(args) != 1: return False
    v, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v))
  def _ctor_alt_init_Lmosek_4fusion_4SliceVariable_2(self,v):
    self._ctor_init_Lmosek_4fusion_4SliceVariable_2(v)
  def _ctor_init_Lmosek_4fusion_4SliceVariable_2(self,v):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,v._getModel_())
   (self.__nativeidxs) = (v.__nativeidxs)
   (self.__sparsity) = (v.__sparsity)
   (self.__shape) = (v.__shape)
 return SliceVariable
mosek_fusion_SliceVariable=__mk_mosek_fusion_SliceVariable()
del __mk_mosek_fusion_SliceVariable
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceVariable():
 class BoundInterfaceVariable(mosek_fusion_SliceVariable):
  __slots__ = ['_BoundInterfaceVariable__islower']
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I_3I(*args): # []int32,[]int32
      return self._pick__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I_3I(*args): # []int32,[]int32
      return self._pick_alt__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick__3I_3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_pick__3I_3I_3I(*args): # []int32,[]int32,[]int32
      return self._pick_alt__3I_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=2))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.BoundInterfaceVariable.pick(array(int32,ndim=1),array(int32,ndim=1),array(int32,ndim=1))')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.transpose()')
  def antidiag(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_antidiag_(*args): # 
      return self._antidiag_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_antidiag_(*args): # 
      return self._antidiag_alt_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_antidiag_I(*args): # int32
      return self._antidiag_I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_antidiag_I(*args): # int32
      return self._antidiag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.antidiag()\n\tmosek.fusion.BoundInterfaceVariable.antidiag(int32)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.slice(int32,int32)\n\tmosek.fusion.BoundInterfaceVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.dual()')
  def diag(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceVariable._match_diag_(*args): # 
      return self._diag_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_diag_(*args): # 
      return self._diag_alt_(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_diag_I(*args): # int32
      return self._diag_I(*args)
    elif mosek_fusion_BoundInterfaceVariable._match_alt_diag_I(*args): # int32
      return self._diag_alt_I(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceVariable.diag()\n\tmosek.fusion.BoundInterfaceVariable.diag(int32)')
  def __repr__(self): return 'mosek.fusion.BoundInterfaceVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,shape,sparsity,nativeidxs,islower):
    o = BoundInterfaceVariable.__new__(BoundInterfaceVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,shape,sparsity,nativeidxs,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(*args):
    if len(args) != 5: return False
    m,shape,sparsity,nativeidxs,islower, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3J__(nativeidxs) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(*args):
    if len(args) != 5: return False
    m,shape,sparsity,nativeidxs,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(nativeidxs) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self,m,shape,sparsity,nativeidxs,islower):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)),islower)
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self,m,shape,sparsity,nativeidxs,islower):
   mosek_fusion_SliceVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,m,shape,sparsity,nativeidxs)
   (self.__islower) = islower
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceVariable_2Z(v,islower):
    o = BoundInterfaceVariable.__new__(BoundInterfaceVariable)
    o._ctor_init_Lmosek_4fusion_4SliceVariable_2Z(v,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceVariable_2Z(*args):
    if len(args) != 2: return False
    v,islower, = args
    return (__arg_match_Lmosek_4fusion_4SliceVariable_2__(v) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceVariable_2Z(*args):
    if len(args) != 2: return False
    v,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4SliceVariable_2Z(self,v,islower):
    self._ctor_init_Lmosek_4fusion_4SliceVariable_2Z(v,islower)
  def _ctor_init_Lmosek_4fusion_4SliceVariable_2Z(self,v,islower):
   mosek_fusion_SliceVariable._ctor_init_Lmosek_4fusion_4SliceVariable_2(self,v)
   (self.__islower) = islower
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
   self._dual_1lu_I_3DZ(0,_0,self.__islower)
   return (_0)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._transpose_(self)))
  @staticmethod
  def _match_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_pick__3I_3I_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3I__(_2))
  def _pick_alt__3I_3I_3I(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I_3I(self,_0,_1,_2):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I_3I_3I(self,_0,_1,_2)))
  @staticmethod
  def _match_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_pick__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _pick_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I_3I(self,_0,_1):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I_3I(self,_0,_1)))
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3_5I(self,_0)))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._pick__3I(self,_0)))
  @staticmethod
  def _match_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_antidiag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _antidiag_alt_I(self,_t__0):
    return self._antidiag_I(numpy.int32(__0))
  def _antidiag_I(self,_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._antidiag_I(self,_0)))
  @staticmethod
  def _match_antidiag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_antidiag_(*args):
    if len(args) != 0: return False
    return True
  def _antidiag_alt_(self,):
    return self._antidiag_()
  def _antidiag_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._antidiag_(self)))
  @staticmethod
  def _match_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_diag_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _diag_alt_I(self,_t__0):
    return self._diag_I(numpy.int32(__0))
  def _diag_I(self,_0):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._diag_I(self,_0)))
  @staticmethod
  def _match_diag_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_diag_(*args):
    if len(args) != 0: return False
    return True
  def _diag_alt_(self,):
    return self._diag_()
  def _diag_(self,):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._diag_(self)))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._slice__3I_3I(self,_0,_1)))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (self.__from_1_Lmosek_4fusion_4Variable_2(mosek_fusion_BaseVariable._slice_II(self,_0,_1)))
  def __from_1_alt_Lmosek_4fusion_4Variable_2(self,_t__0):
    return self.__from_1_Lmosek_4fusion_4Variable_2(_0)
  def __from_1_Lmosek_4fusion_4Variable_2(self,_0):
   _1=self._getShape_()
   _2=_0._numInst_()
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _4=None
   if (_0._getSize_()==_2): # src/fusion/BoundInterfaceVariable.mbi:57:12-30
    _0._inst_I_3J(0,_3)
   else:
    _4 = numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _0._inst_I_3JI_3J(0,_4,0,_3)
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(_0._getModel_(),_1,_4,_3,self.__islower))
 return BoundInterfaceVariable
mosek_fusion_BoundInterfaceVariable=__mk_mosek_fusion_BoundInterfaceVariable()
del __mk_mosek_fusion_BoundInterfaceVariable
#BEFORE CLASS
def __mk_mosek_fusion_ModelVariable():
 class ModelVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_ModelVariable__sparsity','_ModelVariable__shape','_ModelVariable__modelvar_nativeidxs','_ModelVariable__varid','_ModelVariable__name']
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_ModelVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_ModelVariable._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_ModelVariable._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelVariable.remove()')
  def __repr__(self): return 'mosek.fusion.ModelVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4BaseVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__name = (v.__name)
   self.__varid = (v.__varid)
   self.__modelvar_nativeidxs = (v.__modelvar_nativeidxs)
   self.__shape = (v.__shape)
   self.__sparsity = (v.__sparsity)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,shape,varid,sparsity,modelvar_nativeidxs):
    o = ModelVariable.__new__(ModelVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,shape,varid,sparsity,modelvar_nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(*args):
    if len(args) != 6: return False
    model,name,shape,varid,sparsity,modelvar_nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match_J__(varid) and __arg_match__3J__(sparsity) and __arg_match__3J__(modelvar_nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(*args):
    if len(args) != 6: return False
    model,name,shape,varid,sparsity,modelvar_nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match_J__(varid) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3J__(modelvar_nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,modelvar_nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int64(varid),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(modelvar_nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,modelvar_nativeidxs):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,model,shape,sparsity,modelvar_nativeidxs)
   (self.__name) = name
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__sparsity) = sparsity
   (self.__modelvar_nativeidxs) = modelvar_nativeidxs
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _1._a_S(("_" if ((int(len(self.__name))==0) ) else self.__name))._a_S("[")._a_S(mosek.fusion.Set._indexToString__3IJ(self.__shape,_0))._a_S("]")
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   self._getModel_()._removeVariableBlock_J(self.__varid)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
 return ModelVariable
mosek_fusion_ModelVariable=__mk_mosek_fusion_ModelVariable()
del __mk_mosek_fusion_ModelVariable
#BEFORE CLASS
def __mk_mosek_fusion_RangedVariable():
 class RangedVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_RangedVariable__shape','_RangedVariable__name','_RangedVariable__names_flushed','_RangedVariable__nativeidxs','_RangedVariable__sparsity']
  def upperBoundVar(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_upperBoundVar_(*args): # 
      return self._upperBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_upperBoundVar_(*args): # 
      return self._upperBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.upperBoundVar()')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_RangedVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def lowerBoundVar(self,*args):
    if False: pass
    elif mosek_fusion_RangedVariable._match_lowerBoundVar_(*args): # 
      return self._lowerBoundVar_(*args)
    elif mosek_fusion_RangedVariable._match_alt_lowerBoundVar_(*args): # 
      return self._lowerBoundVar_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundVar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedVariable.lowerBoundVar()')
  def __repr__(self): return 'mosek.fusion.RangedVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__name = (v.__name)
   self.__nativeidxs = (v.__nativeidxs)
   self.__sparsity = (v.__sparsity)
   self.__names_flushed = (v.__names_flushed)
   self.__shape = (v.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs):
    o = RangedVariable.__new__(RangedVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,numpy.int64(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,mosek.fusion.RangedVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__name) = name
   (self.__shape) = shape
   self.__names_flushed = False
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   _1._a_S(" : in range")
   return (_1)
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  def _dual_1u_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1u_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1u_I_3D(self,_0,_1):
   self._dual_1lu_I_3DZ(_0,_1,False)
  def _dual_1l_alt_I_3D(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = self._dual_1l_I_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1l_I_3D(self,_0,_1):
   self._dual_1lu_I_3DZ(_0,_1,True)
  @staticmethod
  def _match_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundVar_alt_(self,):
    return self._upperBoundVar_()
  def _upperBoundVar_(self,):
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self._getModel_(),self.__shape,self.__sparsity,numpy.array([self.__nativeidxs[_0] for _0 in range(0,int((self.__nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.int64)),False))
  @staticmethod
  def _match_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundVar_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundVar_alt_(self,):
    return self._lowerBoundVar_()
  def _lowerBoundVar_(self,):
   return (mosek_fusion_BoundInterfaceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3JZ(self._getModel_(),self.__shape,self.__sparsity,numpy.array([self.__nativeidxs[_0] for _0 in range(0,int((self.__nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.int64)),True))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedVariable._ctor_Lmosek_4fusion_4RangedVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_RangedVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_191(_0,_1) # src/fusion/RangedVariable.mbi:26:44-98
   return (_1)
 return RangedVariable
mosek_fusion_RangedVariable=__mk_mosek_fusion_RangedVariable()
del __mk_mosek_fusion_RangedVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDVariable():
 class LinearPSDVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearPSDVariable__shape','_LinearPSDVariable__name','_LinearPSDVariable__varid','_LinearPSDVariable__nativeidxs','_LinearPSDVariable__conedim']
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    elif mosek_fusion_LinearPSDVariable._match_make_1integer__3J(*args): # []int64
      return self._make_1integer__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1integer__3J(*args): # []int64
      return self._make_1integer_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_integer()\n\tmosek.fusion.LinearPSDVariable.make_integer(array(int64,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.toString()')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    elif mosek_fusion_LinearPSDVariable._match_make_1continuous__3J(*args): # []int64
      return self._make_1continuous__3J(*args)
    elif mosek_fusion_LinearPSDVariable._match_alt_make_1continuous__3J(*args): # []int64
      return self._make_1continuous_alt__3J(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearPSDVariable.make_continuous()\n\tmosek.fusion.LinearPSDVariable.make_continuous(array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.LinearPSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   (self.__conedim) = (v.__conedim)
   (self.__varid) = (v.__varid)
   (self.__name) = (v.__name)
   (self.__shape) = (v.__shape)
   (self.__nativeidxs) = (v.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,varid,shape,conedim,nativeidxs):
    o = LinearPSDVariable.__new__(LinearPSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,varid,shape,conedim,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3II_3J(*args):
    if len(args) != 6: return False
    model,name,varid,shape,conedim,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match_I__(conedim) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3II_3J(*args):
    if len(args) != 6: return False
    model,name,varid,shape,conedim,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3II_3J(self,model,name,varid,shape,conedim,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3II_3J(self,model,name,varid,shape,conedim,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.LinearPSDVariable.__globalNativeIndexes__3J(nativeidxs))
   (self.__name) = name
   (self.__conedim) = conedim
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self.__name)) > 0): # src/fusion/LinearPSDVariable.monty:64:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1continuous__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1continuous_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1continuous__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1continuous__3J(self,_0):
   pass
  @staticmethod
  def _match_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3J__(_0))
  @staticmethod
  def _match_alt_make_1integer__3J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3J__(_0))
  def _make_1integer_alt__3J(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = self._make_1integer__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _make_1integer__3J(self,_0):
   raise mosek_fusion_UnimplementedError._ctor_S("Cannot make PSDVariable elements integer")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDVariable._ctor_Lmosek_4fusion_4LinearPSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3J(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_LinearPSDVariable.__globalNativeIndexes__3J(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3J(_0):
   return (numpy.array([(- (_0[_1] + 1)) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)))
 return LinearPSDVariable
mosek_fusion_LinearPSDVariable=__mk_mosek_fusion_LinearPSDVariable()
del __mk_mosek_fusion_LinearPSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_PSDVariable():
 class PSDVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_PSDVariable__model','_PSDVariable__names_flushed','_PSDVariable__barvaridxs','_PSDVariable__conedim2','_PSDVariable__conedim1','_PSDVariable__shape','_PSDVariable__name','_PSDVariable__nativeidxs','_PSDVariable__varid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.toString()')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_PSDVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_PSDVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def __repr__(self): return 'mosek.fusion.PSDVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__varid = (v.__varid)
   self.__nativeidxs = (v.__nativeidxs)
   self.__name = (v.__name)
   self.__shape = (v.__shape)
   self.__conedim1 = (v.__conedim1)
   self.__conedim2 = (v.__conedim2)
   self.__names_flushed = False
   self.__model = m
   self.__barvaridxs = (v.__barvaridxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3III_3I_3J(model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs):
    o = PSDVariable.__new__(PSDVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3I_3J(model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3III_3I_3J(*args):
    if len(args) != 8: return False
    model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match_I__(conedim1) and __arg_match_I__(conedim2) and __arg_match__3I__(barvaridxs) and __arg_match__3J__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3III_3I_3J(*args):
    if len(args) != 8: return False
    model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim1) and __arg_alt_match_I__(conedim2) and __arg_alt_match__3I__(barvaridxs) and __arg_alt_match__3J__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3III_3I_3J(self,model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3I_3J(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim1),numpy.int32(conedim2),numpy.array(barvaridxs,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3III_3I_3J(self,model,name,varid,shape,conedim1,conedim2,barvaridxs,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.PSDVariable.__fullnativeidxs__3III_3J(shape,conedim1,conedim2,nativeidxs))
   (self.__varid) = varid
   (self.__nativeidxs) = nativeidxs
   (self.__name) = name
   (self.__shape) = shape
   (self.__conedim1) = conedim1
   (self.__conedim2) = conedim2
   self.__names_flushed = False
   (self.__model) = model
   (self.__barvaridxs) = barvaridxs
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("PSDVariable(")
   if (int(len(self.__name)) > 0): # src/fusion/SemidefiniteVariable.mbi:123:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(_0,_1)
   _1._a_S(" : element in positive semidefinite cone")
   return (_1)
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDVariable._ctor_Lmosek_4fusion_4PSDVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __fullnativeidxs_alt__3III_3J(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_PSDVariable.__fullnativeidxs__3III_3J(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __fullnativeidxs__3III_3J(_0,_1,_2,_3):
   _4=int((_0).shape[0])
   _5=(_1 < _2)
   _6=(_1 if (_5 ) else _2)
   _7=(_1 if ((not _5) ) else _2)
   _8=1
   _8 = fragments._c_closure_192(_6,_8,_0) # src/fusion/SemidefiniteVariable.mbi:29:20-56
   _8 = numpy.int32(_8) # postprocess
   _9=_0[_6]
   _10=1
   _10 = fragments._c_closure_193(_6,_7,_10,_0) # src/fusion/SemidefiniteVariable.mbi:31:20-60
   _10 = numpy.int32(_10) # postprocess
   _11=_0[_7]
   _12=1
   _12 = fragments._c_closure_194(_7,_12,_4,_0) # src/fusion/SemidefiniteVariable.mbi:33:20-59
   _12 = numpy.int32(_12) # postprocess
   _13=((((_8 * _9) * _10) * _11) * _12)
   _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
   _15=_12
   _16=(_15 * _11)
   _17=(_16 * _10)
   _18=(_17 * _17)
   fragments._c_closure_195(_8,_9,_10,_11,_12,_3,_14,_18,_17,_16,_15) # src/fusion/SemidefiniteVariable.mbi:43:8-56:9
   return (_14)
 return PSDVariable
mosek_fusion_PSDVariable=__mk_mosek_fusion_PSDVariable()
del __mk_mosek_fusion_PSDVariable
#BEFORE CLASS
def __mk_mosek_fusion_LinearVariable():
 class LinearVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_LinearVariable__shape','_LinearVariable__sparsity','_LinearVariable__nativeidxs','_LinearVariable__names_flushed','_LinearVariable__name']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearVariable.toString()')
  def __repr__(self): return 'mosek.fusion.LinearVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__nativeidxs = (v.__nativeidxs)
   self.__sparsity = (v.__sparsity)
   self.__shape = (v.__shape)
   self.__name = (v.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs):
    o = LinearVariable.__new__(LinearVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,varid,shape,sparsity,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_J__(varid) and __arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(*args):
    if len(args) != 6: return False
    model,name,varid,shape,sparsity,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_J__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(model,name,numpy.int64(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SJ_3I_3J_3I(self,model,name,varid,shape,sparsity,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,sparsity,mosek.fusion.LinearVariable.__globalNativeIndexes__3I(nativeidxs))
   self.__names_flushed = False
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__sparsity) = sparsity
   (self.__shape) = shape
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("LinearVariable((")
   if (int((self.__shape).shape[0]) > 0): # src/fusion/LinearVariable.mbi:100:12-26
    _0._a_I(self.__shape[0])
    for _1 in range(1,int((self.__shape).shape[0])):
     _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   if (self.__sparsity is not None): # src/fusion/LinearVariable.mbi:105:12-28
    _0._a_S(",sparse")
   _0._a_S(")")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearVariable._ctor_Lmosek_4fusion_4LinearVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_LinearVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_196(_0,_1) # src/fusion/LinearVariable.mbi:32:44-98
   return (_1)
 return LinearVariable
mosek_fusion_LinearVariable=__mk_mosek_fusion_LinearVariable()
del __mk_mosek_fusion_LinearVariable
#BEFORE CLASS
def __mk_mosek_fusion_ConicVariable():
 class ConicVariable(mosek_fusion_ModelVariable):
  __slots__ = ['_ConicVariable__nativeidxs','_ConicVariable__shape','_ConicVariable__name','_ConicVariable__names_flushed','_ConicVariable__varid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicVariable.toString()')
  def __repr__(self): return 'mosek.fusion.ConicVariable'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    v,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
    self._ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(v,m)
  def _ctor_init_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,v,m):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4ModelVariable_2Lmosek_4fusion_4Model_2(self,v,m)
   self.__names_flushed = (v.__names_flushed)
   self.__shape = (v.__shape)
   self.__nativeidxs = (v.__nativeidxs)
   self.__shape = (v.__shape)
   self.__varid = (v.__varid)
   self.__name = (v.__name)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,varid,shape,nativeidxs):
    o = ConicVariable.__new__(ConicVariable)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,varid,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,varid,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(varid) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3I_3I(*args):
    if len(args) != 5: return False
    model,name,varid,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(varid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,varid,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(model,name,numpy.int32(varid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I(self,model,name,varid,shape,nativeidxs):
   mosek_fusion_ModelVariable._ctor_init_Lmosek_4fusion_4Model_2S_3IJ_3J_3J(self,model,name,shape,varid,None,mosek.fusion.ConicVariable.__globalNativeIndexes__3I(nativeidxs))
   (self.__name) = name
   (self.__names_flushed) = False
   (self.__varid) = varid
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("ConicVariable( ")
   if (int(len(self.__name)) > 0): # src/fusion/ConicVariable.mbi:100:12-25
    _0._a_S("'")._a_S(self.__name)._a_S("',")
   _0._a_S("(")
   _0._a_I(self.__shape[0])
   for _1 in range(1,int((self.__shape).shape[0])):
    _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(") )")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicVariable._ctor_Lmosek_4fusion_4ConicVariable_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __globalNativeIndexes_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ConicVariable.__globalNativeIndexes__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __globalNativeIndexes__3I(_0):
   _1=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_197(_0,_1) # src/fusion/ConicVariable.mbi:36:44-98
   return (_1)
 return ConicVariable
mosek_fusion_ConicVariable=__mk_mosek_fusion_ConicVariable()
del __mk_mosek_fusion_ConicVariable
#BEFORE CLASS
def __mk_mosek_fusion_NilVariable():
 class NilVariable(mosek_fusion_BaseVariable):
  __slots__ = ['_NilVariable__shape']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_NilVariable._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.toString()')
  def numInst(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_numInst_(*args): # 
      return self._numInst_(*args)
    elif mosek_fusion_NilVariable._match_alt_numInst_(*args): # 
      return self._numInst_alt_(*args)
    else:
      raise ValueError('Invalid argument list numInst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.numInst()')
  def make_integer(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1integer_(*args): # 
      return self._make_1integer_(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1integer_(*args): # 
      return self._make_1integer_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_integer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_integer()')
  def elementName(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementName('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementName(int64,mosek.fusion.Utils.StringBuffer)')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_NilVariable._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_NilVariable._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_NilVariable._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    elif mosek_fusion_NilVariable._match_index_II(*args): # int32,int32
      return self._index_II(*args)
    elif mosek_fusion_NilVariable._match_alt_index_II(*args): # int32,int32
      return self._index_alt_II(*args)
    elif mosek_fusion_NilVariable._match_index_III(*args): # int32,int32,int32
      return self._index_III(*args)
    elif mosek_fusion_NilVariable._match_alt_index_III(*args): # int32,int32,int32
      return self._index_alt_III(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.index(int32)\n\tmosek.fusion.NilVariable.index(array(int32,ndim=1))\n\tmosek.fusion.NilVariable.index(int32,int32)\n\tmosek.fusion.NilVariable.index(int32,int32,int32)')
  def set_values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_set_1values__3DZ(*args): # []double,bool
      return self._set_1values__3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_set_1values__3DZ(*args): # []double,bool
      return self._set_1values_alt__3DZ(*args)
    else:
      raise ValueError('Invalid argument list set_values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.set_values(array(double,ndim=1),bool)')
  def make_continuous(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_make_1continuous_(*args): # 
      return self._make_1continuous_(*args)
    elif mosek_fusion_NilVariable._match_alt_make_1continuous_(*args): # 
      return self._make_1continuous_alt_(*args)
    else:
      raise ValueError('Invalid argument list make_continuous('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.make_continuous()')
  def values(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_I_3DZ(*args)
    elif mosek_fusion_NilVariable._match_alt_values_I_3DZ(*args): # int32,[]double,bool
      return self._values_alt_I_3DZ(*args)
    else:
      raise ValueError('Invalid argument list values('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.values(int32,array(double,ndim=1),bool)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_NilVariable._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_NilVariable._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_NilVariable._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.slice(int32,int32)\n\tmosek.fusion.NilVariable.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def elementDesc(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    elif mosek_fusion_NilVariable._match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args): # int64,mosek.fusion.Utils.StringBuffer
      return self._elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(*args)
    else:
      raise ValueError('Invalid argument list elementDesc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.elementDesc(int64,mosek.fusion.Utils.StringBuffer)')
  def inst(self,*args):
    if False: pass
    elif mosek_fusion_NilVariable._match_inst_I_3J(*args): # int32,[]int64
      return self._inst_I_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3J(*args): # int32,[]int64
      return self._inst_alt_I_3J(*args)
    elif mosek_fusion_NilVariable._match_inst_I_3J_3J(*args): # int32,[]int64,[]int64
      return self._inst_I_3J_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3J_3J(*args): # int32,[]int64,[]int64
      return self._inst_alt_I_3J_3J(*args)
    elif mosek_fusion_NilVariable._match_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_I_3JI_3J(*args)
    elif mosek_fusion_NilVariable._match_alt_inst_I_3JI_3J(*args): # int32,[]int64,int32,[]int64
      return self._inst_alt_I_3JI_3J(*args)
    else:
      raise ValueError('Invalid argument list inst('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1))\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),array(int64,ndim=1))\n\tmosek.fusion.NilVariable.inst(int32,array(int64,ndim=1),int32,array(int64,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NilVariable'
  @staticmethod
  def _ctor__3I(shape):
    o = NilVariable.__new__(NilVariable)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   mosek_fusion_BaseVariable._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3J(self,None,mosek.fusion.Utils.Tools._arraycopy__3I(shape),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)))
   (self.__shape) = numpy.array([shape[_0] for _0 in range(0,int((shape).shape[0]))], dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_():
    o = NilVariable.__new__(NilVariable)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_NilVariable._ctor_init__3I(self,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  @staticmethod
  def _match_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementDesc_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementDesc_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   return (_1)
  @staticmethod
  def _match_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_J__(_0) and __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  @staticmethod
  def _match_alt_elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_J__(_0) and __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(_1))
  def _elementName_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _elementName_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  @staticmethod
  def _match_numInst_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numInst_(*args):
    if len(args) != 0: return False
    return True
  def _numInst_alt_(self,):
    return self._numInst_()
  def _numInst_(self,):
   return numpy.int32(0)
  @staticmethod
  def _match_inst_I_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match__3J__(_2))
  @staticmethod
  def _match_alt_inst_I_3J_3J(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3J__(_2))
  def _inst_alt_I_3J_3J(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J_3J(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J_3J(self,_0,_1,_2):
   return numpy.int32(0)
  @staticmethod
  def _match_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1))
  @staticmethod
  def _match_alt_inst_I_3J(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1))
  def _inst_alt_I_3J(self,_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _1 = self._inst_I_3J(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _inst_I_3J(self,_0,_1):
   pass
  @staticmethod
  def _match_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Z__(_1))
  @staticmethod
  def _match_alt_set_1values__3DZ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Z__(_1))
  def _set_1values_alt__3DZ(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = self._set_1values__3DZ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _set_1values__3DZ(self,_0,_1):
   pass
  @staticmethod
  def _match_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_values_I_3DZ(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_Z__(_2))
  def _values_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._values_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _values_I_3DZ(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1continuous_(*args):
    if len(args) != 0: return False
    return True
  def _make_1continuous_alt_(self,):
    return self._make_1continuous_()
  def _make_1continuous_(self,):
   pass
  @staticmethod
  def _match_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_make_1integer_(*args):
    if len(args) != 0: return False
    return True
  def _make_1integer_alt_(self,):
    return self._make_1integer_()
  def _make_1integer_(self,):
   pass
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("NilVariable")
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([1 for _1 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([1 for _1 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if ((int((self.__shape).shape[0])!=int((_0).shape[0])) or (int((self.__shape).shape[0])!=int((_1).shape[0]))): # src/fusion/BaseVariable.monty:1030:12-63
    raise mosek_fusion_DimensionError._ctor_S("Mismatching slice shape")
   for _2 in range(0,int((_0).shape[0])):
    if ((_1[_2] > _0[_2]) or ((_0[_2] < 0) or (_1[_2] >= self.__shape[_2]))): # src/fusion/BaseVariable.monty:1033:14-71
     raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   return (mosek_fusion_NilVariable._ctor__3I(numpy.array([(_1[_3] - _0[_3]) for _3 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if ((_1 > _0) or ((_0 < 0) or (_1 > self.__shape[0]))): # src/fusion/BaseVariable.monty:1018:12-56
    raise mosek_fusion_SliceError._ctor_S("Slice is out of bounds")
   elif (int((self.__shape).shape[0])!=1): # src/fusion/BaseVariable.monty:1020:16-31
    raise mosek_fusion_DimensionError._ctor_S("Mismatching slice shape")
   else:
    return (mosek_fusion_NilVariable._ctor__3I(numpy.array([(_1 - _0)], dtype=numpy.dtype(numpy.int32))))
 return NilVariable
mosek_fusion_NilVariable=__mk_mosek_fusion_NilVariable()
del __mk_mosek_fusion_NilVariable
#BEFORE CLASS
def __mk_mosek_fusion_Var():
 class Var(object):
  @staticmethod
  def vrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._vrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list vrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def hrepeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._hrepeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list hrepeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hrepeat(mosek.fusion.Variable,int32)')
  @staticmethod
  def empty(*args):
    if False: pass
    elif mosek_fusion_Var._match_empty__3I(*args): # []int32
      return mosek_fusion_Var._empty__3I(*args)
    elif mosek_fusion_Var._match_alt_empty__3I(*args): # []int32
      return mosek_fusion_Var._empty_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list empty('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.empty(array(int32,ndim=1))')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args): # mosek.fusion.Variable,[]int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2_3I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._reshape_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,array(int32,ndim=1))\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.reshape(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.hstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.hstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def promote(*args):
    if False: pass
    elif mosek_fusion_Var._match_promote_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._promote_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_promote_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._promote_alt_Lmosek_4fusion_4Variable_2I(*args)
    else:
      raise ValueError('Invalid argument list promote('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.promote(mosek.fusion.Variable,int32)')
  @staticmethod
  def compress(*args):
    if False: pass
    elif mosek_fusion_Var._match_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_compress_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._compress_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list compress('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.compress(mosek.fusion.Variable)')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Var._match_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_flatten_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      return mosek_fusion_Var._flatten_alt_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.flatten(mosek.fusion.Variable)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Var._match_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.vstack(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.vstack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Var._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Var._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.repeat(mosek.fusion.Variable,int32,int32)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Var._match_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args): # [][]mosek.fusion.Variable
      return mosek_fusion_Var._stack_alt__3_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args): # []mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt__3Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_I_3Lmosek_4fusion_4Variable_2(*args): # int32,[]mosek.fusion.Variable
      return mosek_fusion_Var._stack_I_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack_I_3Lmosek_4fusion_4Variable_2(*args): # int32,[]mosek.fusion.Variable
      return mosek_fusion_Var._stack_alt_I_3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args): # mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32
      return mosek_fusion_Var._stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args)
    elif mosek_fusion_Var._match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Var._match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args): # int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable
      return mosek_fusion_Var._stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Var.stack(array(array(mosek.fusion.Variable,ndim=1),ndim=1))\n\tmosek.fusion.Var.stack(array(mosek.fusion.Variable,ndim=1),int32)\n\tmosek.fusion.Var.stack(int32,array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable)\n\tmosek.fusion.Var.stack(mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable,int32)\n\tmosek.fusion.Var.stack(int32,mosek.fusion.Variable,mosek.fusion.Variable,mosek.fusion.Variable)')
  def __repr__(self): return 'mosek.fusion.Var'
  @staticmethod
  def _match_empty__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_empty__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _empty_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._empty__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _empty__3I(_0):
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] < 0): # src/fusion/Var.monty:810:14-26
     raise mosek_fusion_DimensionError._ctor_S("Invalid shape")
   return (mosek_fusion_NilVariable._ctor__3I(_0))
  @staticmethod
  def _match_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_compress_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _compress_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._compress_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _compress_Lmosek_4fusion_4Variable_2(_0):
   _1=_0._getShape_()
   _2=int((_1).shape[0])
   _3=0
   _3 = fragments._c_closure_198(_2,_3,_1) # src/fusion/Var.monty:787:8-788:38
   _3 = numpy.int32(_3) # postprocess
   _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_199(_2,_4,_1) # src/fusion/Var.monty:790:8-797:9
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,_4))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Variable_2(_t__0):
    return mosek_fusion_Var._flatten_Lmosek_4fusion_4Variable_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Variable_2(_0):
   return (mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,numpy.array([numpy.int32(mosek.fusion.Set._size__3I(_0._getShape_()))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Variable_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _reshape_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   return (_0._reshape__3I(_1))
  @staticmethod
  def _index_1permute_1_alt_Lmosek_4fusion_4Variable_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Var._index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _index_1permute_1_Lmosek_4fusion_4Variable_2_3I(_0,_1):
   _4=_0._getShape_()
   _5=int((_4).shape[0])
   _6=1
   _6 = fragments._c_closure_200(_5,_4,_6) # src/fusion/Var.monty:624:27-69
   _6 = numpy.int32(_6) # postprocess
   _7=_0._numInst_()
   _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
   _8[(_5 - 1)] = 1
   fragments._c_closure_201(_5,_1,_8,_4) # src/fusion/Var.monty:627:57-131
   if (_7 < _6): # src/fusion/Var.monty:629:12-27
    _2 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _3 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _0._inst_I_3JI_3J(0,_2,0,_3)
   else:
    _2 = None
    _3 = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _0._inst_I_3J(0,_3)
   if (_2 is None): # src/fusion/Var.monty:640:12-28
    _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_202(_3,_5,_7,_1,_8,_9,_4) # src/fusion/Var.monty:642:10-649:11
    _3 = _9
   else:
    _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_203(_5,_7,_1,_8,_10,_4) # src/fusion/Var.monty:654:10-661:11
    _11=numpy.array([_12 for _12 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_11,_10,None,0,_7)
    _2 = numpy.array([_2[_11[_13]] for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    _3 = numpy.array([_3[_11[_14]] for _14 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
   return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_0._getModel_(),numpy.array([_4[_1[_15]] for _15 in range(0,_5)], dtype=numpy.dtype(numpy.int32)),_2,_3))
  @staticmethod
  def _match_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_hrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _hrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._hrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _hrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,1,_1))
  @staticmethod
  def _match_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_vrepeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _vrepeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._vrepeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _vrepeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,0,_1))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._repeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2))
  @staticmethod
  def __drepeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Var.__drepeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __drepeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   if (_2 < 0): # src/fusion/Var.monty:477:12-17
    raise mosek_fusion_LengthError._ctor_S("Cannot repeat less than 0 times")
   elif (_2==0): # src/fusion/Var.monty:479:16-22
    return (mosek_fusion_NilVariable._ctor_())
   elif (_2==1): # src/fusion/Var.monty:481:16-22
    return (_0)
   else:
    _3=_0._getModel_()
    _4=_0._getShape_()
    _5=int((_4).shape[0])
    if ((_1 < 0) or (_1 > _5)): # src/fusion/Var.monty:488:14-33
     raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
    _6=mosek.fusion.Set._size__3I(_4)
    _7=_0._numInst_()
    _8=(_7 * _2)
    _9=1
    _9 = fragments._c_closure_204(_9,_1,_4) # src/fusion/Var.monty:494:22-58
    _9 = numpy.int32(_9) # postprocess
    _10=(_4[_1] if ((_1 < _5) ) else 1)
    _11=(_10 * _2)
    _12=1
    _12 = fragments._c_closure_205(_12,_1,_5,_4) # src/fusion/Var.monty:497:22-61
    _12 = numpy.int32(_12) # postprocess
    _13=(_5 if ((_1 < _5) ) else (_1 + 1))
    _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_206(_5,_14,_4) # src/fusion/Var.monty:501:10-51
    fragments._c_closure_207(_5,_13,_14) # src/fusion/Var.monty:502:10-46
    _14[_1] = _11
    if (_7 < _6): # src/fusion/Var.monty:505:14-27
     _15=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _16=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _17=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     _18=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int64))
     _0._inst_I_3JI_3J(0,_16,0,_15)
     _19=(_11 * _12)
     _20=(_10 * _12)
     _21=_12
     if (_1==0): # src/fusion/Var.monty:518:18-26
      _22=0
      _22 = fragments._c_closure_208(_6,_22,_2,_7,_17,_18,_15,_16) # src/fusion/Var.monty:520:16-525:19
      _22 = numpy.int32(_22) # postprocess
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_14,_18,_17))
     elif (_1 >= _5): # src/fusion/Var.monty:528:22-31
      _23=0
      _23 = fragments._c_closure_209(_23,_2,_7,_17,_18,_15,_16) # src/fusion/Var.monty:530:16-535:19
      _23 = numpy.int32(_23) # postprocess
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_14,_18,_17))
     else:
      _24=0
      _24 = fragments._c_closure_210(_10,_12,_24,_2,_7,_19,_17,_18,_20,_21,_15,_16) # src/fusion/Var.monty:541:16-551:17
      _24 = numpy.int32(_24) # postprocess
      _25=1
      _25 = fragments._c_closure_211(_25,_13,_14) # src/fusion/Var.monty:554:32-96
      _25 = numpy.int32(_25) # postprocess
      _26=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
      _27=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
      _28=numpy.zeros(((_25 + 1),), dtype=numpy.dtype(numpy.int32))
      _29=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int64))
      _29[(_13 - 1)] = 1
      fragments._c_closure_212(_13,_14,_29) # src/fusion/Var.monty:560:55-114
      fragments._c_closure_213(_26,_8) # src/fusion/Var.monty:561:18-55
      for _30 in range(0,_13):
       _31=((_13 - _30) - 1)
       fragments._c_closure_214(_31,_28,_14) # src/fusion/Var.monty:565:20-60
       fragments._c_closure_215(_31,_28,_8,_14,_18,_29) # src/fusion/Var.monty:566:20-79
       fragments._c_closure_216(_31,_28,_14) # src/fusion/Var.monty:567:20-66
       fragments._c_closure_217(_26,_31,_28,_8,_14,_18,_29,_27) # src/fusion/Var.monty:568:20-573:21
       _32=_26
       _26 = _27
       _27 = _32
      return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_14,numpy.array([_18[_26[_33]] for _33 in range(0,_8)], dtype=numpy.dtype(numpy.int64)),numpy.array([_17[_26[_34]] for _34 in range(0,_8)], dtype=numpy.dtype(numpy.int64))))
    else:
     _35=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
     _36=numpy.zeros(((_7 * _2),), dtype=numpy.dtype(numpy.int64))
     _0._inst_I_3J(0,_35)
     _37=(_11 * _12)
     _38=_12
     _39=0
     _39 = fragments._c_closure_218(_9,_10,_12,_39,_2,_36,_37,_38,_35) # src/fusion/Var.monty:595:12-601:17
     _39 = numpy.int32(_39) # postprocess
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_3,_14,None,_36))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Var._stack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Variable_2(_0):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0[_1],1) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._vstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Variable_2(_0):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Var._hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._hstack__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Variable_2(_0):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,1))
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._stack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   return (mosek.fusion.Var._stack_I_3Lmosek_4fusion_4Variable_2(_1,_0))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,numpy.int32(__3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2,_3):
   return (mosek.fusion.Var._stack_I_3Lmosek_4fusion_4Variable_2(_3,numpy.array([_0,_1,_2], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,numpy.int32(__2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2I(_0,_1,_2):
   return (mosek.fusion.Var._stack_I_3Lmosek_4fusion_4Variable_2(_2,numpy.array([_0,_1], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Var._stack_I_3Lmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Variable_2(_0,_1):
   _2=_0
   for _3 in range(0,int((_1).shape[0])):
    if (_2 < _1[_3]._getND_()): # src/fusion/Var.monty:291:53-73
     _2 = _1[_3]._getND_()
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(_1,_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Var._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2,_3):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_1,_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Var._stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Variable_2Lmosek_4fusion_4Variable_2(_0,_1,_2):
   return (mosek.fusion.Var._dstack__3Lmosek_4fusion_4Variable_2I(numpy.array([_1,_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_promote_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_promote_Lmosek_4fusion_4Variable_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _promote_alt_Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
    return mosek_fusion_Var._promote_Lmosek_4fusion_4Variable_2I(_0,numpy.int32(__1))
  @staticmethod
  def _promote_Lmosek_4fusion_4Variable_2I(_0,_1):
   if (_1 > _0._getND_()): # src/fusion/Var.monty:276:12-26
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    _3=_0._getShape_()
    fragments._c_closure_219(_3,_2) # src/fusion/Var.monty:279:10-52
    fragments._c_closure_220(_1,_3,_2) # src/fusion/Var.monty:280:10-49
    return (_0._reshape__3I(_2))
   else:
    return (_0)
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Variable_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Var._dstack__3Lmosek_4fusion_4Variable_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Variable_2I(_0,_1):
   if (_1 < 0): # src/fusion/Var.monty:155:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
   _2=None
   for _3 in range(0,int((_0).shape[0])):
    if (_2 is None): # src/fusion/Var.monty:161:16-26
     _2 = _0[_3]._getModel_()
    elif ((_0[_3]._getModel_() is not None) and (_0[_3]._getModel_() is not _2)): # src/fusion/Var.monty:162:20-69
     _4=mosek.fusion.Utils.StringBuffer()
     _5=(_2._getName_() if ((int(len(_2._getName_())) > 0) ) else "?")
     _6=(_0[_3]._getModel_()._getName_() if ((int(len(_0[_3]._getModel_()._getName_())) > 0) ) else "?")
     _4._a_S("Variables belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   if (int((_0).shape[0])==0): # src/fusion/Var.monty:173:12-23
    return (mosek_fusion_NilVariable._ctor_())
   elif (int((_0).shape[0])==1): # src/fusion/Var.monty:174:16-27
    return (_0[0])
   else:
    _7=int((_0).shape[0])
    _8=numpy.array([_0[_9]._numInst_() for _9 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _10=_monty.initJaggedArray([_0[_11]._getShape_() for _11 in range(0,_7)], 1)
    _12=numpy.array([int((_10[_13]).shape[0]) for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _14=_10[0]
    _15=_12[0]
    _16=0
    _16 = fragments._c_closure_221(_7,_8,_16) # src/fusion/Var.monty:182:24-60
    _16 = numpy.int32(_16) # postprocess
    _17=(_1 + 1)
    _17 = fragments._c_closure_222(_7,_12,_17) # src/fusion/Var.monty:184:27-77
    _17 = numpy.int32(_17) # postprocess
    _18=numpy.zeros((_17,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_223(_15,_18,_14) # src/fusion/Var.monty:186:10-53
    fragments._c_closure_224(_15,_17,_18) # src/fusion/Var.monty:186:54-91
    _18[_1] = 0
    fragments._c_closure_225(_1,_7,_18,_10) # src/fusion/Var.monty:187:27-109
    for _19 in range(0,_7):
     for _20 in range(0,int((_10[_19]).shape[0])):
      if ((_20!=_1) and (_10[_19][_20]!=_18[_20])): # src/fusion/Var.monty:191:18-56
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
     for _21 in range(int((_10[_19]).shape[0]),_17):
      if ((_21!=_1) and (1!=_18[_21])): # src/fusion/Var.monty:194:18-45
       raise mosek_fusion_DimensionError._ctor_S("Variable dimensions do not match")
    _22=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    _23=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int64))
    _24=numpy.array([(_10[_25][_1] if ((_1 < int((_10[_25]).shape[0])) ) else 1) for _25 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
    _26=1
    _26 = fragments._c_closure_226(_26,_1,_14) # src/fusion/Var.monty:202:22-88
    _26 = numpy.int32(_26) # postprocess
    _27=0
    _27 = fragments._c_closure_227(_27,_7,_24) # src/fusion/Var.monty:203:22-56
    _27 = numpy.int32(_27) # postprocess
    _28=1
    _28 = fragments._c_closure_228(_28,_1,_14) # src/fusion/Var.monty:204:22-71
    _28 = numpy.int32(_28) # postprocess
    if (_26==1): # src/fusion/Var.monty:206:14-21
     _29=0
     _30=0
     for _31 in range(0,_7):
      _0[_31]._inst_I_3JI_3J(_29,_23,_29,_22)
      _29 = fragments._c_closure_229(_31,_29,_30,_8,_23) # src/fusion/Var.monty:210:14-213:15
      _29 = numpy.int32(_29) # postprocess
      _30 += mosek.fusion.Set._size__3I(_10[_31])
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_2,_18,(_23 if ((_16 < ((_26 * _27) * _28)) ) else None),_22))
    else:
     _32=0
     for _33 in range(0,_7):
      _32 += _0[_33]._inst_I_3JI_3J(_32,_23,_32,_22)
     _34=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
     _35=numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
     _36=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_230(_7,_36,_24) # src/fusion/Var.monty:226:38-92
     fragments._c_closure_231(_34,_16) # src/fusion/Var.monty:228:12-49
     _37=0
     _37 = fragments._c_closure_232(_27,_28,_37,_7,_8,_36,_23,_24) # src/fusion/Var.monty:231:12-241:13
     _37 = numpy.int32(_37) # postprocess
     _38=1
     _38 = fragments._c_closure_233(_38,_17,_18) # src/fusion/Var.monty:243:28-104
     _38 = numpy.int32(_38) # postprocess
     _39=numpy.zeros((_17,), dtype=numpy.dtype(numpy.int64))
     _39[(_17 - 1)] = 1
     fragments._c_closure_234(_17,_18,_39) # src/fusion/Var.monty:244:49-106
     _40=numpy.zeros(((_38 + 1),), dtype=numpy.dtype(numpy.int32))
     for _41 in range(0,_17):
      _42=((_17 - _41) - 1)
      fragments._c_closure_235(_42,_40,_18) # src/fusion/Var.monty:249:14-54
      fragments._c_closure_236(_42,_40,_16,_18,_23,_39) # src/fusion/Var.monty:250:14-69
      fragments._c_closure_237(_42,_40,_18) # src/fusion/Var.monty:251:14-60
      fragments._c_closure_238(_34,_42,_40,_16,_18,_23,_39,_35) # src/fusion/Var.monty:252:14-257:15
      _43=_34
      _34 = _35
      _35 = _43
     return (mosek_fusion_SliceVariable._ctor_Lmosek_4fusion_4Model_2_3I_3J_3J(_2,_18,(numpy.array([_23[_34[_44]] for _44 in range(0,_16)], dtype=numpy.dtype(numpy.int64)) if ((_16 < ((_26 * _27) * _28)) ) else None),numpy.array([_22[_34[_45]] for _45 in range(0,_16)], dtype=numpy.dtype(numpy.int64))))
 return Var
mosek_fusion_Var=__mk_mosek_fusion_Var()
del __mk_mosek_fusion_Var
#BEFORE CLASS
def __mk_mosek_fusion_Constraint():
 class Constraint(object):
  __slots__ = ['_Constraint__con_nativeidxs','_Constraint__shape','_Constraint__model']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):# mosek.fusion.Constraint,mosek.fusion.Model
      self._ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args): # mosek.fusion.Model,[]int32,[]int32
      self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):# mosek.fusion.Model,[]int32,[]int32
      self._ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Constraint,mosek.fusion.Model)\n\tmosek.fusion.Constraint.ctor(mosek.fusion.Model,array(int32,ndim=1),array(int32,ndim=1))')
  def level(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_level_(*args): # 
      return self._level_(*args)
    elif mosek_fusion_Constraint._match_alt_level_(*args): # 
      return self._level_alt_(*args)
    else:
      raise ValueError('Invalid argument list level('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.level()')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_Constraint._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.remove()')
  def update(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._update_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return self._update_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Constraint._match_update__3D(*args): # []double
      return self._update__3D(*args)
    elif mosek_fusion_Constraint._match_alt_update__3D(*args): # []double
      return self._update_alt__3D(*args)
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Expression,mosek.fusion.Variable
      return self._update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Constraint._match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args): # mosek.fusion.Expression,mosek.fusion.Variable,bool
      return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args)
    elif mosek_fusion_Constraint._match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args): # mosek.fusion.Expression,mosek.fusion.Variable,bool
      return self._update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args)
    else:
      raise ValueError('Invalid argument list update('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression)\n\tmosek.fusion.Constraint.update(array(double,ndim=1))\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable)\n\tmosek.fusion.Constraint.update(mosek.fusion.Expression,mosek.fusion.Variable,bool)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_Constraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_Constraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_Constraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.slice(int32,int32)\n\tmosek.fusion.Constraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_vstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.vstack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.vstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_hstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack__3Lmosek_4fusion_4Constraint_2(*args): # []mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt__3Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    elif mosek_fusion_Constraint._match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint
      return mosek_fusion_Constraint._hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.hstack(array(mosek.fusion.Constraint,ndim=1))\n\tmosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint)\n\tmosek.fusion.Constraint.hstack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint)')
  def size(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_size_(*args): # 
      return self._size_(*args)
    elif mosek_fusion_Constraint._match_alt_size_(*args): # 
      return self._size_alt_(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.size()')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_Constraint._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getModel()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_Constraint._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getSize()')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_Constraint._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getND()')
  def get_model(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1model_(*args): # 
      return self._get_1model_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1model_(*args): # 
      return self._get_1model_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_model('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_model()')
  def get_nd(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_get_1nd_(*args): # 
      return self._get_1nd_(*args)
    elif mosek_fusion_Constraint._match_alt_get_1nd_(*args): # 
      return self._get_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list get_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.get_nd()')
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_Constraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.dual()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Constraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.toString()')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Constraint._match_stack__3Lmosek_4fusion_4Constraint_2I(*args): # []mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack__3Lmosek_4fusion_4Constraint_2I(*args): # []mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt__3Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    elif mosek_fusion_Constraint._match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args): # mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32
      return mosek_fusion_Constraint._stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.stack(array(mosek.fusion.Constraint,ndim=1),int32)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,int32)\n\tmosek.fusion.Constraint.stack(mosek.fusion.Constraint,mosek.fusion.Constraint,mosek.fusion.Constraint,int32)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_Constraint._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.getShape()')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_Constraint._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_Constraint._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_Constraint._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_Constraint._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Constraint.index(int32)\n\tmosek.fusion.Constraint.index(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Constraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m):
   self.__model = m
   self.__shape = (c.__shape)
   self.__con_nativeidxs = (c.__con_nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3I(model,shape,con_nativeidxs):
    o = Constraint.__new__(Constraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,shape,con_nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,con_nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3I__(con_nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,con_nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(con_nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,con_nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(con_nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,con_nativeidxs):
   (self.__model) = model
   (self.__shape) = shape
   (self.__con_nativeidxs) = con_nativeidxs
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   raise mosek_fusion_UnimplementedError._ctor_S("Constraint.toString")
  def _toStringArray_alt__3JJ_3S(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(object))
   _1 = self._toStringArray__3JJ_3S(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _toStringArray__3JJ_3S(self,_0,_1,_2):
   pass
  def _dual_1lu_alt_I_3DZ(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = self._dual_1lu_I_3DZ(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _dual_1lu_I_3DZ(self,_0,_1,_2):
   self.__model._getConstraintDuals_Z_3I_3DI(_2,self.__con_nativeidxs,_1,_0)
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((int((self.__con_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__values_ZI_3D(False,0,_0)
   return (_0)
  @staticmethod
  def _match_level_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_level_(*args):
    if len(args) != 0: return False
    return True
  def _level_alt_(self,):
    return self._level_()
  def _level_(self,):
   _0=numpy.zeros((int((self.__con_nativeidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
   self.__values_ZI_3D(True,0,_0)
   return (_0)
  def __values_alt_ZI_3D(self,_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self.__values_ZI_3D(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __values_ZI_3D(self,_0,_1,_2):
   self.__model._getConstraintValues_Z_3I_3DI(_0,self.__con_nativeidxs,_2,_1)
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   raise mosek_fusion_DeletionError._ctor_S("Only original constraints can be removed")
  @staticmethod
  def _match_update__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_update__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _update_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._update__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _update__3D(self,_0):
   self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(mosek.fusion.Expr._constTerm__3D(_0),self._getShape_()),mosek_fusion_NilVariable._ctor_(),True)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  def _update_alt_Lmosek_4fusion_4Expression_2(self,_t__0):
    return self._update_Lmosek_4fusion_4Expression_2(_0)
  def _update_Lmosek_4fusion_4Expression_2(self,_0):
   _1=_0._getShape_()
   if (int((self.__shape).shape[0]) < int((_1).shape[0])): # src/fusion/Constraint.mbi:579:12-36
    raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _2 in range(0,int((_1).shape[0])):
    if (_1[_2]!=self.__shape[_2]): # src/fusion/Constraint.mbi:582:14-35
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _3 in range(int((_1).shape[0]),int((self.__shape).shape[0])):
    if (self.__shape[_3]!=1): # src/fusion/Constraint.mbi:585:14-27
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   self.__model._update__3ILmosek_4fusion_4Expression_2(self.__con_nativeidxs,_0)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_match_Z__(_2))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1) and __arg_alt_match_Z__(_2))
  def _update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(self,_t__0,_t__1,_t__2):
    return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(_0,_1,_2)
  def _update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(self,_0,_1,_2):
   _3=self._getND_()
   _4=_0._getShape_()
   if (_3 < int((_4).shape[0])): # src/fusion/Constraint.mbi:520:12-28
    raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _5 in range(0,int((_4).shape[0])):
    if (_4[_5]!=self.__shape[_5]): # src/fusion/Constraint.mbi:523:14-35
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   for _6 in range(int((_4).shape[0]),int((self.__shape).shape[0])):
    if (self.__shape[_6]!=1): # src/fusion/Constraint.mbi:526:14-27
     raise mosek_fusion_DimensionError._ctor_S("Expression shape does not match constraint")
   _7=_1._numInst_()
   _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
   if (_7 < _1._getSize_()): # src/fusion/Constraint.mbi:531:12-28
    _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    _1._inst_I_3JI_3J(0,_9,0,_8)
   else:
    _1._inst_I_3J(0,_8)
   for _10 in range(0,_7):
    if (_8[_10] < 0): # src/fusion/Constraint.mbi:539:14-28
     raise mosek_fusion_UpdateError._ctor_S("Semidefinite terms cannot be updated")
   _12=True
   _12 = fragments._c_closure_239(_12,_7,_8) # src/fusion/Constraint.mbi:546:10-82
   if _12: # src/fusion/Constraint.mbi:547:14-22
    if (not _2): # src/fusion/Constraint.mbi:548:16-30
     _11 = numpy.array([numpy.int32(_8[_13]) for _13 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    else:
     _11 = numpy.zeros(((_7 + 1),), dtype=numpy.dtype(numpy.int32))
     _11[0] = 0
     fragments._c_closure_240(_7,_8,_11) # src/fusion/Constraint.mbi:553:14-69
   else:
    _14=numpy.array([_15 for _15 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_14,_8,None,0,_7)
    _16=1
    _16 = fragments._c_closure_241(_7,_16,_14,_8) # src/fusion/Constraint.mbi:560:12-85
    _16 = numpy.int32(_16) # postprocess
    if _2: # src/fusion/Constraint.mbi:561:16-26
     _16 += 1
    _11 = numpy.zeros((_16,), dtype=numpy.dtype(numpy.int32))
    _17=0
    if _2: # src/fusion/Constraint.mbi:564:16-26
     _11[0] = 0
     _17 += 1
    _11[_17] = numpy.int32(_8[_14[0]])
    _17 = fragments._c_closure_242(_17,_7,_14,_8,_11) # src/fusion/Constraint.mbi:566:12-569:13
    _17 = numpy.int32(_17) # postprocess
   self.__model._update__3ILmosek_4fusion_4Expression_2_3I(self.__con_nativeidxs,_0,_11)
  @staticmethod
  def _match_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  def _update_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_t__0,_t__1):
    return self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(_0,_1)
  def _update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2(self,_0,_1):
   self._update_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Variable_2Z(_0,_1,False)
  @staticmethod
  def _match_get_1model_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1model_(*args):
    if len(args) != 0: return False
    return True
  def _get_1model_alt_(self,):
    return self._get_1model_()
  def _get_1model_(self,):
   return (self.__model)
  @staticmethod
  def _match_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_get_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _get_1nd_alt_(self,):
    return self._get_1nd_()
  def _get_1nd_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_size_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_size_(*args):
    if len(args) != 0: return False
    return True
  def _size_alt_(self,):
    return self._size_()
  def _size_(self,):
   _0=1
   _0 = fragments._c_closure_243(self.__shape,_0) # src/fusion/Constraint.mbi:493:26-69
   _0 = numpy.int64(_0) # postprocess
   return numpy.int64(_0)
  @staticmethod
  def _match_stack__3Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_stack__3Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _stack_alt__3Lmosek_4fusion_4Constraint_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Constraint._stack__3Lmosek_4fusion_4Constraint_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3Lmosek_4fusion_4Constraint_2I(_0,_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2,numpy.int32(__3))
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2,_3):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),_3))
  @staticmethod
  def _match_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _stack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,numpy.int32(__2))
  @staticmethod
  def _stack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2I(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),_2))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Constraint._hstack__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Constraint_2(_0):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,1))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Constraint_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Constraint_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Constraint._vstack__3Lmosek_4fusion_4Constraint_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Constraint_2(_0):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1,_2):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1):
    return mosek_fusion_Constraint._hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Constraint_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Constraint_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_t__0,_t__1):
    return mosek_fusion_Constraint._vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Constraint_2(_0,_1):
   return (mosek.fusion.Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Constraint_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Constraint._dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Constraint_2I(_0,_1):
   _2=None
   for _3 in range(0,int((_0).shape[0])):
    if (_2 is None): # src/fusion/Constraint.mbi:284:16-26
     _2 = _0[_3]._getModel_()
    elif (((_0[_3].__model) is not None) and ((_0[_3].__model) is not _2)): # src/fusion/Constraint.mbi:285:20-59
     _4=mosek.fusion.Utils.StringBuffer()
     _5=(_2._getName_() if ((int(len(_2._getName_())) > 0) ) else "?")
     _6=(_0[_3]._getModel_()._getName_() if ((int(len(_0[_3]._getModel_()._getName_())) > 0) ) else "?")
     _4._a_S("Constraints belong to different models: '")._a_S(_5)._a_S("' and '")._a_S(_6)._a_S("'")
     raise mosek_fusion_ModelError._ctor_S(_4._toString_())
   if (int((_0).shape[0])==0): # src/fusion/Constraint.mbi:296:12-23
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(None,numpy.array([0], dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
   elif (int((_0).shape[0])==1): # src/fusion/Constraint.mbi:297:16-27
    return (_0[1])
   else:
    _7=int((_0).shape[0])
    _8=1
    for _9 in range(0,_7):
     _8 = (_0[_9]._getND_() if ((_0[_9]._getND_() > _8) ) else _8)
    if (_1==_8): # src/fusion/Constraint.mbi:302:14-23
     _8 += 1
    _10=numpy.zeros((_7,_8,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_244(_7,_8,_10) # src/fusion/Constraint.mbi:303:38-92
    _11=numpy.array([_0[_12]._getSize_() for _12 in range(0,_7)], dtype=numpy.dtype(numpy.int32))
    _13=0
    _13 = fragments._c_closure_245(_7,_11,_13) # src/fusion/Constraint.mbi:306:28-68
    _13 = numpy.int32(_13) # postprocess
    for _14 in range(0,_7):
     _15=_0[_14]._getShape_()
     fragments._c_closure_246(_14,_10,_15) # src/fusion/Constraint.mbi:310:12-311:35
    if ((_1 < 0) or (_1 > _8)): # src/fusion/Constraint.mbi:314:14-33
     raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
    for _16 in range(0,_1):
     for _17 in range(1,_7):
      if (_10[0,_16]!=_10[_17,_16]): # src/fusion/Constraint.mbi:319:18-42
       raise mosek_fusion_DimensionError._ctor_S("Constraint dimensions do not match")
    for _18 in range((_1 + 1),_8):
     for _19 in range(1,_7):
      if (_10[0,_18]!=_10[_19,_18]): # src/fusion/Constraint.mbi:324:18-42
       raise mosek_fusion_DimensionError._ctor_S("Constraint dimensions do not match")
    _20=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _21=numpy.array([_10[0,_22] for _22 in range(0,_8)], dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_247(_1,_7,_21,_10) # src/fusion/Constraint.mbi:333:10-59
    _23=int((_21).shape[0])
    _24=numpy.zeros(((int((_0).shape[0]) + 1),), dtype=numpy.dtype(numpy.int64))
    for _25 in range(0,int((_0).shape[0])):
     _24[(_25 + 1)] = (_24[_25] + _10[_25,_1])
    if (_1==0): # src/fusion/Constraint.mbi:341:16-24
     _26=0
     for _27 in range(0,_7):
      _28=int(((_0[_27].__con_nativeidxs)).shape[0])
      mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0[_27].__con_nativeidxs),0,_20,_26,_28)
      _26 += _28
    else:
     _29=_monty.initJaggedArray([(_0[_30].__con_nativeidxs) for _30 in range(0,_7)], 1)
     if (_1 < _8): # src/fusion/Constraint.mbi:352:18-26
      _31=1
      _31 = fragments._c_closure_248(_31,_1,_21) # src/fusion/Constraint.mbi:354:28-70
      _31 = numpy.int32(_31) # postprocess
      _32=1
      _32 = fragments._c_closure_249(_32,_1,_8,_21) # src/fusion/Constraint.mbi:355:28-70
      _32 = numpy.int32(_32) # postprocess
      _33=0
      for _34 in range(0,_31):
       for _35 in range(0,_7):
        _36=0
        _37=_10[_35,_1]
        for _38 in range(0,_37):
         for _39 in range(0,_32):
          _20[_33] = (_0[_7].__con_nativeidxs)[(((_34 * _32) * _37) + _36)]
          _33 += 1
          _36 += 1
     else:
      fragments._c_closure_250(_20,_7,_8,_29,_21) # src/fusion/Constraint.mbi:372:19-380:15
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(_2,_21,_20))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   if (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/Constraint.mbi:253:12-35
    raise mosek_fusion_DimensionError._ctor_S("variable shape and slice do not match")
   else:
    for _1 in range(0,int((self.__shape).shape[0])):
     if ((_0[_1] < 0) or (_0[_1] > self.__shape[_1])): # src/fusion/Constraint.mbi:257:16-49
      raise mosek_fusion_IndexError._ctor_S("index is out of bounds")
    _2=int((self.__shape).shape[0])
    _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _3[(_2 - 1)] = 1
    fragments._c_closure_251(_2,self.__shape,_3) # src/fusion/Constraint.mbi:261:57-123
    _4=0
    _4 = fragments._c_closure_252(_0,_4,_2,_3) # src/fusion/Constraint.mbi:262:22-76
    _4 = numpy.int32(_4) # postprocess
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.array([self.__con_nativeidxs[_4]], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   if ((int((self.__shape).shape[0])==0) and (_0==0)): # src/fusion/Constraint.mbi:238:12-40
    return (self)
   elif (int((self.__shape).shape[0])!=1): # src/fusion/Constraint.mbi:240:16-31
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   elif ((_0 < 0) or (_0 > self.__shape[0])): # src/fusion/Constraint.mbi:242:16-41
    raise mosek_fusion_IndexError._ctor_S("Index is out of bounds")
   else:
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.array([self.__con_nativeidxs[_0]], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/Constraint.mbi:180:12-37
    raise mosek_fusion_SliceError._ctor_S("invalid slice")
   elif (int((_0).shape[0])!=int((self.__shape).shape[0])): # src/fusion/Constraint.mbi:182:16-41
    raise mosek_fusion_DimensionError._ctor_S("variable shape and slice do not match")
   else:
    for _2 in range(0,int((self.__shape).shape[0])):
     if ((_0[_2] < 0) or (_1[_2] > self.__shape[_2])): # src/fusion/Constraint.mbi:186:16-52
      raise mosek_fusion_IndexError._ctor_S("slice is out of bounds")
     elif (_0[_2] > _1[_2]): # src/fusion/Constraint.mbi:188:20-40
      raise mosek_fusion_SliceError._ctor_S("invalid slice")
    _3=int((self.__shape).shape[0])
    _4=numpy.array([(_1[_5] - _0[_5]) for _5 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
    _6=1
    _6 = fragments._c_closure_253(_0,_1,_3,_6) # src/fusion/Constraint.mbi:194:29-81
    _6 = numpy.int32(_6) # postprocess
    if (_6==0): # src/fusion/Constraint.mbi:195:14-28
     return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,_4,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
    else:
     _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_254(self.__con_nativeidxs,_0,_1,_3,self.__shape,_7,_6) # src/fusion/Constraint.mbi:199:12-226:13
     return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self._getModel_(),_4,_7))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (int((self.__shape).shape[0])!=1): # src/fusion/Constraint.mbi:167:12-27
    raise mosek_fusion_DimensionError._ctor_S("Variable shape and slice do not match")
   if ((_0==0) and (_1==self.__shape[0])): # src/fusion/Constraint.mbi:169:12-43
    return (self)
   elif ((_0 < 0) or (_1 > self.__shape[0])): # src/fusion/Constraint.mbi:171:16-44
    raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   elif (_0 > _1): # src/fusion/Constraint.mbi:173:16-28
    raise mosek_fusion_SliceError._ctor_S("Invalid slice")
   else:
    return (mosek_fusion_SliceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3I(self.__model,numpy.array([(_1 - _0)], dtype=numpy.dtype(numpy.int32)),numpy.array([self.__con_nativeidxs[_2] for _2 in range(_0,_1)], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   _0=1
   _0 = fragments._c_closure_255(self.__shape,_0) # src/fusion/Constraint.mbi:157:20-63
   _0 = numpy.int32(_0) # postprocess
   return numpy.int32(_0)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (numpy.array([self.__shape[_0] for _0 in range(0,int((self.__shape).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  def _getNativeidxs_alt_(self,):
    return self._getNativeidxs_()
  def _getNativeidxs_(self,):
   return (self.__con_nativeidxs)
 return Constraint
mosek_fusion_Constraint=__mk_mosek_fusion_Constraint()
del __mk_mosek_fusion_Constraint
#BEFORE CLASS
def __mk_mosek_fusion_SliceConstraint():
 class SliceConstraint(mosek_fusion_Constraint):
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SliceConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SliceConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SliceConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.SliceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceConstraint_2(c):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4SliceConstraint_2(c)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceConstraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_match_Lmosek_4fusion_4SliceConstraint_2__(c))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceConstraint_2(*args):
    if len(args) != 1: return False
    c, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(c))
  def _ctor_alt_init_Lmosek_4fusion_4SliceConstraint_2(self,c):
    self._ctor_init_Lmosek_4fusion_4SliceConstraint_2(c)
  def _ctor_init_Lmosek_4fusion_4SliceConstraint_2(self,c):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,c._getModel_())
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs):
    o = SliceConstraint.__new__(SliceConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,shape,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3I(*args):
    if len(args) != 3: return False
    model,shape,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nativeidxs)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SliceConstraint()")
   return (_0._toString_())
 return SliceConstraint
mosek_fusion_SliceConstraint=__mk_mosek_fusion_SliceConstraint()
del __mk_mosek_fusion_SliceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_BoundInterfaceConstraint():
 class BoundInterfaceConstraint(mosek_fusion_SliceConstraint):
  __slots__ = ['_BoundInterfaceConstraint__islower']
  def dual(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_dual_(*args): # 
      return self._dual_(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_dual_(*args): # 
      return self._dual_alt_(*args)
    else:
      raise ValueError('Invalid argument list dual('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.dual()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.slice(int32,int32)\n\tmosek.fusion.BoundInterfaceConstraint.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BoundInterfaceConstraint._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BoundInterfaceConstraint._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BoundInterfaceConstraint.index(int32)\n\tmosek.fusion.BoundInterfaceConstraint.index(array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.BoundInterfaceConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3IZ(m,shape,nativeidxs,islower):
    o = BoundInterfaceConstraint.__new__(BoundInterfaceConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(m,shape,nativeidxs,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3IZ(*args):
    if len(args) != 4: return False
    m,shape,nativeidxs,islower, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(m) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3IZ(*args):
    if len(args) != 4: return False
    m,shape,nativeidxs,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(m) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3IZ(self,m,shape,nativeidxs,islower):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(m,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),islower)
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3IZ(self,m,shape,nativeidxs,islower):
   mosek_fusion_SliceConstraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,m,shape,nativeidxs)
   (self.__islower) = islower
  @staticmethod
  def _ctor_Lmosek_4fusion_4SliceConstraint_2Z(c,islower):
    o = BoundInterfaceConstraint.__new__(BoundInterfaceConstraint)
    o._ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(c,islower)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4SliceConstraint_2Z(*args):
    if len(args) != 2: return False
    c,islower, = args
    return (__arg_match_Lmosek_4fusion_4SliceConstraint_2__(c) and __arg_match_Z__(islower))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4SliceConstraint_2Z(*args):
    if len(args) != 2: return False
    c,islower, = args
    return (__arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(c) and __arg_alt_match_Z__(islower))
  def _ctor_alt_init_Lmosek_4fusion_4SliceConstraint_2Z(self,c,islower):
    self._ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(c,islower)
  def _ctor_init_Lmosek_4fusion_4SliceConstraint_2Z(self,c,islower):
   mosek_fusion_SliceConstraint._ctor_init_Lmosek_4fusion_4SliceConstraint_2(self,c)
   (self.__islower) = islower
  @staticmethod
  def _match_dual_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_dual_(*args):
    if len(args) != 0: return False
    return True
  def _dual_alt_(self,):
    return self._dual_()
  def _dual_(self,):
   _0=numpy.zeros((self._getSize_(),), dtype=numpy.dtype(numpy.float64))
   self._dual_1lu_I_3DZ(0,_0,self.__islower)
   return (_0)
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   _2=mosek_fusion_Constraint._slice__3I_3I(self,_0,_1)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_2))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   _2=mosek_fusion_Constraint._slice_II(self,_0,_1)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_2))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   _1=mosek_fusion_Constraint._index__3I(self,_0)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_1))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   _1=mosek_fusion_Constraint._index_I(self,_0)
   return (self.__from_1_Lmosek_4fusion_4Constraint_2(_1))
  def __from_1_alt_Lmosek_4fusion_4Constraint_2(self,_t__0):
    return self.__from_1_Lmosek_4fusion_4Constraint_2(_0)
  def __from_1_Lmosek_4fusion_4Constraint_2(self,_0):
   _2=_0
   if   isinstance(_2,mosek_fusion_SliceConstraint):
    cc=_2
    return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4SliceConstraint_2Z(cc,self.__islower))
   else:
    cc=_2
    return (None)
 return BoundInterfaceConstraint
mosek_fusion_BoundInterfaceConstraint=__mk_mosek_fusion_BoundInterfaceConstraint()
del __mk_mosek_fusion_BoundInterfaceConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ModelConstraint():
 class ModelConstraint(mosek_fusion_Constraint):
  __slots__ = ['_ModelConstraint__conid','_ModelConstraint__shape','_ModelConstraint__modelcon_nativeidxs','_ModelConstraint__name']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.toString()')
  def remove(self,*args):
    if False: pass
    elif mosek_fusion_ModelConstraint._match_remove_(*args): # 
      return self._remove_(*args)
    elif mosek_fusion_ModelConstraint._match_alt_remove_(*args): # 
      return self._remove_alt_(*args)
    else:
      raise ValueError('Invalid argument list remove('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ModelConstraint.remove()')
  def __repr__(self): return 'mosek.fusion.ModelConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Constraint_2Lmosek_4fusion_4Model_2(self,c,m)
   (self.__conid) = (c.__conid)
   self.__name = (c.__name)
   self.__modelcon_nativeidxs = (c.__modelcon_nativeidxs)
   self.__shape = (c.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nidxs,conid):
    o = ModelConstraint.__new__(ModelConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nidxs,conid)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nidxs,conid, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match__3I__(nidxs) and __arg_match_I__(conid))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nidxs,conid, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nidxs) and __arg_alt_match_I__(conid))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid):
   mosek_fusion_Constraint._ctor_init_Lmosek_4fusion_4Model_2_3I_3I(self,model,shape,nidxs)
   (self.__name) = name
   (self.__modelcon_nativeidxs) = nidxs
   (self.__shape) = shape
   (self.__conid) = conid
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("Constraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   pass
  @staticmethod
  def _match_remove_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_remove_(*args):
    if len(args) != 0: return False
    return True
  def _remove_alt_(self,):
    return self._remove_()
  def _remove_(self,):
   self._getModel_()._removeConstraintBlock_I(self.__conid)
 return ModelConstraint
mosek_fusion_ModelConstraint=__mk_mosek_fusion_ModelConstraint()
del __mk_mosek_fusion_ModelConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearPSDConstraint():
 class LinearPSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearPSDConstraint__conedim','_LinearPSDConstraint__shape','_LinearPSDConstraint__conid','_LinearPSDConstraint__slackidxs','_LinearPSDConstraint__nativeidxs']
  def __repr__(self): return 'mosek.fusion.LinearPSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__slackidxs = (c.__slackidxs)
   self.__nativeidxs = (c.__nativeidxs)
   self.__conedim = (c.__conedim)
   self.__shape = (c.__shape)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,conid,shape,conedim,nativeidxs,slackidxs):
    o = LinearPSDConstraint.__new__(LinearPSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,conid,shape,conedim,nativeidxs,slackidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(*args):
    if len(args) != 7: return False
    model,name,conid,shape,conedim,nativeidxs,slackidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match_I__(conedim) and __arg_match__3I__(nativeidxs) and __arg_match__3J__(slackidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3II_3I_3J(*args):
    if len(args) != 7: return False
    model,name,conid,shape,conedim,nativeidxs,slackidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match__3J__(slackidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,model,name,conid,shape,conedim,nativeidxs,slackidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(slackidxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3II_3I_3J(self,model,name,conid,shape,conedim,nativeidxs,slackidxs):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid)
   (self.__conid) = conid
   (self.__slackidxs) = slackidxs
   (self.__nativeidxs) = nativeidxs
   (self.__conedim) = conedim
   (self.__shape) = shape
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   _2=mosek.fusion.Set._idxtokey__3IJ(self.__shape,_0)
   _1._a_S(" : element (")._a_I(_2[0])
   for _3 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(_2[_3])
   _1._a_S(") in a positive semi-definite cone of size (")._a_I(self.__shape[0])
   for _4 in range(1,int((_2).shape[0])):
    _1._a_S(",")._a_I(self.__shape[_4])
   _1._a_S(")")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearPSDConstraint._ctor_Lmosek_4fusion_4LinearPSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearPSDConstraint
mosek_fusion_LinearPSDConstraint=__mk_mosek_fusion_LinearPSDConstraint()
del __mk_mosek_fusion_LinearPSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_PSDConstraint():
 class PSDConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_PSDConstraint__names_flushed','_PSDConstraint__conedim1','_PSDConstraint__conedim0','_PSDConstraint__shape','_PSDConstraint__name','_PSDConstraint__slackidxs','_PSDConstraint__nativeidxs','_PSDConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_PSDConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_PSDConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.PSDConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__name = (c.__name)
   self.__shape = (c.__shape)
   self.__slackidxs = (c.__slackidxs)
   self.__nativeidxs = (c.__nativeidxs)
   self.__names_flushed = (c.__names_flushed)
   self.__conedim0 = (c.__conedim0)
   self.__conedim1 = (c.__conedim1)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
    o = PSDConstraint.__new__(PSDConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(*args):
    if len(args) != 8: return False
    model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match_I__(conedim0) and __arg_match_I__(conedim1) and __arg_match__3J__(slackidxs) and __arg_match__3I__(nativeidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3III_3J_3I(*args):
    if len(args) != 8: return False
    model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conedim0) and __arg_alt_match_I__(conedim1) and __arg_alt_match__3J__(slackidxs) and __arg_alt_match__3I__(nativeidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim0),numpy.int32(conedim1),numpy.array(slackidxs,dtype=numpy.dtype(numpy.int64)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3III_3J_3I(self,model,name,conid,shape,conedim0,conedim1,slackidxs,nativeidxs):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,mosek.fusion.PSDConstraint.__computenidxs__3III_3I(shape,conedim0,conedim1,nativeidxs),conid)
   (self.__conid) = conid
   (self.__nativeidxs) = nativeidxs
   (self.__slackidxs) = slackidxs
   (self.__name) = name
   (self.__shape) = shape
   (self.__conedim0) = conedim0
   (self.__conedim1) = conedim1
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   raise mosek_fusion_UnimplementedError._ctor_S("PSDConstraint.toString not implemented")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_PSDConstraint._ctor_Lmosek_4fusion_4PSDConstraint_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def __computenidxs_alt__3III_3I(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_PSDConstraint.__computenidxs__3III_3I(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computenidxs__3III_3I(_0,_1,_2,_3):
   _4=int((_0).shape[0])
   _5=(_1 < _2)
   _6=(_1 if (_5 ) else _2)
   _7=(_2 if (_5 ) else _1)
   _8=numpy.array([1,1,1,1,1], dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _10=1
   _10 = fragments._c_closure_256(_0,_10) # src/fusion/SemidefiniteConstraint.mbi:39:22-67
   _10 = numpy.int32(_10) # postprocess
   fragments._c_closure_257(_6,_8,_0) # src/fusion/SemidefiniteConstraint.mbi:41:8-53
   _8[1] = _0[_6]
   fragments._c_closure_258(_6,_7,_8,_0) # src/fusion/SemidefiniteConstraint.mbi:43:8-62
   _8[3] = _0[_7]
   fragments._c_closure_259(_7,_8,_4,_0) # src/fusion/SemidefiniteConstraint.mbi:45:8-56
   _9[4] = 1
   fragments._c_closure_260(_8,_9) # src/fusion/SemidefiniteConstraint.mbi:46:23-81
   _11=numpy.zeros((_10,), dtype=numpy.dtype(numpy.int32))
   _12=0
   _12 = fragments._c_closure_261(_8,_12,_3,_11,_9,_5) # src/fusion/SemidefiniteConstraint.mbi:51:8-70:19
   _12 = numpy.int32(_12) # postprocess
   return (_11)
 return PSDConstraint
mosek_fusion_PSDConstraint=__mk_mosek_fusion_PSDConstraint()
del __mk_mosek_fusion_PSDConstraint
#BEFORE CLASS
def __mk_mosek_fusion_RangedConstraint():
 class RangedConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_RangedConstraint__nativeidxs','_RangedConstraint__shape']
  def upperBoundCon(self,*args):
    if False: pass
    elif mosek_fusion_RangedConstraint._match_upperBoundCon_(*args): # 
      return self._upperBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_upperBoundCon_(*args): # 
      return self._upperBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list upperBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.upperBoundCon()')
  def lowerBoundCon(self,*args):
    if False: pass
    elif mosek_fusion_RangedConstraint._match_lowerBoundCon_(*args): # 
      return self._lowerBoundCon_(*args)
    elif mosek_fusion_RangedConstraint._match_alt_lowerBoundCon_(*args): # 
      return self._lowerBoundCon_alt_(*args)
    else:
      raise ValueError('Invalid argument list lowerBoundCon('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangedConstraint.lowerBoundCon()')
  def __repr__(self): return 'mosek.fusion.RangedConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__shape = (c.__shape)
   self.__nativeidxs = (c.__nativeidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nativeidxs,conid):
    o = RangedConstraint.__new__(RangedConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,shape,nativeidxs,conid)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nativeidxs,conid, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match__3I__(shape) and __arg_match__3I__(nativeidxs) and __arg_match_I__(conid))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2S_3I_3II(*args):
    if len(args) != 5: return False
    model,name,shape,nativeidxs,conid, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match_I__(conid))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid):
    self._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(model,name,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid))
  def _ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nativeidxs,conid)
   (self.__shape) = shape
   (self.__nativeidxs) = nativeidxs
  @staticmethod
  def _match_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_upperBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _upperBoundCon_alt_(self,):
    return self._upperBoundCon_()
  def _upperBoundCon_(self,):
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3IZ(self._getModel_(),self.__shape,self.__nativeidxs,False))
  @staticmethod
  def _match_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_lowerBoundCon_(*args):
    if len(args) != 0: return False
    return True
  def _lowerBoundCon_alt_(self,):
    return self._lowerBoundCon_()
  def _lowerBoundCon_(self,):
   return (mosek_fusion_BoundInterfaceConstraint._ctor_Lmosek_4fusion_4Model_2_3I_3IZ(self._getModel_(),self.__shape,self.__nativeidxs,True))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_RangedConstraint._ctor_Lmosek_4fusion_4RangedConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return RangedConstraint
mosek_fusion_RangedConstraint=__mk_mosek_fusion_RangedConstraint()
del __mk_mosek_fusion_RangedConstraint
#BEFORE CLASS
def __mk_mosek_fusion_ConicConstraint():
 class ConicConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_ConicConstraint__indexnames','_ConicConstraint__nativeidxs','_ConicConstraint__names_flushed','_ConicConstraint__name','_ConicConstraint__shape','_ConicConstraint__dom','_ConicConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ConicConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ConicConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConicConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.ConicConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__dom = (c.__dom)
   self.__conid = (c.__conid)
   self.__shape = (c.__shape)
   self.__name = (c.__name)
   self.__nativeidxs = (c.__nativeidxs)
   self.__names_flushed = (c.__names_flushed)
   self.__indexnames = (c.__indexnames)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(model,name,dom,shape,conid,nativeidxs,indexnames):
    o = ConicConstraint.__new__(ConicConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(model,name,dom,shape,conid,nativeidxs,indexnames)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(*args):
    if len(args) != 7: return False
    model,name,dom,shape,conid,nativeidxs,indexnames, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_Lmosek_4fusion_4ConeDomain_2__(dom) and __arg_match__3I__(shape) and __arg_match_I__(conid) and __arg_match__3I__(nativeidxs) and __arg_match__3_3S__(indexnames))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(*args):
    if len(args) != 7: return False
    model,name,dom,shape,conid,nativeidxs,indexnames, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(dom) and __arg_alt_match__3I__(shape) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(nativeidxs) and __arg_alt_match__3_3S__(indexnames))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(self,model,name,dom,shape,conid,nativeidxs,indexnames):
    self._ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(model,name,dom,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.int32(conid),numpy.array(nativeidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(indexnames,dtype=numpy.dtype(object)))
  def _ctor_init_Lmosek_4fusion_4Model_2SLmosek_4fusion_4ConeDomain_2_3II_3I_3_3S(self,model,name,dom,shape,conid,nativeidxs,indexnames):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,numpy.array([(- (1 + nativeidxs[_0])) for _0 in range(0,int((nativeidxs).shape[0]))], dtype=numpy.dtype(numpy.int32)),(- (1 + conid)))
   (self.__dom) = dom
   (self.__shape) = shape
   (self.__name) = name
   (self.__nativeidxs) = nativeidxs
   (self.__indexnames) = indexnames
   (self.__conid) = conid
   self.__names_flushed = False
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("ConicConstraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   raise mosek_fusion_UnimplementedError._ctor_S("ConicConstraint.domainToString")
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ConicConstraint._ctor_Lmosek_4fusion_4ConicConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return ConicConstraint
mosek_fusion_ConicConstraint=__mk_mosek_fusion_ConicConstraint()
del __mk_mosek_fusion_ConicConstraint
#BEFORE CLASS
def __mk_mosek_fusion_LinearConstraint():
 class LinearConstraint(mosek_fusion_ModelConstraint):
  __slots__ = ['_LinearConstraint__indexnames','_LinearConstraint__names_flushed','_LinearConstraint__nidxs','_LinearConstraint__name','_LinearConstraint__conid']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_LinearConstraint._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_LinearConstraint._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearConstraint.toString()')
  def __repr__(self): return 'mosek.fusion.LinearConstraint'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_match_Lmosek_4fusion_4Model_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    c,m, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(c) and __arg_alt_match_Lmosek_4fusion_4Model_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
    self._ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(c,m)
  def _ctor_init_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,c,m):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4ModelConstraint_2Lmosek_4fusion_4Model_2(self,c,m)
   self.__conid = (c.__conid)
   self.__name = (c.__name)
   self.__nidxs = mosek.fusion.Utils.Tools._arraycopy__3I((c.__nidxs))
   self.__names_flushed = (c.__names_flushed)
   self.__indexnames = (c.__indexnames)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(model,name,conid,shape,nidxs,indexnames):
    o = LinearConstraint.__new__(LinearConstraint)
    o._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(model,name,conid,shape,nidxs,indexnames)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(*args):
    if len(args) != 6: return False
    model,name,conid,shape,nidxs,indexnames, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match_S__(name) and __arg_match_I__(conid) and __arg_match__3I__(shape) and __arg_match__3I__(nidxs) and __arg_match__3_3S__(indexnames))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(*args):
    if len(args) != 6: return False
    model,name,conid,shape,nidxs,indexnames, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match_S__(name) and __arg_alt_match_I__(conid) and __arg_alt_match__3I__(shape) and __arg_alt_match__3I__(nidxs) and __arg_alt_match__3_3S__(indexnames))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(self,model,name,conid,shape,nidxs,indexnames):
    self._ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(model,name,numpy.int32(conid),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)),numpy.array(indexnames,dtype=numpy.dtype(object)))
  def _ctor_init_Lmosek_4fusion_4Model_2SI_3I_3I_3_3S(self,model,name,conid,shape,nidxs,indexnames):
   mosek_fusion_ModelConstraint._ctor_init_Lmosek_4fusion_4Model_2S_3I_3II(self,model,name,shape,nidxs,conid)
   (self.__nidxs) = nidxs
   (self.__conid) = conid
   (self.__name) = name
   (self.__names_flushed) = False
   (self.__indexnames) = indexnames
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("LinearConstraint('")._a_S(self.__name)._a_S("')")
   return (_0._toString_())
  def _flushNames_alt_(self,):
    return self._flushNames_()
  def _flushNames_(self,):
   pass
  def _domainToString_alt_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_t__0,_t__1):
    return self._domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(numpy.int64(__0),_1)
  def _domainToString_JLmosek_4fusion_4Utils_4StringBuffer_2(self,_0,_1):
   pass
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_LinearConstraint._ctor_Lmosek_4fusion_4LinearConstraint_2Lmosek_4fusion_4Model_2(self,_0))
 return LinearConstraint
mosek_fusion_LinearConstraint=__mk_mosek_fusion_LinearConstraint()
del __mk_mosek_fusion_LinearConstraint
#BEFORE CLASS
def __mk_mosek_fusion_Set():
 class Set(object):
  @staticmethod
  def linearidx(*args):
    if False: pass
    elif mosek_fusion_Set._match_linearidx__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._linearidx__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_linearidx__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._linearidx_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list linearidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.linearidx(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def indexToKey(*args):
    if False: pass
    elif mosek_fusion_Set._match_indexToKey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._indexToKey__3IJ_3I(*args)
    elif mosek_fusion_Set._match_alt_indexToKey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._indexToKey_alt__3IJ_3I(*args)
    else:
      raise ValueError('Invalid argument list indexToKey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToKey(array(int32,ndim=1),int64,array(int32,ndim=1))')
  @staticmethod
  def size(*args):
    if False: pass
    elif mosek_fusion_Set._match_size__3I(*args): # []int32
      return mosek_fusion_Set._size__3I(*args)
    elif mosek_fusion_Set._match_alt_size__3I(*args): # []int32
      return mosek_fusion_Set._size_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list size('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.size(array(int32,ndim=1))')
  @staticmethod
  def keyToString(*args):
    if False: pass
    elif mosek_fusion_Set._match_keyToString__3I(*args): # []int32
      return mosek_fusion_Set._keyToString__3I(*args)
    elif mosek_fusion_Set._match_alt_keyToString__3I(*args): # []int32
      return mosek_fusion_Set._keyToString_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list keyToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.keyToString(array(int32,ndim=1))')
  @staticmethod
  def match(*args):
    if False: pass
    elif mosek_fusion_Set._match_match__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._match__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_match__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._match_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list match('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.match(array(int32,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def indexToString(*args):
    if False: pass
    elif mosek_fusion_Set._match_indexToString__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._indexToString__3IJ(*args)
    elif mosek_fusion_Set._match_alt_indexToString__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._indexToString_alt__3IJ(*args)
    else:
      raise ValueError('Invalid argument list indexToString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.indexToString(array(int32,ndim=1),int64)')
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_Set._match_make__3S(*args): # []string
      return mosek_fusion_Set._make__3S(*args)
    elif mosek_fusion_Set._match_alt_make__3S(*args): # []string
      return mosek_fusion_Set._make_alt__3S(*args)
    elif mosek_fusion_Set._match_make_I(*args): # int32
      return mosek_fusion_Set._make_I(*args)
    elif mosek_fusion_Set._match_alt_make_I(*args): # int32
      return mosek_fusion_Set._make_alt_I(*args)
    elif mosek_fusion_Set._match_make__3I(*args): # []int32
      return mosek_fusion_Set._make__3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I(*args): # []int32
      return mosek_fusion_Set._make_alt__3I(*args)
    elif mosek_fusion_Set._match_make__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._make__3I_3I(*args)
    elif mosek_fusion_Set._match_alt_make__3I_3I(*args): # []int32,[]int32
      return mosek_fusion_Set._make_alt__3I_3I(*args)
    elif mosek_fusion_Set._match_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_II(*args)
    elif mosek_fusion_Set._match_alt_make_II(*args): # int32,int32
      return mosek_fusion_Set._make_alt_II(*args)
    elif mosek_fusion_Set._match_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_III(*args)
    elif mosek_fusion_Set._match_alt_make_III(*args): # int32,int32,int32
      return mosek_fusion_Set._make_alt_III(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.make(array(string,ndim=1))\n\tmosek.fusion.Set.make(int32)\n\tmosek.fusion.Set.make(array(int32,ndim=1))\n\tmosek.fusion.Set.make(array(int32,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Set.make(int32,int32)\n\tmosek.fusion.Set.make(int32,int32,int32)')
  @staticmethod
  def strides(*args):
    if False: pass
    elif mosek_fusion_Set._match_strides__3I(*args): # []int32
      return mosek_fusion_Set._strides__3I(*args)
    elif mosek_fusion_Set._match_alt_strides__3I(*args): # []int32
      return mosek_fusion_Set._strides_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list strides('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.strides(array(int32,ndim=1))')
  @staticmethod
  def scalar(*args):
    if False: pass
    elif mosek_fusion_Set._match_scalar_(*args): # 
      return mosek_fusion_Set._scalar_(*args)
    elif mosek_fusion_Set._match_alt_scalar_(*args): # 
      return mosek_fusion_Set._scalar_alt_(*args)
    else:
      raise ValueError('Invalid argument list scalar('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.scalar()')
  @staticmethod
  def idxtokey(*args):
    if False: pass
    elif mosek_fusion_Set._match_idxtokey__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._idxtokey__3IJ(*args)
    elif mosek_fusion_Set._match_alt_idxtokey__3IJ(*args): # []int32,int64
      return mosek_fusion_Set._idxtokey_alt__3IJ(*args)
    elif mosek_fusion_Set._match_idxtokey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._idxtokey__3IJ_3I(*args)
    elif mosek_fusion_Set._match_alt_idxtokey__3IJ_3I(*args): # []int32,int64,[]int32
      return mosek_fusion_Set._idxtokey_alt__3IJ_3I(*args)
    else:
      raise ValueError('Invalid argument list idxtokey('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Set.idxtokey(array(int32,ndim=1),int64)\n\tmosek.fusion.Set.idxtokey(array(int32,ndim=1),int64,array(int32,ndim=1))')
  def __repr__(self): return 'mosek.fusion.Set'
  @staticmethod
  def _match_size__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_size__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _size_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._size__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _size__3I(_0):
   _1=1
   _1 = fragments._c_closure_262(_0,_1) # src/fusion/Set.mbi:205:21-64
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def _match_match__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_match__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _match_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._match__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _match__3I_3I(_0,_1):
   if (int((_0).shape[0])!=int((_1).shape[0])): # src/fusion/Set.mbi:196:12-30
    return (False)
   for _2 in range(0,int((_0).shape[0])):
    if (_0[_2]!=_1[_2]): # src/fusion/Set.mbi:198:14-28
     return (False)
   return (True)
  @staticmethod
  def _match_linearidx__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_linearidx__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _linearidx_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._linearidx__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _linearidx__3I_3I(_0,_1):
   _2=_1[0]
   _2 = fragments._c_closure_263(_1,_2,_0) # src/fusion/Set.mbi:189:8-190:40
   _2 = numpy.int64(_2) # postprocess
   return numpy.int64(_2)
  @staticmethod
  def _match_idxtokey__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_idxtokey__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _idxtokey_alt__3IJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_Set._idxtokey__3IJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _idxtokey__3IJ(_0,_1):
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Set._idxtokey__3IJ_3I(_0,_1,_2)
   return (_2)
  @staticmethod
  def _match_idxtokey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_idxtokey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _idxtokey_alt__3IJ_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._idxtokey__3IJ_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _idxtokey__3IJ_3I(_0,_1,_2):
   fragments._c_closure_264(_2,_1,_0) # src/fusion/Set.mbi:155:6-167:7
  @staticmethod
  def _match_indexToString__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1))
  @staticmethod
  def _match_alt_indexToString__3IJ(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1))
  @staticmethod
  def _indexToString_alt__3IJ(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _1 = mosek_fusion_Set._indexToString__3IJ(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _indexToString__3IJ(_0,_1):
   _2=int((_0).shape[0])
   _3=mosek.fusion.Utils.StringBuffer()
   if (_2==0): # src/fusion/Set.mbi:128:12-19
    return ("0")
   elif (_2==1): # src/fusion/Set.mbi:130:16-23
    return (_3._a_J(_1)._toString_())
   else:
    _4=_1
    _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _4 = fragments._c_closure_265(_5,_2,_4,_0) # src/fusion/Set.mbi:136:10-139:11
    _4 = numpy.int64(_4) # postprocess
    _5[0] = numpy.int32(_4)
    _3._a_I(_5[0])
    for _6 in range(1,_2):
     _3._a_S(",")._a_I(_5[_6])
    return (_3._toString_())
  @staticmethod
  def _match_keyToString__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_keyToString__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _keyToString_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._keyToString__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _keyToString__3I(_0):
   _1=mosek.fusion.Utils.StringBuffer()
   _1._a_I(_0[0])
   for _2 in range(1,int((_0).shape[0])):
    _1._a_S(",")._a_I(_0[_2])
   return (_1._toString_())
  @staticmethod
  def _match_indexToKey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_J__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_indexToKey__3IJ_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_J__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _indexToKey_alt__3IJ_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._indexToKey__3IJ_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _indexToKey__3IJ_3I(_0,_1,_2):
   fragments._c_closure_266(_1,_2,_0) # src/fusion/Set.mbi:93:6-107:7
  @staticmethod
  def _match_strides__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_strides__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _strides_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._strides__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _strides__3I(_0):
   _1=int((_0).shape[0])
   _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
   _2[(_1 - 1)] = 1
   fragments._c_closure_267(_1,_0,_2) # src/fusion/Set.mbi:85:8-64
   return (_2)
  @staticmethod
  def _match_make__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_make__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _make_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._make__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3I(_0,_1):
   _2=numpy.zeros(((int((_0).shape[0]) + int((_1).shape[0])),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_268(_2,_0) # src/fusion/Set.mbi:69:8-50
   fragments._c_closure_269(_2,_0,_1) # src/fusion/Set.mbi:70:8-60
   return (_2)
  @staticmethod
  def _match_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_make__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _make_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Set._make__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I(_0):
   return (numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_make_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _make_alt_III(_t__0,_t__1,_t__2):
    return mosek_fusion_Set._make_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _make_III(_0,_1,_2):
   return (numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_make_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _make_alt_II(_t__0,_t__1):
    return mosek_fusion_Set._make_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _make_II(_0,_1):
   return (numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_make_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _make_alt_I(_t__0):
    return mosek_fusion_Set._make_I(numpy.int32(__0))
  @staticmethod
  def _make_I(_0):
   return (numpy.array([_0], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_scalar_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _scalar_alt_():
    return mosek_fusion_Set._scalar_()
  @staticmethod
  def _scalar_():
   return (numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3S__(_0))
  @staticmethod
  def _match_alt_make__3S(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3S__(_0))
  @staticmethod
  def _make_alt__3S(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Set._make__3S(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3S(_0):
   return (numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)))
 return Set
mosek_fusion_Set=__mk_mosek_fusion_Set()
del __mk_mosek_fusion_Set
#BEFORE CLASS
def __mk_mosek_fusion_ConeDomain():
 class ConeDomain(object):
  __slots__ = ['_indexnames','_domsize','_domofs','_alpha','_shape','_int_flag','_axisset','_axisidx','_key']
  def withShape(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_withShape__3I(*args): # []int32
      return self._withShape__3I(*args)
    elif mosek_fusion_ConeDomain._match_alt_withShape__3I(*args): # []int32
      return self._withShape_alt__3I(*args)
    elif mosek_fusion_ConeDomain._match_withShape_I(*args): # int32
      return self._withShape_I(*args)
    elif mosek_fusion_ConeDomain._match_alt_withShape_I(*args): # int32
      return self._withShape_alt_I(*args)
    elif mosek_fusion_ConeDomain._match_withShape_II(*args): # int32,int32
      return self._withShape_II(*args)
    elif mosek_fusion_ConeDomain._match_alt_withShape_II(*args): # int32,int32
      return self._withShape_alt_II(*args)
    elif mosek_fusion_ConeDomain._match_withShape_III(*args): # int32,int32,int32
      return self._withShape_III(*args)
    elif mosek_fusion_ConeDomain._match_alt_withShape_III(*args): # int32,int32,int32
      return self._withShape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.withShape(array(int32,ndim=1))\n\tmosek.fusion.ConeDomain.withShape(int32)\n\tmosek.fusion.ConeDomain.withShape(int32,int32)\n\tmosek.fusion.ConeDomain.withShape(int32,int32,int32)')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_ConeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.integral()')
  def withNamesOnAxis(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_withNamesOnAxis__3SI(*args): # []string,int32
      return self._withNamesOnAxis__3SI(*args)
    elif mosek_fusion_ConeDomain._match_alt_withNamesOnAxis__3SI(*args): # []string,int32
      return self._withNamesOnAxis_alt__3SI(*args)
    else:
      raise ValueError('Invalid argument list withNamesOnAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.withNamesOnAxis(array(string,ndim=1),int32)')
  def axis(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_axis_I(*args): # int32
      return self._axis_I(*args)
    elif mosek_fusion_ConeDomain._match_alt_axis_I(*args): # int32
      return self._axis_alt_I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.axis(int32)')
  def getAxis(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_getAxis_(*args): # 
      return self._getAxis_(*args)
    elif mosek_fusion_ConeDomain._match_alt_getAxis_(*args): # 
      return self._getAxis_alt_(*args)
    else:
      raise ValueError('Invalid argument list getAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.getAxis()')
  def axisIsSet(self,*args):
    if False: pass
    elif mosek_fusion_ConeDomain._match_axisIsSet_(*args): # 
      return self._axisIsSet_(*args)
    elif mosek_fusion_ConeDomain._match_alt_axisIsSet_(*args): # 
      return self._axisIsSet_alt_(*args)
    else:
      raise ValueError('Invalid argument list axisIsSet('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ConeDomain.axisIsSet()')
  def __repr__(self): return 'mosek.fusion.ConeDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2_3D_3I(k,alpha,d):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2_3D_3I(k,alpha,d)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2_3D_3I(*args):
    if len(args) != 3: return False
    k,alpha,d, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match__3D__(alpha) and __arg_match__3I__(d))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2_3D_3I(*args):
    if len(args) != 3: return False
    k,alpha,d, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match__3D__(alpha) and __arg_alt_match__3I__(d))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2_3D_3I(self,k,alpha,d):
    self._ctor_init_Emosek_4fusion_4QConeKey_2_3D_3I(k,numpy.array(alpha,dtype=numpy.dtype(numpy.float64)),numpy.array(d,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4QConeKey_2_3D_3I(self,k,alpha,d):
   self._shape = (mosek.fusion.Utils.Tools._arraycopy__3I(d) if ((d is not None) ) else None)
   self._domsize = 0
   (self._alpha) = alpha
   self._key = k
   self._axisidx = 0
   self._axisset = False
   self._int_flag = False
   self._domofs = None
   self._indexnames = None
  @staticmethod
  def _ctor_Emosek_4fusion_4QConeKey_2_3I(k,d):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Emosek_4fusion_4QConeKey_2_3I(k,d)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4QConeKey_2_3I(*args):
    if len(args) != 2: return False
    k,d, = args
    return (__arg_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_match__3I__(d))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4QConeKey_2_3I(*args):
    if len(args) != 2: return False
    k,d, = args
    return (__arg_alt_match_Emosek_4fusion_4QConeKey_2__(k) and __arg_alt_match__3I__(d))
  def _ctor_alt_init_Emosek_4fusion_4QConeKey_2_3I(self,k,d):
    self._ctor_init_Emosek_4fusion_4QConeKey_2_3I(k,numpy.array(d,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4QConeKey_2_3I(self,k,d):
   mosek_fusion_ConeDomain._ctor_init_Emosek_4fusion_4QConeKey_2_3D_3I(self,k,None,d)
  @staticmethod
  def _ctor_Lmosek_4fusion_4ConeDomain_2(other):
    o = ConeDomain.__new__(ConeDomain)
    o._ctor_init_Lmosek_4fusion_4ConeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4ConeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4ConeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4ConeDomain_2(self,other):
   self._key = (other._key)
   self._axisidx = (other._axisidx)
   self._axisset = (other._axisset)
   self._int_flag = (other._int_flag)
   self._shape = (other._shape)
   self._alpha = (other._alpha)
   self._domofs = (other._domofs)
   self._domsize = (other._domsize)
   self._indexnames = (other._indexnames)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   return (((self._shape is None) or mosek.fusion.Set._match__3I_3I(_0,self._shape)))
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._int_flag = True
   return (self)
  @staticmethod
  def _match_axisIsSet_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_axisIsSet_(*args):
    if len(args) != 0: return False
    return True
  def _axisIsSet_alt_(self,):
    return self._axisIsSet_()
  def _axisIsSet_(self,):
   return (self._axisset)
  @staticmethod
  def _match_getAxis_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getAxis_(*args):
    if len(args) != 0: return False
    return True
  def _getAxis_alt_(self,):
    return self._getAxis_()
  def _getAxis_(self,):
   return numpy.int32(self._axisidx)
  @staticmethod
  def _match_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_axis_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _axis_alt_I(self,_t__0):
    return self._axis_I(numpy.int32(__0))
  def _axis_I(self,_0):
   self._axisidx = _0
   self._axisset = True
   return (self)
  @staticmethod
  def _match_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _withShape_alt_III(self,_t__0,_t__1,_t__2):
    return self._withShape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _withShape_III(self,_0,_1,_2):
   return (self.__withShape_1__3I(numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _withShape_alt_II(self,_t__0,_t__1):
    return self._withShape_II(numpy.int32(__0),numpy.int32(__1))
  def _withShape_II(self,_0,_1):
   return (self.__withShape_1__3I(numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _withShape_alt_I(self,_t__0):
    return self._withShape_I(numpy.int32(__0))
  def _withShape_I(self,_0):
   return (self.__withShape_1__3I(numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _withShape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._withShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withShape__3I(self,_0):
   return (self.__withShape_1__3I(mosek.fusion.Utils.Tools._arraycopy__3I(_0)))
  def __withShape_1_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__withShape_1__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __withShape_1__3I(self,_0):
   self._shape = _0
   return (self)
  @staticmethod
  def _match_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3S__(_0) and __arg_alt_match_I__(_1))
  def _withNamesOnAxis_alt__3SI(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = self._withNamesOnAxis__3SI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withNamesOnAxis__3SI(self,_0,_1):
   if (_0 is None): # src/fusion/domain.mbi:1739:12-25
    self._indexnames = numpy.zeros(((_1 + 1),), dtype=numpy.dtype(object))
    self._indexnames[_1] = numpy.array([_0[_2] for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   if (int((self._indexnames).shape[0]) < (_1 + 1)): # src/fusion/domain.mbi:1744:12-36
    _3=numpy.ndarray((_1,), dtype=numpy.dtype(object))
    for _4 in range(0,int((self._indexnames).shape[0])):
     _3[_4] = self._indexnames[_4]
    self._indexnames = _3
   self._indexnames[_1] = numpy.array([_0[_5] for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (self)
  def __finalize_1and_1validate_1inplace_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__finalize_1and_1validate_1inplace__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __finalize_1and_1validate_1inplace__3I(self,_0):
   self._domsize = 1
   if (self._shape is None): # src/fusion/domain.mbi:1665:12-25
    if (_0 is not None): # src/fusion/domain.mbi:1666:14-25
     self._shape = _0
    else:
     raise mosek_fusion_DimensionError._ctor_S("Missing domain shape")
   elif (_0 is not None): # src/fusion/domain.mbi:1671:16-27
    if (int((_0).shape[0])!=int((self._shape).shape[0])): # src/fusion/domain.mbi:1672:14-36
     raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
    for _1 in range(0,int((_0).shape[0])):
     if (_0[_1]!=self._shape[_1]): # src/fusion/domain.mbi:1675:16-34
      raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
   self._domsize = fragments._c_closure_270(self._domsize,self._shape) # src/fusion/domain.mbi:1678:8-56
   self._domsize = numpy.int64(self._domsize) # postprocess
   if (self._indexnames is not None): # src/fusion/domain.mbi:1680:12-30
    if (int((self._indexnames).shape[0])!=int((self._shape).shape[0])): # src/fusion/domain.mbi:1681:14-43
     raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
    for _2 in range(0,int((self._shape).shape[0])):
     if ((self._indexnames[_2] is not None) and (int((self._indexnames[_2]).shape[0])!=self._shape[_2])): # src/fusion/domain.mbi:1684:16-72
      raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
   if (not self._axisset): # src/fusion/domain.mbi:1688:12-23
    self._axisset = True
    self._axisidx = (int((self._shape).shape[0]) - 1)
   elif ((self._axisidx < 0) or (self._axisidx >= int((self._shape).shape[0]))): # src/fusion/domain.mbi:1692:16-52
    raise mosek_fusion_DimensionError._ctor_S("Cone axis is invalid")
   if ((self._domofs is not None) and (int((self._domofs).shape[0])!=self._domsize)): # src/fusion/domain.mbi:1695:12-53
    raise mosek_fusion_DimensionError._ctor_S("Domain offset does not match shape")
  def _finalize_1and_1validate_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._finalize_1and_1validate__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _finalize_1and_1validate__3I(self,_0):
   _1=mosek_fusion_ConeDomain._ctor_Lmosek_4fusion_4ConeDomain_2(self)
   _1.__finalize_1and_1validate_1inplace__3I(_0)
   return (_1)
 return ConeDomain
mosek_fusion_ConeDomain=__mk_mosek_fusion_ConeDomain()
del __mk_mosek_fusion_ConeDomain
#BEFORE CLASS
def __mk_mosek_fusion_PSDDomain():
 class PSDDomain(object):
  __slots__ = ['_indexnames','_axisIsSet','_conedim2','_conedim1','_key','_shape']
  def axis(self,*args):
    if False: pass
    elif mosek_fusion_PSDDomain._match_axis_II(*args): # int32,int32
      return self._axis_II(*args)
    elif mosek_fusion_PSDDomain._match_alt_axis_II(*args): # int32,int32
      return self._axis_alt_II(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDDomain.axis(int32,int32)')
  def withNamesOnAxis(self,*args):
    if False: pass
    elif mosek_fusion_PSDDomain._match_withNamesOnAxis__3SI(*args): # []string,int32
      return self._withNamesOnAxis__3SI(*args)
    elif mosek_fusion_PSDDomain._match_alt_withNamesOnAxis__3SI(*args): # []string,int32
      return self._withNamesOnAxis_alt__3SI(*args)
    else:
      raise ValueError('Invalid argument list withNamesOnAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.PSDDomain.withNamesOnAxis(array(string,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.PSDDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2_3III(k,shp,conedim1,conedim2):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2_3III(k,shp,conedim1,conedim2)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2_3III(*args):
    if len(args) != 4: return False
    k,shp,conedim1,conedim2, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match__3I__(shp) and __arg_match_I__(conedim1) and __arg_match_I__(conedim2))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2_3III(*args):
    if len(args) != 4: return False
    k,shp,conedim1,conedim2, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match__3I__(shp) and __arg_alt_match_I__(conedim1) and __arg_alt_match_I__(conedim2))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,conedim1,conedim2):
    self._ctor_init_Emosek_4fusion_4PSDKey_2_3III(k,numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.int32(conedim1),numpy.int32(conedim2))
  def _ctor_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,conedim1,conedim2):
   self._axisIsSet = True
   self._shape = shp
   self._key = k
   (self._conedim1) = conedim1
   (self._conedim2) = conedim2
   self._indexnames = None
   _0=int((self._shape).shape[0])
   if ((not ((int((self._shape).shape[0]) > conedim1) and ((int((self._shape).shape[0]) > conedim2) and ((conedim1 >= 0) and ((conedim2 >= 0) and (conedim1!=conedim2)))))) and (self._shape[conedim1]==self._shape[conedim2])): # src/fusion/domain.mbi:1512:13-1517:47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2_3I(k,shp):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2_3I(k,shp)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2_3I(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_match__3I__(shp))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2_3I(*args):
    if len(args) != 2: return False
    k,shp, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k) and __arg_alt_match__3I__(shp))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2_3I(self,k,shp):
    self._ctor_init_Emosek_4fusion_4PSDKey_2_3I(k,numpy.array(shp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4PSDKey_2_3I(self,k,shp):
   mosek_fusion_PSDDomain._ctor_init_Emosek_4fusion_4PSDKey_2_3III(self,k,shp,(int((shp).shape[0]) - 2),(int((shp).shape[0]) - 1))
  @staticmethod
  def _ctor_Emosek_4fusion_4PSDKey_2(k):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Emosek_4fusion_4PSDKey_2(k)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_match_Emosek_4fusion_4PSDKey_2__(k))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4PSDKey_2(*args):
    if len(args) != 1: return False
    k, = args
    return (__arg_alt_match_Emosek_4fusion_4PSDKey_2__(k))
  def _ctor_alt_init_Emosek_4fusion_4PSDKey_2(self,k):
    self._ctor_init_Emosek_4fusion_4PSDKey_2(k)
  def _ctor_init_Emosek_4fusion_4PSDKey_2(self,k):
   self._shape = None
   self._key = k
   self._conedim1 = 0
   self._conedim2 = 0
   self._axisIsSet = False
   self._indexnames = None
  @staticmethod
  def _ctor_Lmosek_4fusion_4PSDDomain_2(other):
    o = PSDDomain.__new__(PSDDomain)
    o._ctor_init_Lmosek_4fusion_4PSDDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4PSDDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4PSDDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4PSDDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4PSDDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4PSDDomain_2(self,other):
   self._shape = (other._shape)
   self._key = (other._key)
   self._conedim1 = (other._conedim1)
   self._conedim2 = (other._conedim2)
   self._axisIsSet = (other._axisIsSet)
   self._indexnames = (other._indexnames)
  @staticmethod
  def _match_axis_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_axis_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _axis_alt_II(self,_t__0,_t__1):
    return self._axis_II(numpy.int32(__0),numpy.int32(__1))
  def _axis_II(self,_0,_1):
   (self._conedim1) = _0
   (self._conedim2) = _1
   self._axisIsSet = True
   if ((self._shape is None) and (not ((_0 >= 0) and ((_1 >= 0) and (_0!=_1))))): # src/fusion/domain.mbi:1551:17-1554:43
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
   elif ((self._shape is not None) and ((not ((int((self._shape).shape[0]) > _0) and ((int((self._shape).shape[0]) > _1) and ((_0 >= 0) and ((_1 >= 0) and (_0!=_1)))))) and (self._shape[_0]==self._shape[_1]))): # src/fusion/domain.mbi:1556:17-1562:51
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape or cone dimensions")
   return (self)
  @staticmethod
  def _match_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3S__(_0) and __arg_alt_match_I__(_1))
  def _withNamesOnAxis_alt__3SI(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = self._withNamesOnAxis__3SI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withNamesOnAxis__3SI(self,_0,_1):
   if (self._indexnames is None): # src/fusion/domain.mbi:1524:12-30
    self._indexnames = _monty.initJaggedArray([None for _2 in range(0,(_1 + 1))], 1)
    self._indexnames[_1] = numpy.array([_0[_3] for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   if (int((self._indexnames).shape[0]) < (_1 + 1)): # src/fusion/domain.mbi:1529:12-36
    _4=_monty.initJaggedArray([None for _5 in range(0,(_1 + 1))], 1)
    for _6 in range(0,int((self._indexnames).shape[0])):
     _4[_6] = self._indexnames[_6]
    self._indexnames = _4
   self._indexnames[_1] = numpy.array([_0[_7] for _7 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (self)
  def __finalize_1and_1validate_1inplace_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__finalize_1and_1validate_1inplace__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __finalize_1and_1validate_1inplace__3I(self,_0):
   if (_0 is not None): # src/fusion/domain.mbi:1452:12-23
    if (self._shape is None): # src/fusion/domain.mbi:1453:14-27
     self._shape = _0
    else:
     if (int((_0).shape[0])!=int((self._shape).shape[0])): # src/fusion/domain.mbi:1456:16-38
      raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
     for _1 in range(0,int((_0).shape[0])):
      if (_0[_1]!=self._shape[_1]): # src/fusion/domain.mbi:1459:18-36
       raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
   if (int((self._shape).shape[0]) < 2): # src/fusion/domain.mbi:1463:12-26
    raise mosek_fusion_DimensionError._ctor_S("Positive semidefinite domain must have at least two dimensions")
   if (not self._axisIsSet): # src/fusion/domain.mbi:1466:12-25
    self._conedim1 = (int((self._shape).shape[0]) - 2)
    self._conedim2 = (int((self._shape).shape[0]) - 1)
   if ((self._conedim1 < 0) or ((self._conedim1 >= int((self._shape).shape[0])) or ((self._conedim2 < 0) or ((self._conedim2 >= int((self._shape).shape[0])) or (self._conedim1==self._conedim2))))): # src/fusion/domain.mbi:1471:12-1473:32
    raise mosek_fusion_DimensionError._ctor_S("Invalid cone dimension specification")
   if (self._shape[self._conedim1]!=self._shape[self._conedim2]): # src/fusion/domain.mbi:1476:12-46
    raise mosek_fusion_DimensionError._ctor_S("Cone dimensions must have same size")
   if (self._indexnames is not None): # src/fusion/domain.mbi:1479:12-30
    if (int((self._indexnames).shape[0])!=int((self._shape).shape[0])): # src/fusion/domain.mbi:1480:14-43
     raise mosek_fusion_DimensionError._ctor_S("Index names do not match the domain shape")
    else:
     for _2 in range(0,int((self._shape).shape[0])):
      if ((self._indexnames[_2] is not None) and (int((self._indexnames[_2]).shape[0])!=self._shape[_2])): # src/fusion/domain.mbi:1484:18-74
       raise mosek_fusion_DimensionError._ctor_S("Index names do not match the domain shape")
  def _finalize_1and_1validate_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._finalize_1and_1validate__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _finalize_1and_1validate__3I(self,_0):
   _1=mosek_fusion_PSDDomain._ctor_Lmosek_4fusion_4PSDDomain_2(self)
   _1.__finalize_1and_1validate_1inplace__3I(_0)
   return (_1)
 return PSDDomain
mosek_fusion_PSDDomain=__mk_mosek_fusion_PSDDomain()
del __mk_mosek_fusion_PSDDomain
#BEFORE CLASS
def __mk_mosek_fusion_RangeDomain():
 class RangeDomain(object):
  __slots__ = ['_domsize','_nelements','_indexnames','_cardinal_flag','_scalable','_ub','_lb','_sparsity','_empty','_shape']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    elif mosek_fusion_RangeDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_RangeDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_RangeDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.sparse()\n\tmosek.fusion.RangeDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.RangeDomain.sparse(array(int32,ndim=2))')
  def withShape(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_withShape__3I(*args): # []int32
      return self._withShape__3I(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape__3I(*args): # []int32
      return self._withShape_alt__3I(*args)
    elif mosek_fusion_RangeDomain._match_withShape_I(*args): # int32
      return self._withShape_I(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_I(*args): # int32
      return self._withShape_alt_I(*args)
    elif mosek_fusion_RangeDomain._match_withShape_II(*args): # int32,int32
      return self._withShape_II(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_II(*args): # int32,int32
      return self._withShape_alt_II(*args)
    elif mosek_fusion_RangeDomain._match_withShape_III(*args): # int32,int32,int32
      return self._withShape_III(*args)
    elif mosek_fusion_RangeDomain._match_alt_withShape_III(*args): # int32,int32,int32
      return self._withShape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.withShape(array(int32,ndim=1))\n\tmosek.fusion.RangeDomain.withShape(int32)\n\tmosek.fusion.RangeDomain.withShape(int32,int32)\n\tmosek.fusion.RangeDomain.withShape(int32,int32,int32)')
  def withNamesOnAxis(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_withNamesOnAxis__3SI(*args): # []string,int32
      return self._withNamesOnAxis__3SI(*args)
    elif mosek_fusion_RangeDomain._match_alt_withNamesOnAxis__3SI(*args): # []string,int32
      return self._withNamesOnAxis_alt__3SI(*args)
    else:
      raise ValueError('Invalid argument list withNamesOnAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.withNamesOnAxis(array(string,ndim=1),int32)')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_RangeDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.integral()')
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_RangeDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_RangeDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.RangeDomain.symmetric()')
  def __repr__(self): return 'mosek.fusion.RangeDomain'
  @staticmethod
  def _ctor_Z_3D_3D_3I(scalable,lb,ub,dims):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I(scalable,lb,ub,dims)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I(*args):
    if len(args) != 4: return False
    scalable,lb,ub,dims, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Z_3D_3D_3I(self,scalable,lb,ub,dims):
    self._ctor_init_Z_3D_3D_3I(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Z_3D_3D_3I(self,scalable,lb,ub,dims):
   mosek_fusion_RangeDomain._ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,None,1)
  @staticmethod
  def _ctor_Z_3D_3D_3I_3_5I(scalable,lb,ub,dims,sp):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I_3_5I(scalable,lb,ub,dims,sp)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I_3_5I(*args):
    if len(args) != 5: return False
    scalable,lb,ub,dims,sp, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I_3_5I(*args):
    if len(args) != 5: return False
    scalable,lb,ub,dims,sp, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp))
  def _ctor_alt_init_Z_3D_3D_3I_3_5I(self,scalable,lb,ub,dims,sp):
    self._ctor_init_Z_3D_3D_3I_3_5I(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Z_3D_3D_3I_3_5I(self,scalable,lb,ub,dims,sp):
   mosek_fusion_RangeDomain._ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,1)
  @staticmethod
  def _ctor_Z_3D_3D_3I_3_5II(scalable,lb,ub,dims,sp,steal):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Z_3D_3D_3I_3_5II(scalable,lb,ub,dims,sp,steal)
    return o
  @staticmethod
  def __match_ctor_Z_3D_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    scalable,lb,ub,dims,sp,steal, = args
    return (__arg_match_Z__(scalable) and __arg_match__3D__(lb) and __arg_match__3D__(ub) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp) and __arg_match_I__(steal))
  @staticmethod
  def __match_alt_ctor_Z_3D_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    scalable,lb,ub,dims,sp,steal, = args
    return (__arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(lb) and __arg_alt_match__3D__(ub) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp) and __arg_alt_match_I__(steal))
  def _ctor_alt_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,steal):
    self._ctor_init_Z_3D_3D_3I_3_5II(scalable,numpy.array(lb,dtype=numpy.dtype(numpy.float64)),numpy.array(ub,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)),numpy.int32(steal))
  def _ctor_init_Z_3D_3D_3I_3_5II(self,scalable,lb,ub,dims,sp,steal):
   self._cardinal_flag = False
   self._shape = dims
   self._sparsity = None
   (self._scalable) = scalable
   (self._ub) = ub
   (self._lb) = lb
   (self._sparsity) = sp
   (self._empty) = False
   (self._indexnames) = None
   (self._domsize) = 0
   (self._nelements) = 0
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = RangeDomain.__new__(RangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   self._cardinal_flag = (other._cardinal_flag)
   self._sparsity = (other._sparsity)
   self._scalable = (other._scalable)
   self._shape = (other._shape)
   self._ub = (other._ub)
   self._lb = (other._lb)
   self._domsize = (other._domsize)
   self._nelements = (other._nelements)
   self._empty = (other._empty)
   self._indexnames = (_monty.initJaggedArray([(other._indexnames)[_0] for _0 in range(0,int(((other._indexnames)).shape[0]))], 1) if (((other._indexnames) is not None) ) else None)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricRangeDomain._ctor_Lmosek_4fusion_4RangeDomain_2(self))
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   (self._empty) = True
   (self._sparsity) = None
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  @staticmethod
  def _match_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _withShape_alt_III(self,_t__0,_t__1,_t__2):
    return self._withShape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _withShape_III(self,_0,_1,_2):
   self._shape = numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _withShape_alt_II(self,_t__0,_t__1):
    return self._withShape_II(numpy.int32(__0),numpy.int32(__1))
  def _withShape_II(self,_0,_1):
   self._shape = numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _withShape_alt_I(self,_t__0):
    return self._withShape_I(numpy.int32(__0))
  def _withShape_I(self,_0):
   self._shape = numpy.array([_0], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _withShape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._withShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withShape__3I(self,_0):
   self._shape = _0
   return (self)
  @staticmethod
  def _match_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3S__(_0) and __arg_alt_match_I__(_1))
  def _withNamesOnAxis_alt__3SI(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = self._withNamesOnAxis__3SI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withNamesOnAxis__3SI(self,_0,_1):
   if (self._indexnames is None): # src/fusion/domain.mbi:1291:12-30
    self._indexnames = _monty.initJaggedArray([None for _2 in range(0,(_1 + 1))], 1)
    self._indexnames[_1] = numpy.array([_0[_3] for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   if (int((self._indexnames).shape[0]) < (_1 + 1)): # src/fusion/domain.mbi:1296:12-36
    _4=_monty.initJaggedArray([None for _5 in range(0,(_1 + 1))], 1)
    for _6 in range(0,int((self._indexnames).shape[0])):
     _4[_6] = self._indexnames[_6]
    self._indexnames = _4
   self._indexnames[_1] = numpy.array([_0[_7] for _7 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   if self._scalable: # src/fusion/domain.mbi:1279:17-25
    return (True)
   elif (int((self._shape).shape[0])!=int((_0).shape[0])): # src/fusion/domain.mbi:1281:17-39
    return (False)
   else:
    for _1 in range(0,int((self._shape).shape[0])):
     if (self._shape[_1]!=_0[_1]): # src/fusion/domain.mbi:1285:16-34
      return (False)
   return (True)
  def __finalize_1and_1validate_1inplace_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__finalize_1and_1validate_1inplace__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __finalize_1and_1validate_1inplace__3I(self,_0):
   self._domsize = 1
   if self._scalable: # src/fusion/domain.mbi:1158:12-20
    if (_0 is not None): # src/fusion/domain.mbi:1159:14-25
     self._shape = _0
    else:
     self._shape = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._domsize = fragments._c_closure_271(self._domsize,self._shape) # src/fusion/domain.mbi:1165:10-58
    self._domsize = numpy.int64(self._domsize) # postprocess
   else:
    if (_0 is not None): # src/fusion/domain.mbi:1167:17-28
     if (int((_0).shape[0])!=int((self._shape).shape[0])): # src/fusion/domain.mbi:1168:14-36
      raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
     for _1 in range(0,int((_0).shape[0])):
      if (_0[_1]!=self._shape[_1]): # src/fusion/domain.mbi:1171:16-34
       raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
     self._domsize = fragments._c_closure_272(self._domsize,self._shape) # src/fusion/domain.mbi:1173:10-58
     self._domsize = numpy.int64(self._domsize) # postprocess
   if (self._indexnames is not None): # src/fusion/domain.mbi:1182:12-30
    if (int((self._indexnames).shape[0])!=int((self._shape).shape[0])): # src/fusion/domain.mbi:1183:14-43
     raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
    for _2 in range(0,int((self._shape).shape[0])):
     if ((self._indexnames[_2] is not None) and (int((self._indexnames[_2]).shape[0])!=self._shape[_2])): # src/fusion/domain.mbi:1186:16-72
      raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
   if (self._sparsity is not None): # src/fusion/domain.mbi:1190:12-28
    self._nelements = int((self._sparsity).shape[0])
    if (int((self._shape).shape[0])!=int((self._sparsity).shape[1])): # src/fusion/domain.mbi:1192:14-43
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and sparsity pattern")
    for _3 in range(0,self._nelements):
     for _4 in range(0,int((self._sparsity).shape[1])):
      if ((self._sparsity[_3,_4] < 0) or (self._sparsity[_3,_4] >= self._shape[_4])): # src/fusion/domain.mbi:1196:18-64
       raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern entry is out of bounds")
    if ((not self._scalable) and ((self._lb is not None) and (int((self._lb).shape[0])!=self._nelements))): # src/fusion/domain.mbi:1200:14-1202:34
     raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern does not match bound")
    if ((not self._scalable) and ((self._ub is not None) and (int((self._ub).shape[0])!=self._nelements))): # src/fusion/domain.mbi:1204:14-1206:34
     raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern does not match bound")
   else:
    self._nelements = self._domsize
    if ((self._lb is not None) and (not self._scalable)): # src/fusion/domain.mbi:1211:14-41
     if (int((self._lb).shape[0])!=self._nelements): # src/fusion/domain.mbi:1212:16-36
      raise mosek_fusion_DimensionError._ctor_S("Domain bound does not match shape")
    if ((self._ub is not None) and (not self._scalable)): # src/fusion/domain.mbi:1215:14-41
     if (int((self._ub).shape[0])!=self._nelements): # src/fusion/domain.mbi:1216:16-36
      raise mosek_fusion_DimensionError._ctor_S("Domain bound does not match shape")
  def _finalize_1and_1validate_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._finalize_1and_1validate__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _finalize_1and_1validate__3I(self,_0):
   _1=mosek_fusion_RangeDomain._ctor_Lmosek_4fusion_4RangeDomain_2(self)
   _1.__finalize_1and_1validate_1inplace__3I(_0)
   return (_1)
 return RangeDomain
mosek_fusion_RangeDomain=__mk_mosek_fusion_RangeDomain()
del __mk_mosek_fusion_RangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricRangeDomain():
 class SymmetricRangeDomain(mosek_fusion_RangeDomain):
  __slots__ = ['_dim']
  def __repr__(self): return 'mosek.fusion.SymmetricRangeDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4RangeDomain_2(other):
    o = SymmetricRangeDomain.__new__(SymmetricRangeDomain)
    o._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4RangeDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4RangeDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other):
   mosek_fusion_RangeDomain._ctor_init_Lmosek_4fusion_4RangeDomain_2(self,other)
   if ((self._shape is not None) and ((int((self._shape).shape[0])!=2) or (self._shape[0]!=self._shape[1]))): # src/fusion/domain.mbi:1391:13-1393:37
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape[0])
 return SymmetricRangeDomain
mosek_fusion_SymmetricRangeDomain=__mk_mosek_fusion_SymmetricRangeDomain()
del __mk_mosek_fusion_SymmetricRangeDomain
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricLinearDomain():
 class SymmetricLinearDomain(object):
  __slots__ = ['_sparsity','_cardinal_flag','_key','_shape','_dom','_dim']
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.SymmetricLinearDomain.sparse(array(int32,ndim=2))')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricLinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_SymmetricLinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricLinearDomain.integral()')
  def __repr__(self): return 'mosek.fusion.SymmetricLinearDomain'
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = SymmetricLinearDomain.__new__(SymmetricLinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   self._dom = other
   self._shape = (other._shape)
   self._key = (other._key)
   self._cardinal_flag = (other._cardinal_flag)
   self._sparsity = (other._sparsity)
   if ((self._shape is not None) and ((int((self._shape).shape[0])!=2) or (self._shape[0]!=self._shape[1]))): # src/fusion/domain.mbi:1042:13-1044:36
    raise mosek_fusion_DimensionError._ctor_S("Only square domains can be symmetric")
   self._dim = (0 if ((self._shape is None) ) else self._shape[0])
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1]==self._shape[_1]): # src/fusion/domain.mbi:1052:14-32
     return (False)
   return (True)
 return SymmetricLinearDomain
mosek_fusion_SymmetricLinearDomain=__mk_mosek_fusion_SymmetricLinearDomain()
del __mk_mosek_fusion_SymmetricLinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_LinearDomain():
 class LinearDomain(object):
  __slots__ = ['_nelements','_domsize','_indexnames','_empty','_scalable','_sparsity','_cardinal_flag','_key','_bnd','_shape']
  def withShape(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_withShape__3I(*args): # []int32
      return self._withShape__3I(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape__3I(*args): # []int32
      return self._withShape_alt__3I(*args)
    elif mosek_fusion_LinearDomain._match_withShape_I(*args): # int32
      return self._withShape_I(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_I(*args): # int32
      return self._withShape_alt_I(*args)
    elif mosek_fusion_LinearDomain._match_withShape_II(*args): # int32,int32
      return self._withShape_II(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_II(*args): # int32,int32
      return self._withShape_alt_II(*args)
    elif mosek_fusion_LinearDomain._match_withShape_III(*args): # int32,int32,int32
      return self._withShape_III(*args)
    elif mosek_fusion_LinearDomain._match_alt_withShape_III(*args): # int32,int32,int32
      return self._withShape_alt_III(*args)
    else:
      raise ValueError('Invalid argument list withShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.withShape(array(int32,ndim=1))\n\tmosek.fusion.LinearDomain.withShape(int32)\n\tmosek.fusion.LinearDomain.withShape(int32,int32)\n\tmosek.fusion.LinearDomain.withShape(int32,int32,int32)')
  def withNamesOnAxis(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_withNamesOnAxis__3SI(*args): # []string,int32
      return self._withNamesOnAxis__3SI(*args)
    elif mosek_fusion_LinearDomain._match_alt_withNamesOnAxis__3SI(*args): # []string,int32
      return self._withNamesOnAxis_alt__3SI(*args)
    else:
      raise ValueError('Invalid argument list withNamesOnAxis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.withNamesOnAxis(array(string,ndim=1),int32)')
  def integral(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_integral_(*args): # 
      return self._integral_(*args)
    elif mosek_fusion_LinearDomain._match_alt_integral_(*args): # 
      return self._integral_alt_(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.integral()')
  def symmetric(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_symmetric_(*args): # 
      return self._symmetric_(*args)
    elif mosek_fusion_LinearDomain._match_alt_symmetric_(*args): # 
      return self._symmetric_alt_(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.symmetric()')
  def sparse(self,*args):
    if False: pass
    elif mosek_fusion_LinearDomain._match_sparse_(*args): # 
      return self._sparse_(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse_(*args): # 
      return self._sparse_alt_(*args)
    elif mosek_fusion_LinearDomain._match_sparse__3I(*args): # []int32
      return self._sparse__3I(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse__3I(*args): # []int32
      return self._sparse_alt__3I(*args)
    elif mosek_fusion_LinearDomain._match_sparse__3_5I(*args): # [,]int32
      return self._sparse__3_5I(*args)
    elif mosek_fusion_LinearDomain._match_alt_sparse__3_5I(*args): # [,]int32
      return self._sparse_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinearDomain.sparse()\n\tmosek.fusion.LinearDomain.sparse(array(int32,ndim=1))\n\tmosek.fusion.LinearDomain.sparse(array(int32,ndim=2))')
  def __repr__(self): return 'mosek.fusion.LinearDomain'
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,rhs,dims):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,rhs,dims)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(*args):
    if len(args) != 4: return False
    k,scalable,rhs,dims, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match_Z__(scalable) and __arg_match__3D__(rhs) and __arg_match__3I__(dims))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(*args):
    if len(args) != 4: return False
    k,scalable,rhs,dims, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3I__(dims))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(self,k,scalable,rhs,dims):
    self._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(k,scalable,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I(self,k,scalable,rhs,dims):
   mosek_fusion_LinearDomain._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,None,1)
  @staticmethod
  def _ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,rhs,dims,sp,steal):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,rhs,dims,sp,steal)
    return o
  @staticmethod
  def __match_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    k,scalable,rhs,dims,sp,steal, = args
    return (__arg_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_match_Z__(scalable) and __arg_match__3D__(rhs) and __arg_match__3I__(dims) and __arg_match__3_5I__(sp) and __arg_match_I__(steal))
  @staticmethod
  def __match_alt_ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(*args):
    if len(args) != 6: return False
    k,scalable,rhs,dims,sp,steal, = args
    return (__arg_alt_match_Emosek_4fusion_4RelationKey_2__(k) and __arg_alt_match_Z__(scalable) and __arg_alt_match__3D__(rhs) and __arg_alt_match__3I__(dims) and __arg_alt_match__3_5I__(sp) and __arg_alt_match_I__(steal))
  def _ctor_alt_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,sp,steal):
    self._ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(k,scalable,numpy.array(rhs,dtype=numpy.dtype(numpy.float64)),numpy.array(dims,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int32)),numpy.int32(steal))
  def _ctor_init_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(self,k,scalable,rhs,dims,sp,steal):
   (self._scalable) = scalable
   (self._shape) = dims
   (self._key) = k
   (self._bnd) = rhs
   (self._sparsity) = sp
   (self._cardinal_flag) = False
   (self._empty) = False
   self._indexnames = None
   (self._domsize) = 0
   (self._nelements) = 0
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinearDomain_2(other):
    o = LinearDomain.__new__(LinearDomain)
    o._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinearDomain_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinearDomain_2(other)
  def _ctor_init_Lmosek_4fusion_4LinearDomain_2(self,other):
   self._scalable = (other._scalable)
   self._nelements = (other._nelements)
   self._domsize = (other._domsize)
   self._shape = (other._shape)
   self._key = (other._key)
   self._bnd = (other._bnd)
   self._sparsity = (other._sparsity)
   self._cardinal_flag = (other._cardinal_flag)
   self._empty = (other._empty)
   self._indexnames = (other._indexnames)
  @staticmethod
  def _match_symmetric_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_symmetric_(*args):
    if len(args) != 0: return False
    return True
  def _symmetric_alt_(self,):
    return self._symmetric_()
  def _symmetric_(self,):
   return (mosek_fusion_SymmetricLinearDomain._ctor_Lmosek_4fusion_4LinearDomain_2(self))
  @staticmethod
  def _match_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_sparse__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _sparse_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3_5I(_0)
   return _1
  def _sparse__3_5I(self,_0):
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),int((_0).shape[1]),), dtype=numpy.dtype(numpy.int32))
   (self._empty) = False
   _1=0
   while (_1 < int((_0).shape[0])):
    _2=0
    while (_2 < int((_0).shape[1])):
     (self._sparsity)[_1,_2] = _0[_1,_2]
     _2 += 1
    _1 += 1
   return (self)
  @staticmethod
  def _match_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_sparse__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _sparse_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._sparse__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _sparse__3I(self,_0):
   (self._sparsity) = numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   (self._empty) = False
   for _1 in range(0,int((_0).shape[0])):
    (self._sparsity)[_1,0] = _0[_1]
   return (self)
  @staticmethod
  def _match_sparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_sparse_(*args):
    if len(args) != 0: return False
    return True
  def _sparse_alt_(self,):
    return self._sparse_()
  def _sparse_(self,):
   (self._empty) = True
   (self._sparsity) = None
   return (self)
  @staticmethod
  def _match_integral_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_integral_(*args):
    if len(args) != 0: return False
    return True
  def _integral_alt_(self,):
    return self._integral_()
  def _integral_(self,):
   self._cardinal_flag = True
   return (self)
  @staticmethod
  def _match_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_withShape_III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  def _withShape_alt_III(self,_t__0,_t__1,_t__2):
    return self._withShape_III(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2))
  def _withShape_III(self,_0,_1,_2):
   self._shape = numpy.array([_0,_1,_2], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withShape_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _withShape_alt_II(self,_t__0,_t__1):
    return self._withShape_II(numpy.int32(__0),numpy.int32(__1))
  def _withShape_II(self,_0,_1):
   self._shape = numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_withShape_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _withShape_alt_I(self,_t__0):
    return self._withShape_I(numpy.int32(__0))
  def _withShape_I(self,_0):
   self._shape = numpy.array([_0], dtype=numpy.dtype(numpy.int32))
   return (self)
  @staticmethod
  def _match_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_withShape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _withShape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._withShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withShape__3I(self,_0):
   self._shape = _0
   return (self)
  @staticmethod
  def _match_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3S__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_withNamesOnAxis__3SI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3S__(_0) and __arg_alt_match_I__(_1))
  def _withNamesOnAxis_alt__3SI(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = self._withNamesOnAxis__3SI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _withNamesOnAxis__3SI(self,_0,_1):
   if (self._indexnames is None): # src/fusion/domain.mbi:930:12-30
    self._indexnames = _monty.initJaggedArray([None for _2 in range(0,(_1 + 1))], 1)
    self._indexnames[_1] = numpy.array([_0[_3] for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   if (int((self._indexnames).shape[0]) < (_1 + 1)): # src/fusion/domain.mbi:935:12-36
    _4=_monty.initJaggedArray([None for _5 in range(0,(_1 + 1))], 1)
    for _6 in range(0,int((self._indexnames).shape[0])):
     _4[_6] = self._indexnames[_6]
    self._indexnames = _4
   self._indexnames[_1] = numpy.array([_0[_7] for _7 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (self)
  def _match_1shape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._match_1shape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _match_1shape__3I(self,_0):
   if (not self._scalable): # src/fusion/domain.mbi:920:12-24
    for _1 in range(0,int((_0).shape[0])):
     if (_0[_1]==self._shape[_1]): # src/fusion/domain.mbi:922:16-34
      return (False)
   return (True)
  def __finalize_1and_1validate_1inplace_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__finalize_1and_1validate_1inplace__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __finalize_1and_1validate_1inplace__3I(self,_0):
   if self._scalable: # src/fusion/domain.mbi:805:12-20
    if (self._shape is None): # src/fusion/domain.mbi:806:14-27
     if ((self._sparsity is not None) and (_0 is None)): # src/fusion/domain.mbi:807:16-48
      raise mosek_fusion_DimensionError._ctor_S("Sparse domain requires a fixed shape")
     if (_0 is not None): # src/fusion/domain.mbi:810:16-27
      self._shape = _0
     else:
      self._shape = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
   else:
    if (_0 is not None): # src/fusion/domain.mbi:818:17-28
     if (int((_0).shape[0])!=int((self._shape).shape[0])): # src/fusion/domain.mbi:819:14-36
      raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
     for _1 in range(0,int((_0).shape[0])):
      if (_0[_1]!=self._shape[_1]): # src/fusion/domain.mbi:822:16-34
       raise mosek_fusion_DimensionError._ctor_S("Conflicting shape definitions")
   if (self._indexnames is not None): # src/fusion/domain.mbi:832:12-30
    if (int((self._indexnames).shape[0]) > int((self._shape).shape[0])): # src/fusion/domain.mbi:833:14-42
     raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
    for _2 in range(0,int((self._indexnames).shape[0])):
     if ((self._indexnames[_2] is not None) and (int((self._indexnames[_2]).shape[0])!=self._shape[_2])): # src/fusion/domain.mbi:836:16-72
      raise mosek_fusion_DimensionError._ctor_S("Index names do not match shape")
    if (int((self._indexnames).shape[0]) < int((self._shape).shape[0])): # src/fusion/domain.mbi:838:14-42
     _3=numpy.ndarray((int((self._shape).shape[0]),), dtype=numpy.dtype(object))
     for _4 in range(0,int((self._indexnames).shape[0])):
      _3[_4] = self._indexnames[_4]
     self._indexnames = _3
   self._domsize = 1
   self._domsize = fragments._c_closure_273(self._domsize,self._shape) # src/fusion/domain.mbi:847:8-56
   self._domsize = numpy.int64(self._domsize) # postprocess
   if (self._sparsity is not None): # src/fusion/domain.mbi:849:12-28
    self._nelements = int((self._sparsity).shape[0])
    if (int((self._shape).shape[0])!=int((self._sparsity).shape[1])): # src/fusion/domain.mbi:851:14-43
     raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and sparsity pattern")
    for _5 in range(0,self._nelements):
     for _6 in range(0,int((self._sparsity).shape[1])):
      if ((self._sparsity[_5,_6] < 0) or (self._sparsity[_5,_6] >= self._shape[_6])): # src/fusion/domain.mbi:855:18-64
       raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern entry is out of bounds")
    if ((not self._scalable) and ((self._bnd is not None) and (int((self._bnd).shape[0])!=self._nelements))): # src/fusion/domain.mbi:859:14-861:35
     raise mosek_fusion_DimensionError._ctor_S("Sparsity pattern does not match bound")
   else:
    self._nelements = self._domsize
    if ((self._bnd is not None) and (not self._scalable)): # src/fusion/domain.mbi:866:14-42
     if (int((self._bnd).shape[0])!=self._nelements): # src/fusion/domain.mbi:867:16-37
      raise mosek_fusion_DimensionError._ctor_S("Domain bound does not match shape")
  def _finalize_1and_1validate_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._finalize_1and_1validate__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _finalize_1and_1validate__3I(self,_0):
   _1=mosek_fusion_LinearDomain._ctor_Lmosek_4fusion_4LinearDomain_2(self)
   _1.__finalize_1and_1validate_1inplace__3I(_0)
   return (_1)
 return LinearDomain
mosek_fusion_LinearDomain=__mk_mosek_fusion_LinearDomain()
del __mk_mosek_fusion_LinearDomain
#BEFORE CLASS
def __mk_mosek_fusion_Domain():
 class Domain(object):
  @staticmethod
  def axis(*args):
    if False: pass
    elif mosek_fusion_Domain._match_axis_Lmosek_4fusion_4ConeDomain_2I(*args): # mosek.fusion.ConeDomain,int32
      return mosek_fusion_Domain._axis_Lmosek_4fusion_4ConeDomain_2I(*args)
    elif mosek_fusion_Domain._match_alt_axis_Lmosek_4fusion_4ConeDomain_2I(*args): # mosek.fusion.ConeDomain,int32
      return mosek_fusion_Domain._axis_alt_Lmosek_4fusion_4ConeDomain_2I(*args)
    else:
      raise ValueError('Invalid argument list axis('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.axis(mosek.fusion.ConeDomain,int32)')
  @staticmethod
  def greaterThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D(*args): # []double
      return mosek_fusion_Domain._greaterThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._greaterThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._greaterThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_D(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D(*args): # double
      return mosek_fusion_Domain._greaterThan_alt_D(*args)
    elif mosek_fusion_Domain._match_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._greaterThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._greaterThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DI(*args): # double,int32
      return mosek_fusion_Domain._greaterThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_greaterThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._greaterThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list greaterThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1))\n\tmosek.fusion.Domain.greaterThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=2))\n\tmosek.fusion.Domain.greaterThan(double)\n\tmosek.fusion.Domain.greaterThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.greaterThan(double,int32)\n\tmosek.fusion.Domain.greaterThan(double,int32,int32)')
  @staticmethod
  def symmetric(*args):
    if False: pass
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._symmetric_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list symmetric('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.symmetric(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.symmetric(mosek.fusion.RangeDomain)')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args): # mosek.fusion.LinearDomain,[]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args): # mosek.fusion.LinearDomain,[]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args): # mosek.fusion.LinearDomain,[,]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args): # mosek.fusion.LinearDomain,[,]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4LinearDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args): # mosek.fusion.RangeDomain,[]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args): # mosek.fusion.RangeDomain,[]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2_3I(*args)
    elif mosek_fusion_Domain._match_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args): # mosek.fusion.RangeDomain,[,]int32
      return mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args)
    elif mosek_fusion_Domain._match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args): # mosek.fusion.RangeDomain,[,]int32
      return mosek_fusion_Domain._sparse_alt_Lmosek_4fusion_4RangeDomain_2_3_5I(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=1))\n\tmosek.fusion.Domain.sparse(mosek.fusion.LinearDomain,array(int32,ndim=2))\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=1))\n\tmosek.fusion.Domain.sparse(mosek.fusion.RangeDomain,array(int32,ndim=2))')
  @staticmethod
  def lessThan(*args):
    if False: pass
    elif mosek_fusion_Domain._match_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan__3D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D(*args): # []double
      return mosek_fusion_Domain._lessThan_alt__3D(*args)
    elif mosek_fusion_Domain._match_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._lessThan_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3_5D(*args): # [,]double
      return mosek_fusion_Domain._lessThan_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_D(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D(*args): # double
      return mosek_fusion_Domain._lessThan_alt_D(*args)
    elif mosek_fusion_Domain._match_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._lessThan_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_lessThan__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._lessThan_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_DI(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DI(*args): # double,int32
      return mosek_fusion_Domain._lessThan_alt_DI(*args)
    elif mosek_fusion_Domain._match_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_DII(*args)
    elif mosek_fusion_Domain._match_alt_lessThan_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._lessThan_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list lessThan('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1))\n\tmosek.fusion.Domain.lessThan(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.lessThan(array(double,ndim=2))\n\tmosek.fusion.Domain.lessThan(double)\n\tmosek.fusion.Domain.lessThan(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.lessThan(double,int32)\n\tmosek.fusion.Domain.lessThan(double,int32,int32)')
  @staticmethod
  def inDExpCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inDExpCone_(*args): # 
      return mosek_fusion_Domain._inDExpCone_(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone_(*args): # 
      return mosek_fusion_Domain._inDExpCone_alt_(*args)
    elif mosek_fusion_Domain._match_inDExpCone_I(*args): # int32
      return mosek_fusion_Domain._inDExpCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone_I(*args): # int32
      return mosek_fusion_Domain._inDExpCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inDExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inDExpCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inDExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inDExpCone_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list inDExpCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDExpCone()\n\tmosek.fusion.Domain.inDExpCone(int32)\n\tmosek.fusion.Domain.inDExpCone(array(int32,ndim=1))')
  @staticmethod
  def inRange(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange__3D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D(*args): # []double,[]double
      return mosek_fusion_Domain._inRange_alt__3D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange__3DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD(*args): # []double,double
      return mosek_fusion_Domain._inRange_alt__3DD(*args)
    elif mosek_fusion_Domain._match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix,mosek.fusion.Matrix
      return mosek_fusion_Domain._inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_D_3D(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D(*args): # double,[]double
      return mosek_fusion_Domain._inRange_alt_D_3D(*args)
    elif mosek_fusion_Domain._match_inRange__3_5D_3_5D(*args): # [,]double,[,]double
      return mosek_fusion_Domain._inRange__3_5D_3_5D(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3_5D_3_5D(*args): # [,]double,[,]double
      return mosek_fusion_Domain._inRange_alt__3_5D_3_5D(*args)
    elif mosek_fusion_Domain._match_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_DD(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD(*args): # double,double
      return mosek_fusion_Domain._inRange_alt_DD(*args)
    elif mosek_fusion_Domain._match_inRange_D_3D_3I(*args): # double,[]double,[]int32
      return mosek_fusion_Domain._inRange_D_3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange_D_3D_3I(*args): # double,[]double,[]int32
      return mosek_fusion_Domain._inRange_alt_D_3D_3I(*args)
    elif mosek_fusion_Domain._match_inRange__3DD_3I(*args): # []double,double,[]int32
      return mosek_fusion_Domain._inRange__3DD_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3DD_3I(*args): # []double,double,[]int32
      return mosek_fusion_Domain._inRange_alt__3DD_3I(*args)
    elif mosek_fusion_Domain._match_inRange__3D_3D_3I(*args): # []double,[]double,[]int32
      return mosek_fusion_Domain._inRange__3D_3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange__3D_3D_3I(*args): # []double,[]double,[]int32
      return mosek_fusion_Domain._inRange_alt__3D_3D_3I(*args)
    elif mosek_fusion_Domain._match_inRange_DD_3I(*args): # double,double,[]int32
      return mosek_fusion_Domain._inRange_DD_3I(*args)
    elif mosek_fusion_Domain._match_alt_inRange_DD_3I(*args): # double,double,[]int32
      return mosek_fusion_Domain._inRange_alt_DD_3I(*args)
    else:
      raise ValueError('Invalid argument list inRange('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double)\n\tmosek.fusion.Domain.inRange(mosek.fusion.Matrix,mosek.fusion.Matrix)\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=2),array(double,ndim=2))\n\tmosek.fusion.Domain.inRange(double,double)\n\tmosek.fusion.Domain.inRange(double,array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),double,array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.inRange(double,double,array(int32,ndim=1))')
  @staticmethod
  def binary(*args):
    if False: pass
    elif mosek_fusion_Domain._match_binary_(*args): # 
      return mosek_fusion_Domain._binary_(*args)
    elif mosek_fusion_Domain._match_alt_binary_(*args): # 
      return mosek_fusion_Domain._binary_alt_(*args)
    elif mosek_fusion_Domain._match_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary__3I(*args)
    elif mosek_fusion_Domain._match_alt_binary__3I(*args): # []int32
      return mosek_fusion_Domain._binary_alt__3I(*args)
    elif mosek_fusion_Domain._match_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_I(*args)
    elif mosek_fusion_Domain._match_alt_binary_I(*args): # int32
      return mosek_fusion_Domain._binary_alt_I(*args)
    elif mosek_fusion_Domain._match_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_II(*args)
    elif mosek_fusion_Domain._match_alt_binary_II(*args): # int32,int32
      return mosek_fusion_Domain._binary_alt_II(*args)
    else:
      raise ValueError('Invalid argument list binary('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.binary()\n\tmosek.fusion.Domain.binary(array(int32,ndim=1))\n\tmosek.fusion.Domain.binary(int32)\n\tmosek.fusion.Domain.binary(int32,int32)')
  @staticmethod
  def inQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_(*args): # 
      return mosek_fusion_Domain._inQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_I(*args): # int32
      return mosek_fusion_Domain._inQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inQCone()\n\tmosek.fusion.Domain.inQCone(int32)\n\tmosek.fusion.Domain.inQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inQCone(int32,int32)')
  @staticmethod
  def isTrilPSD(*args):
    if False: pass
    elif mosek_fusion_Domain._match_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_(*args): # 
      return mosek_fusion_Domain._isTrilPSD_alt_(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_I(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_I(*args): # int32
      return mosek_fusion_Domain._isTrilPSD_alt_I(*args)
    elif mosek_fusion_Domain._match_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_II(*args)
    elif mosek_fusion_Domain._match_alt_isTrilPSD_II(*args): # int32,int32
      return mosek_fusion_Domain._isTrilPSD_alt_II(*args)
    else:
      raise ValueError('Invalid argument list isTrilPSD('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.isTrilPSD()\n\tmosek.fusion.Domain.isTrilPSD(int32)\n\tmosek.fusion.Domain.isTrilPSD(int32,int32)')
  @staticmethod
  def inPExpCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPExpCone_(*args): # 
      return mosek_fusion_Domain._inPExpCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone_(*args): # 
      return mosek_fusion_Domain._inPExpCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPExpCone_I(*args): # int32
      return mosek_fusion_Domain._inPExpCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone_I(*args): # int32
      return mosek_fusion_Domain._inPExpCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inPExpCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inPExpCone__3I(*args): # []int32
      return mosek_fusion_Domain._inPExpCone_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list inPExpCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPExpCone()\n\tmosek.fusion.Domain.inPExpCone(int32)\n\tmosek.fusion.Domain.inPExpCone(array(int32,ndim=1))')
  @staticmethod
  def inPGeoMeanCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPGeoMeanCone_(*args): # 
      return mosek_fusion_Domain._inPGeoMeanCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPGeoMeanCone_(*args): # 
      return mosek_fusion_Domain._inPGeoMeanCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPGeoMeanCone_I(*args): # int32
      return mosek_fusion_Domain._inPGeoMeanCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPGeoMeanCone_I(*args): # int32
      return mosek_fusion_Domain._inPGeoMeanCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPGeoMeanCone__3I(*args): # []int32
      return mosek_fusion_Domain._inPGeoMeanCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inPGeoMeanCone__3I(*args): # []int32
      return mosek_fusion_Domain._inPGeoMeanCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inPGeoMeanCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPGeoMeanCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inPGeoMeanCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPGeoMeanCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inPGeoMeanCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPGeoMeanCone()\n\tmosek.fusion.Domain.inPGeoMeanCone(int32)\n\tmosek.fusion.Domain.inPGeoMeanCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inPGeoMeanCone(int32,int32)')
  @staticmethod
  def inPSDCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_(*args): # 
      return mosek_fusion_Domain._inPSDCone_alt_(*args)
    elif mosek_fusion_Domain._match_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inPSDCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inPSDCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inPSDCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPSDCone()\n\tmosek.fusion.Domain.inPSDCone(int32)\n\tmosek.fusion.Domain.inPSDCone(int32,int32)')
  @staticmethod
  def inPPowerCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inPPowerCone__3D(*args): # []double
      return mosek_fusion_Domain._inPPowerCone__3D(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone__3D(*args): # []double
      return mosek_fusion_Domain._inPPowerCone_alt__3D(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_D(*args): # double
      return mosek_fusion_Domain._inPPowerCone_D(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_D(*args): # double
      return mosek_fusion_Domain._inPPowerCone_alt_D(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inPPowerCone_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inPPowerCone_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_inPPowerCone__3DI(*args): # []double,int32
      return mosek_fusion_Domain._inPPowerCone__3DI(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone__3DI(*args): # []double,int32
      return mosek_fusion_Domain._inPPowerCone_alt__3DI(*args)
    elif mosek_fusion_Domain._match_inPPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inPPowerCone_DI(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inPPowerCone_alt_DI(*args)
    elif mosek_fusion_Domain._match_inPPowerCone__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._inPPowerCone__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inPPowerCone__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._inPPowerCone_alt__3D_3I(*args)
    else:
      raise ValueError('Invalid argument list inPPowerCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inPPowerCone(array(double,ndim=1))\n\tmosek.fusion.Domain.inPPowerCone(double)\n\tmosek.fusion.Domain.inPPowerCone(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.inPPowerCone(array(double,ndim=1),int32)\n\tmosek.fusion.Domain.inPPowerCone(double,int32)\n\tmosek.fusion.Domain.inPPowerCone(array(double,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def inDPowerCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inDPowerCone__3D(*args): # []double
      return mosek_fusion_Domain._inDPowerCone__3D(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone__3D(*args): # []double
      return mosek_fusion_Domain._inDPowerCone_alt__3D(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_D(*args): # double
      return mosek_fusion_Domain._inDPowerCone_D(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_D(*args): # double
      return mosek_fusion_Domain._inDPowerCone_alt_D(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inDPowerCone_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._inDPowerCone_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_inDPowerCone__3DI(*args): # []double,int32
      return mosek_fusion_Domain._inDPowerCone__3DI(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone__3DI(*args): # []double,int32
      return mosek_fusion_Domain._inDPowerCone_alt__3DI(*args)
    elif mosek_fusion_Domain._match_inDPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inDPowerCone_DI(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone_DI(*args): # double,int32
      return mosek_fusion_Domain._inDPowerCone_alt_DI(*args)
    elif mosek_fusion_Domain._match_inDPowerCone__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._inDPowerCone__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_inDPowerCone__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._inDPowerCone_alt__3D_3I(*args)
    else:
      raise ValueError('Invalid argument list inDPowerCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDPowerCone(array(double,ndim=1))\n\tmosek.fusion.Domain.inDPowerCone(double)\n\tmosek.fusion.Domain.inDPowerCone(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.inDPowerCone(array(double,ndim=1),int32)\n\tmosek.fusion.Domain.inDPowerCone(double,int32)\n\tmosek.fusion.Domain.inDPowerCone(array(double,ndim=1),array(int32,ndim=1))')
  @staticmethod
  def unbounded(*args):
    if False: pass
    elif mosek_fusion_Domain._match_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_(*args): # 
      return mosek_fusion_Domain._unbounded_alt_(*args)
    elif mosek_fusion_Domain._match_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_I(*args): # int32
      return mosek_fusion_Domain._unbounded_alt_I(*args)
    elif mosek_fusion_Domain._match_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded__3I(*args)
    elif mosek_fusion_Domain._match_alt_unbounded__3I(*args): # []int32
      return mosek_fusion_Domain._unbounded_alt__3I(*args)
    elif mosek_fusion_Domain._match_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_II(*args)
    elif mosek_fusion_Domain._match_alt_unbounded_II(*args): # int32,int32
      return mosek_fusion_Domain._unbounded_alt_II(*args)
    else:
      raise ValueError('Invalid argument list unbounded('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.unbounded()\n\tmosek.fusion.Domain.unbounded(int32)\n\tmosek.fusion.Domain.unbounded(array(int32,ndim=1))\n\tmosek.fusion.Domain.unbounded(int32,int32)')
  @staticmethod
  def inRotatedQCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_(*args): # 
      return mosek_fusion_Domain._inRotatedQCone_alt_(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_I(*args): # int32
      return mosek_fusion_Domain._inRotatedQCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone__3I(*args): # []int32
      return mosek_fusion_Domain._inRotatedQCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inRotatedQCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inRotatedQCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inRotatedQCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inRotatedQCone()\n\tmosek.fusion.Domain.inRotatedQCone(int32)\n\tmosek.fusion.Domain.inRotatedQCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inRotatedQCone(int32,int32)')
  @staticmethod
  def inDGeoMeanCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inDGeoMeanCone_(*args): # 
      return mosek_fusion_Domain._inDGeoMeanCone_(*args)
    elif mosek_fusion_Domain._match_alt_inDGeoMeanCone_(*args): # 
      return mosek_fusion_Domain._inDGeoMeanCone_alt_(*args)
    elif mosek_fusion_Domain._match_inDGeoMeanCone_I(*args): # int32
      return mosek_fusion_Domain._inDGeoMeanCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inDGeoMeanCone_I(*args): # int32
      return mosek_fusion_Domain._inDGeoMeanCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inDGeoMeanCone__3I(*args): # []int32
      return mosek_fusion_Domain._inDGeoMeanCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inDGeoMeanCone__3I(*args): # []int32
      return mosek_fusion_Domain._inDGeoMeanCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inDGeoMeanCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inDGeoMeanCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inDGeoMeanCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inDGeoMeanCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inDGeoMeanCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inDGeoMeanCone()\n\tmosek.fusion.Domain.inDGeoMeanCone(int32)\n\tmosek.fusion.Domain.inDGeoMeanCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inDGeoMeanCone(int32,int32)')
  @staticmethod
  def inSVecPSDCone(*args):
    if False: pass
    elif mosek_fusion_Domain._match_inSVecPSDCone_(*args): # 
      return mosek_fusion_Domain._inSVecPSDCone_(*args)
    elif mosek_fusion_Domain._match_alt_inSVecPSDCone_(*args): # 
      return mosek_fusion_Domain._inSVecPSDCone_alt_(*args)
    elif mosek_fusion_Domain._match_inSVecPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inSVecPSDCone_I(*args)
    elif mosek_fusion_Domain._match_alt_inSVecPSDCone_I(*args): # int32
      return mosek_fusion_Domain._inSVecPSDCone_alt_I(*args)
    elif mosek_fusion_Domain._match_inSVecPSDCone__3I(*args): # []int32
      return mosek_fusion_Domain._inSVecPSDCone__3I(*args)
    elif mosek_fusion_Domain._match_alt_inSVecPSDCone__3I(*args): # []int32
      return mosek_fusion_Domain._inSVecPSDCone_alt__3I(*args)
    elif mosek_fusion_Domain._match_inSVecPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inSVecPSDCone_II(*args)
    elif mosek_fusion_Domain._match_alt_inSVecPSDCone_II(*args): # int32,int32
      return mosek_fusion_Domain._inSVecPSDCone_alt_II(*args)
    else:
      raise ValueError('Invalid argument list inSVecPSDCone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.inSVecPSDCone()\n\tmosek.fusion.Domain.inSVecPSDCone(int32)\n\tmosek.fusion.Domain.inSVecPSDCone(array(int32,ndim=1))\n\tmosek.fusion.Domain.inSVecPSDCone(int32,int32)')
  @staticmethod
  def integral(*args):
    if False: pass
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4ConeDomain_2(*args): # mosek.fusion.ConeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4ConeDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args): # mosek.fusion.LinearDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4LinearDomain_2(*args)
    elif mosek_fusion_Domain._match_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(*args)
    elif mosek_fusion_Domain._match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args): # mosek.fusion.RangeDomain
      return mosek_fusion_Domain._integral_alt_Lmosek_4fusion_4RangeDomain_2(*args)
    else:
      raise ValueError('Invalid argument list integral('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.integral(mosek.fusion.ConeDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.LinearDomain)\n\tmosek.fusion.Domain.integral(mosek.fusion.RangeDomain)')
  @staticmethod
  def equalsTo(*args):
    if False: pass
    elif mosek_fusion_Domain._match_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo__3D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D(*args): # []double
      return mosek_fusion_Domain._equalsTo_alt__3D(*args)
    elif mosek_fusion_Domain._match_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Domain._equalsTo_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Domain._match_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo__3_5D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3_5D(*args): # [,]double
      return mosek_fusion_Domain._equalsTo_alt__3_5D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_D(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D(*args): # double
      return mosek_fusion_Domain._equalsTo_alt_D(*args)
    elif mosek_fusion_Domain._match_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_D_3I(*args): # double,[]int32
      return mosek_fusion_Domain._equalsTo_alt_D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo__3D_3I(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo__3D_3I(*args): # []double,[]int32
      return mosek_fusion_Domain._equalsTo_alt__3D_3I(*args)
    elif mosek_fusion_Domain._match_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_DI(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DI(*args): # double,int32
      return mosek_fusion_Domain._equalsTo_alt_DI(*args)
    elif mosek_fusion_Domain._match_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_DII(*args)
    elif mosek_fusion_Domain._match_alt_equalsTo_DII(*args): # double,int32,int32
      return mosek_fusion_Domain._equalsTo_alt_DII(*args)
    else:
      raise ValueError('Invalid argument list equalsTo('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1))\n\tmosek.fusion.Domain.equalsTo(mosek.fusion.Matrix)\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=2))\n\tmosek.fusion.Domain.equalsTo(double)\n\tmosek.fusion.Domain.equalsTo(double,array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(array(double,ndim=1),array(int32,ndim=1))\n\tmosek.fusion.Domain.equalsTo(double,int32)\n\tmosek.fusion.Domain.equalsTo(double,int32,int32)')
  def __repr__(self): return 'mosek.fusion.Domain'
  @staticmethod
  def __dimsize_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__dimsize__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __dimsize__3I(_0):
   _1=1
   _1 = fragments._c_closure_274(_0,_1) # src/fusion/domain.mbi:743:72-113
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def __mkRangedDomain_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain.__mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def __mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if (((_0._dimi)!=(_1._dimi)) or ((_0._dimj)!=(_1._dimj))): # src/fusion/domain.mbi:625:12-52
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions in domain")
   if (_0._isSparse_() and _1._isSparse_()): # src/fusion/domain.mbi:628:12-43
    _2=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _7=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _0._getDataAsTriplets__3I_3I_3D(_2,_3,_4)
    _1._getDataAsTriplets__3I_3I_3D(_5,_6,_7)
    _8=0
    _8 = fragments._c_closure_275(_2,_3,_8,_5,_6) # src/fusion/domain.mbi:639:10-654:11
    _8 = numpy.int64(_8) # postprocess
    _9=numpy.zeros((_8,2,), dtype=numpy.dtype(numpy.int32))
    _10=numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    _11=numpy.zeros((_8,), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_276(_9,_10,_2,_3,_4,_11,_5,_6,_7) # src/fusion/domain.mbi:659:10-700:11
    return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_10,_11,numpy.array([(_0._dimi),(_0._dimj)], dtype=numpy.dtype(numpy.int32)),_9,1))
   else:
    _12=(_0._dimj)
    _13=(_0._dimi)
    _14=(_13 * _12)
    if _0._isSparse_(): # src/fusion/domain.mbi:711:14-27
     _15 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
     _17=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _18=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _19=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
     _0._getDataAsTriplets__3I_3I_3D(_17,_18,_19)
     fragments._c_closure_277(_12,_15,_17,_18,_19) # src/fusion/domain.mbi:718:12-719:48
    else:
     _15 = _0._getDataAsArray_()
    if _1._isSparse_(): # src/fusion/domain.mbi:725:14-27
     _16 = numpy.zeros((_14,), dtype=numpy.dtype(numpy.float64))
     _20=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _21=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
     _22=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
     _1._getDataAsTriplets__3I_3I_3D(_20,_21,_22)
     fragments._c_closure_278(_12,_20,_21,_16,_22) # src/fusion/domain.mbi:732:12-733:48
    else:
     _16 = _1._getDataAsArray_()
    return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_15,_16,numpy.array([(_0._dimi),(_0._dimj)], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __mkRangedDomain_alt__3_5D_3_5D(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain.__mkRangedDomain__3_5D_3_5D(_0,_1)
   return _1
  @staticmethod
  def __mkRangedDomain__3_5D_3_5D(_0,_1):
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[1])!=int((_1).shape[1]))): # src/fusion/domain.mbi:604:12-60
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions in domain")
   _2=int((_0).shape[1])
   _3=int((_0).shape[0])
   _4=(_3 * _2)
   _5=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _7=0
   _7 = fragments._c_closure_279(_3,_2,_7,_0,_5,_1,_6) # src/fusion/domain.mbi:613:8-618:11
   _7 = numpy.int32(_7) # postprocess
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I_3_5II(False,_5,_6,numpy.array([_3,_2], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __mkLinearDomain_alt_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(__0,_1)
  @staticmethod
  def __mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(_0,_1):
   if _1._isSparse_(): # src/fusion/domain.mbi:585:12-25
    _2=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _3=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _1._getDataAsTriplets__3I_3I_3D(_2,_3,_4)
    _5=numpy.zeros((int((_2).shape[0]),2,), dtype=numpy.dtype(numpy.int32))
    fragments._c_closure_280(_5,_2,_3) # src/fusion/domain.mbi:592:10-595:11
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(_0,False,_4,numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32)),_5,1))
   else:
    return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I_3_5II(_0,False,_1._getDataAsArray_(),numpy.array([(_1._dimi),(_1._dimj)], dtype=numpy.dtype(numpy.int32)),None,1))
  @staticmethod
  def __prod_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__prod__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __prod__3I(_0):
   _1=1
   _1 = fragments._c_closure_281(_0,_1) # src/fusion/domain.mbi:581:71-109
   _1 = numpy.int64(_1) # postprocess
   return numpy.int64(_1)
  @staticmethod
  def __inRange_alt_Z_3D_3D_3_5I_3I(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,ndmin=_monty.checkShape(_t__3,2),dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain.__inRange_Z_3D_3D_3_5I_3I(_0,_1,_2,_3,_4)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __inRange_Z_3D_3D_3_5I_3I(_0,_1,_2,_3,_4):
   if ((not _0) and (int((_1).shape[0])!=int((_2).shape[0]))): # src/fusion/domain.mbi:566:12-47
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper and lower bounds.")
   if ((_3 is not None) and (int((_3).shape[0])!=int((_1).shape[0]))): # src/fusion/domain.mbi:568:12-47
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of upper/lower bounds and sparsity.")
   for _5 in range(0,int((_2).shape[0])):
    if (_1[_5] > _2[_5]): # src/fusion/domain.mbi:572:14-27
     raise mosek_fusion_DomainError._ctor_S("Invalid range specified")
   if ((_4 is not None) and (mosek.fusion.Domain.__dimsize__3I(_4)!=int((_1).shape[0]))): # src/fusion/domain.mbi:575:12-53
    raise mosek_fusion_LengthError._ctor_S("Mismatching dimensions.")
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(_0,_1,_2,_4)._sparse__3_5I(_3))
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._symmetric_())
  @staticmethod
  def _match_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_symmetric_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _symmetric_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._symmetric_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _symmetric_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._symmetric_())
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2_3_5I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(_0,_1)
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2_3_5I(_0,_1):
   return (_0._sparse__3_5I(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4RangeDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4RangeDomain_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4RangeDomain_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4RangeDomain_2_3I(_0,_1):
   return (_0._sparse__3I(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2_3_5I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(_0,_1)
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2_3_5I(_0,_1):
   return (_0._sparse__3_5I(_1))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4LinearDomain_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4LinearDomain_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._sparse_Lmosek_4fusion_4LinearDomain_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_Lmosek_4fusion_4LinearDomain_2_3I(_0,_1):
   return (_0._sparse__3I(_1))
  @staticmethod
  def _match_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4RangeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4RangeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4RangeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4RangeDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4LinearDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4LinearDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4LinearDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4LinearDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_integral_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _match_alt_integral_Lmosek_4fusion_4ConeDomain_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0))
  @staticmethod
  def _integral_alt_Lmosek_4fusion_4ConeDomain_2(_t__0):
    return mosek_fusion_Domain._integral_Lmosek_4fusion_4ConeDomain_2(_0)
  @staticmethod
  def _integral_Lmosek_4fusion_4ConeDomain_2(_0):
   return (_0._integral_())
  @staticmethod
  def _match_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4ConeDomain_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_axis_Lmosek_4fusion_4ConeDomain_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _axis_alt_Lmosek_4fusion_4ConeDomain_2I(_t__0,_t__1):
    return mosek_fusion_Domain._axis_Lmosek_4fusion_4ConeDomain_2I(_0,numpy.int32(__1))
  @staticmethod
  def _axis_Lmosek_4fusion_4ConeDomain_2I(_0,_1):
   return (_0._axis_I(_1))
  @staticmethod
  def _match_inDPowerCone__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_inDPowerCone__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _inDPowerCone_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inDPowerCone__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDPowerCone__3D_3I(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,_0,numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inDPowerCone__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inDPowerCone_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Domain._inDPowerCone__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDPowerCone__3DI(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,_0,numpy.array([_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_inDPowerCone__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _inDPowerCone_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inDPowerCone__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDPowerCone__3D(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,_0,None))
  @staticmethod
  def _match_inDPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_inDPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _inDPowerCone_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inDPowerCone_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDPowerCone_D_3I(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,numpy.array([_0,(1.0 - _0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inDPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inDPowerCone_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._inDPowerCone_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _inDPowerCone_DI(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,numpy.array([_0,(1.0 - _0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_inDPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _inDPowerCone_alt_D(_t__0):
    return mosek_fusion_Domain._inDPowerCone_D(numpy.float64(__0))
  @staticmethod
  def _inDPowerCone_D(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InDPowCone,numpy.array([_0,(1.0 - _0)], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_inPPowerCone__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_inPPowerCone__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _inPPowerCone_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inPPowerCone__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPPowerCone__3D_3I(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,_0,numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPPowerCone__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPPowerCone_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Domain._inPPowerCone__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPPowerCone__3DI(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,_0,numpy.array([_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_inPPowerCone__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _inPPowerCone_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inPPowerCone__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPPowerCone__3D(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,_0,None))
  @staticmethod
  def _match_inPPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_inPPowerCone_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _inPPowerCone_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inPPowerCone_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPPowerCone_D_3I(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,numpy.array([_0,(1.0 - _0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_1[_2] for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPPowerCone_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPPowerCone_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._inPPowerCone_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _inPPowerCone_DI(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,numpy.array([_0,(1.0 - _0)], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_inPPowerCone_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _inPPowerCone_alt_D(_t__0):
    return mosek_fusion_Domain._inPPowerCone_D(numpy.float64(__0))
  @staticmethod
  def _inPPowerCone_D(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3D_3I(mosek.fusion.QConeKey.InPPowCone,numpy.array([_0,(1.0 - _0)], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_inDExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inDExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inDExpCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inDExpCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDExpCone__3I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inDExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inDExpCone_alt_I(_t__0):
    return mosek_fusion_Domain._inDExpCone_I(numpy.int32(__0))
  @staticmethod
  def _inDExpCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,numpy.array([_0,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inDExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inDExpCone_alt_():
    return mosek_fusion_Domain._inDExpCone_()
  @staticmethod
  def _inDExpCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDExpCone,None))
  @staticmethod
  def _match_inPExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inPExpCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inPExpCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inPExpCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPExpCone__3I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPExpCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPExpCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPExpCone_I(numpy.int32(__0))
  @staticmethod
  def _inPExpCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,numpy.array([_0,3], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPExpCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPExpCone_alt_():
    return mosek_fusion_Domain._inPExpCone_()
  @staticmethod
  def _inPExpCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPExpCone,None))
  @staticmethod
  def _match_inDGeoMeanCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inDGeoMeanCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inDGeoMeanCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inDGeoMeanCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inDGeoMeanCone__3I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDGeoMeanCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDGeoMeanCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inDGeoMeanCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inDGeoMeanCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inDGeoMeanCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inDGeoMeanCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDGeoMeanCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDGeoMeanCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inDGeoMeanCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inDGeoMeanCone_alt_I(_t__0):
    return mosek_fusion_Domain._inDGeoMeanCone_I(numpy.int32(__0))
  @staticmethod
  def _inDGeoMeanCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDGeoMeanCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inDGeoMeanCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inDGeoMeanCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inDGeoMeanCone_alt_():
    return mosek_fusion_Domain._inDGeoMeanCone_()
  @staticmethod
  def _inDGeoMeanCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InDGeoMeanCone,None))
  @staticmethod
  def _match_inPGeoMeanCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inPGeoMeanCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inPGeoMeanCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inPGeoMeanCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inPGeoMeanCone__3I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPGeoMeanCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPGeoMeanCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPGeoMeanCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPGeoMeanCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inPGeoMeanCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inPGeoMeanCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPGeoMeanCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPGeoMeanCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPGeoMeanCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPGeoMeanCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPGeoMeanCone_I(numpy.int32(__0))
  @staticmethod
  def _inPGeoMeanCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPGeoMeanCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPGeoMeanCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPGeoMeanCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPGeoMeanCone_alt_():
    return mosek_fusion_Domain._inPGeoMeanCone_()
  @staticmethod
  def _inPGeoMeanCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InPGeoMeanCone,None))
  @staticmethod
  def _match_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inRotatedQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRotatedQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRotatedQCone__3I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inRotatedQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inRotatedQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inRotatedQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inRotatedQCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inRotatedQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inRotatedQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inRotatedQCone_I(numpy.int32(__0))
  @staticmethod
  def _inRotatedQCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InRotatedQCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inRotatedQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inRotatedQCone_alt_():
    return mosek_fusion_Domain._inRotatedQCone_()
  @staticmethod
  def _inRotatedQCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InRotatedQCone,None))
  @staticmethod
  def _match_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inQCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inQCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inQCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inQCone__3I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InQCone,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inQCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inQCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inQCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inQCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InQCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inQCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inQCone_alt_I(_t__0):
    return mosek_fusion_Domain._inQCone_I(numpy.int32(__0))
  @staticmethod
  def _inQCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InQCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inQCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inQCone_alt_():
    return mosek_fusion_Domain._inQCone_()
  @staticmethod
  def _inQCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InQCone,None))
  @staticmethod
  def _match_inSVecPSDCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_inSVecPSDCone__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _inSVecPSDCone_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inSVecPSDCone__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inSVecPSDCone__3I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InSVecPSDCone,_0))
  @staticmethod
  def _match_inSVecPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inSVecPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inSVecPSDCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inSVecPSDCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inSVecPSDCone_II(_0,_1):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InSVecPSDCone,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inSVecPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inSVecPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inSVecPSDCone_alt_I(_t__0):
    return mosek_fusion_Domain._inSVecPSDCone_I(numpy.int32(__0))
  @staticmethod
  def _inSVecPSDCone_I(_0):
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InSVecPSDCone,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inSVecPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inSVecPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inSVecPSDCone_alt_():
    return mosek_fusion_Domain._inSVecPSDCone_()
  @staticmethod
  def _inSVecPSDCone_():
   return (mosek_fusion_ConeDomain._ctor_Emosek_4fusion_4QConeKey_2_3I(mosek.fusion.QConeKey.InSVecPSDCone,None))
  @staticmethod
  def _match_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_isTrilPSD_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _isTrilPSD_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._isTrilPSD_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _isTrilPSD_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3III(mosek.fusion.PSDKey.IsTrilPSD,numpy.array([_1,_0,_0], dtype=numpy.dtype(numpy.int32)),1,2))
  @staticmethod
  def _match_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_isTrilPSD_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _isTrilPSD_alt_I(_t__0):
    return mosek_fusion_Domain._isTrilPSD_I(numpy.int32(__0))
  @staticmethod
  def _isTrilPSD_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3III(mosek.fusion.PSDKey.IsTrilPSD,numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32)),0,1))
  @staticmethod
  def _match_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isTrilPSD_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _isTrilPSD_alt_():
    return mosek_fusion_Domain._isTrilPSD_()
  @staticmethod
  def _isTrilPSD_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsTrilPSD))
  @staticmethod
  def _match_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_inPSDCone_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _inPSDCone_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._inPSDCone_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _inPSDCone_II(_0,_1):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3I(mosek.fusion.PSDKey.IsSymPSD,numpy.array([_1,_0,_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_inPSDCone_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _inPSDCone_alt_I(_t__0):
    return mosek_fusion_Domain._inPSDCone_I(numpy.int32(__0))
  @staticmethod
  def _inPSDCone_I(_0):
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2_3I(mosek.fusion.PSDKey.IsSymPSD,numpy.array([_0,_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_inPSDCone_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _inPSDCone_alt_():
    return mosek_fusion_Domain._inPSDCone_()
  @staticmethod
  def _inPSDCone_():
   return (mosek_fusion_PSDDomain._ctor_Emosek_4fusion_4PSDKey_2(mosek.fusion.PSDKey.IsSymPSD))
  @staticmethod
  def _match_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_binary_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _binary_alt_():
    return mosek_fusion_Domain._binary_()
  @staticmethod
  def _binary_():
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),None)._integral_())
  @staticmethod
  def _match_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_binary__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _binary_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._binary__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _binary__3I(_0):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),_0)._integral_())
  @staticmethod
  def _match_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_binary_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _binary_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._binary_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _binary_II(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_binary_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _binary_alt_I(_t__0):
    return mosek_fusion_Domain._binary_I(numpy.int32(__0))
  @staticmethod
  def _binary_I(_0):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([0.0], dtype=numpy.dtype(numpy.float64)),numpy.array([1.0], dtype=numpy.dtype(numpy.float64)),numpy.array([_0], dtype=numpy.dtype(numpy.int32)))._integral_())
  @staticmethod
  def _match_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _inRange_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _inRange_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Domain.__mkRangedDomain_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Matrix_2(_0,_1))
  @staticmethod
  def _match_inRange__3_5D_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_inRange__3_5D_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _inRange_alt__3_5D_3_5D(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange__3_5D_3_5D(_0,_1)
   return _1
  @staticmethod
  def _inRange__3_5D_3_5D(_0,_1):
   return (mosek.fusion.Domain.__mkRangedDomain__3_5D_3_5D(_0,_1))
  @staticmethod
  def _match_inRange__3D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3D__(_0) and __arg_match__3D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange__3D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt__3D_3D_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange__3D_3D_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3D_3D_3I(_0,_1,_2):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,_1,_2))
  @staticmethod
  def _match_inRange__3DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3D__(_0) and __arg_match_D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange__3DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt__3DD_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.float64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange__3DD_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3DD_3I(_0,_1,_2):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,numpy.array([_1 for _3 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),_2))
  @staticmethod
  def _match_inRange_D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match__3D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange_D_3D_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt_D_3D_3I(_t__0,_t__1,_t__2):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange_D_3D_3I(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_D_3D_3I(_0,_1,_2):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([_0 for _3 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_1,_2))
  @staticmethod
  def _match_inRange_DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match__3I__(_2))
  @staticmethod
  def _match_alt_inRange_DD_3I(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match__3I__(_2))
  @staticmethod
  def _inRange_alt_DD_3I(_t__0,_t__1,_t__2):
   _0=numpy.float64(_t__0)
   _1=numpy.float64(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._inRange_DD_3I(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_DD_3I(_0,_1,_2):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.float64)),_2))
  @staticmethod
  def _match_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange__3D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt__3D_3D(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange__3D_3D(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3D_3D(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,_1,numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange__3DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt__3DD(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.float64(_t__1)
   _1 = mosek_fusion_Domain._inRange__3DD(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange__3DD(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,_0,numpy.array([_1 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_inRange_D_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _inRange_alt_D_3D(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._inRange_D_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inRange_D_3D(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(False,numpy.array([_0 for _2 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.float64)),_1,numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_inRange_DD(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _inRange_alt_DD(_t__0,_t__1):
    return mosek_fusion_Domain._inRange_DD(numpy.float64(__0),numpy.float64(__1))
  @staticmethod
  def _inRange_DD(_0,_1):
   return (mosek_fusion_RangeDomain._ctor_Z_3D_3D_3I(True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_greaterThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _greaterThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._greaterThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _greaterThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.GreaterThan,_0))
  @staticmethod
  def _match_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D_3I(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _greaterThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3_5D(_0)
   return _1
  @staticmethod
  def _greaterThan__3_5D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_greaterThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _greaterThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._greaterThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan__3D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_greaterThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _greaterThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._greaterThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _greaterThan_D_3I(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_0 for _2 in range(0,mosek.fusion.Domain.__prod__3I(_1))], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_greaterThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _greaterThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._greaterThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _greaterThan_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_0 for _3 in range(0,(_2 * _1))], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_greaterThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _greaterThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._greaterThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _greaterThan_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,False,numpy.array([_0 for _2 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_greaterThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _greaterThan_alt_D(_t__0):
    return mosek_fusion_Domain._greaterThan_D(numpy.float64(__0))
  @staticmethod
  def _greaterThan_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.GreaterThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_lessThan_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _lessThan_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._lessThan_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _lessThan_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.LessThan,_0))
  @staticmethod
  def _match_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D_3I(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_lessThan__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _lessThan_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3_5D(_0)
   return _1
  @staticmethod
  def _lessThan__3_5D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_lessThan__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _lessThan_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._lessThan__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan__3D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_lessThan_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _lessThan_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._lessThan_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _lessThan_D_3I(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_lessThan_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _lessThan_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._lessThan_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _lessThan_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_lessThan_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _lessThan_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._lessThan_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _lessThan_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,False,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_lessThan_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _lessThan_alt_D(_t__0):
    return mosek_fusion_Domain._lessThan_D(numpy.float64(__0))
  @staticmethod
  def _lessThan_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.LessThan,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_equalsTo_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _equalsTo_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Domain._equalsTo_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _equalsTo_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek.fusion.Domain.__mkLinearDomain_Emosek_4fusion_4RelationKey_2Lmosek_4fusion_4Matrix_2(mosek.fusion.RelationKey.EqualsTo,_0))
  @staticmethod
  def _match_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo__3D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt__3D_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo__3D_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D_3I(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),_1))
  @staticmethod
  def _match_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _equalsTo_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3_5D(_0)
   return _1
  @staticmethod
  def _equalsTo__3_5D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_equalsTo__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _equalsTo_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Domain._equalsTo__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo__3D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,mosek.fusion.Utils.Tools._arraycopy__3D(_0),numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_equalsTo_D_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _equalsTo_alt_D_3I(_t__0,_t__1):
   _0=numpy.float64(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._equalsTo_D_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _equalsTo_D_3I(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def _match_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_equalsTo_DII(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _equalsTo_alt_DII(_t__0,_t__1,_t__2):
    return mosek_fusion_Domain._equalsTo_DII(numpy.float64(__0),numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _equalsTo_DII(_0,_1,_2):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1,_2], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_equalsTo_DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _equalsTo_alt_DI(_t__0,_t__1):
    return mosek_fusion_Domain._equalsTo_DI(numpy.float64(__0),numpy.int32(__1))
  @staticmethod
  def _equalsTo_DI(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,False,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_equalsTo_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _equalsTo_alt_D(_t__0):
    return mosek_fusion_Domain._equalsTo_D(numpy.float64(__0))
  @staticmethod
  def _equalsTo_D(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.EqualsTo,True,numpy.array([_0], dtype=numpy.dtype(numpy.float64)),None))
  @staticmethod
  def _match_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_unbounded__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _unbounded_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Domain._unbounded__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _unbounded__3I(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0[_1] for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_unbounded_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _unbounded_alt_II(_t__0,_t__1):
    return mosek_fusion_Domain._unbounded_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _unbounded_II(_0,_1):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0,_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_unbounded_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _unbounded_alt_I(_t__0):
    return mosek_fusion_Domain._unbounded_I(numpy.int32(__0))
  @staticmethod
  def _unbounded_I(_0):
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,False,None,numpy.array([_0], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_unbounded_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _unbounded_alt_():
    return mosek_fusion_Domain._unbounded_()
  @staticmethod
  def _unbounded_():
   return (mosek_fusion_LinearDomain._ctor_Emosek_4fusion_4RelationKey_2Z_3D_3I(mosek.fusion.RelationKey.IsFree,True,None,None))
 return Domain
mosek_fusion_Domain=__mk_mosek_fusion_Domain()
del __mk_mosek_fusion_Domain
#BEFORE CLASS
def __mk_mosek_fusion_ExprCode():
 class ExprCode(object):
  @staticmethod
  def emit_mul(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1mul__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1mul__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1mul__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1mul_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_mul(array(int32,ndim=1),int32)')
  @staticmethod
  def emit_inv(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1inv__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1inv__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1inv__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1inv_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_inv('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_inv(array(int32,ndim=1),int32)')
  @staticmethod
  def emit_add(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1add__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1add__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1add__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1add_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_add(array(int32,ndim=1),int32)')
  @staticmethod
  def eval_add_list(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args): # []int32,[]int32,[]double,[]double,[]double,mosek.fusion.WorkStack
      return mosek_fusion_ExprCode._eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCode._match_alt_eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args): # []int32,[]int32,[]double,[]double,[]double,mosek.fusion.WorkStack
      return mosek_fusion_ExprCode._eval_1add_1list_alt__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCode._match_eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args): # []int32,[]int32,[]double,int32,[]double,[]double,mosek.fusion.WorkStack
      return mosek_fusion_ExprCode._eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCode._match_alt_eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args): # []int32,[]int32,[]double,int32,[]double,[]double,mosek.fusion.WorkStack
      return mosek_fusion_ExprCode._eval_1add_1list_alt__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_add_list('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.eval_add_list(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),array(double,ndim=1),array(double,ndim=1),mosek.fusion.WorkStack)\n\tmosek.fusion.ExprCode.eval_add_list(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),int32,array(double,ndim=1),array(double,ndim=1),mosek.fusion.WorkStack)')
  @staticmethod
  def emit_constref(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1constref__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1constref__3III(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1constref__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1constref_alt__3III(*args)
    else:
      raise ValueError('Invalid argument list emit_constref('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_constref(array(int32,ndim=1),int32,int32)')
  @staticmethod
  def emit_paramref(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1paramref__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1paramref__3III(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1paramref__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1paramref_alt__3III(*args)
    else:
      raise ValueError('Invalid argument list emit_paramref('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_paramref(array(int32,ndim=1),int32,int32)')
  @staticmethod
  def op2str(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_op2str_I(*args): # int32
      return mosek_fusion_ExprCode._op2str_I(*args)
    elif mosek_fusion_ExprCode._match_alt_op2str_I(*args): # int32
      return mosek_fusion_ExprCode._op2str_alt_I(*args)
    else:
      raise ValueError('Invalid argument list op2str('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.op2str(int32)')
  @staticmethod
  def emit_nop(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1nop__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1nop__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1nop__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1nop_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_nop('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_nop(array(int32,ndim=1),int32)')
  @staticmethod
  def emit_neg(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1neg__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1neg__3II(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1neg__3II(*args): # []int32,int32
      return mosek_fusion_ExprCode._emit_1neg_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list emit_neg('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_neg(array(int32,ndim=1),int32)')
  @staticmethod
  def emit_sum(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_emit_1sum__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1sum__3III(*args)
    elif mosek_fusion_ExprCode._match_alt_emit_1sum__3III(*args): # []int32,int32,int32
      return mosek_fusion_ExprCode._emit_1sum_alt__3III(*args)
    else:
      raise ValueError('Invalid argument list emit_sum('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.emit_sum(array(int32,ndim=1),int32,int32)')
  @staticmethod
  def inplace_relocate(*args):
    if False: pass
    elif mosek_fusion_ExprCode._match_inplace_1relocate__3IIII(*args): # []int32,int32,int32,int32
      return mosek_fusion_ExprCode._inplace_1relocate__3IIII(*args)
    elif mosek_fusion_ExprCode._match_alt_inplace_1relocate__3IIII(*args): # []int32,int32,int32,int32
      return mosek_fusion_ExprCode._inplace_1relocate_alt__3IIII(*args)
    else:
      raise ValueError('Invalid argument list inplace_relocate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCode.inplace_relocate(array(int32,ndim=1),int32,int32,int32)')
  def __repr__(self): return 'mosek.fusion.ExprCode'
  @staticmethod
  def _match_inplace_1relocate__3IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_inplace_1relocate__3IIII(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3))
  @staticmethod
  def _inplace_1relocate_alt__3IIII(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _1 = mosek_fusion_ExprCode._inplace_1relocate__3IIII(_0,_1,_2,_3)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _inplace_1relocate__3IIII(_0,_1,_2,_3):
   fragments._c_closure_282(_0,_3,_2) # src/fusion/Parameter.monty:3115:106-3120:7
  @staticmethod
  def _match_op2str_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_op2str_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _op2str_alt_I(_t__0):
    return mosek_fusion_ExprCode._op2str_I(numpy.int32(__0))
  @staticmethod
  def _op2str_I(_0):
   if (_0==0): # src/fusion/Parameter.monty:3103:16-32
    return ("NOP")
   elif (_0==1): # src/fusion/Parameter.monty:3104:16-34
    return ("PARAMREF")
   elif (_0==2): # src/fusion/Parameter.monty:3105:16-34
    return ("CONST")
   elif (_0==3): # src/fusion/Parameter.monty:3106:16-32
    return ("ADD")
   elif (_0==4): # src/fusion/Parameter.monty:3107:16-32
    return ("NEG")
   elif (_0==5): # src/fusion/Parameter.monty:3108:16-32
    return ("MUL")
   elif (_0==6): # src/fusion/Parameter.monty:3109:16-32
    return ("INV")
   elif (_0==8): # src/fusion/Parameter.monty:3110:16-32
    return ("SUM")
   else:
    return (mosek.fusion.Utils.StringBuffer()._a_S("?(")._a_I(_0)._a_S(")")._toString_())
  @staticmethod
  def _match_eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match_I__(_3) and __arg_match__3D__(_4) and __arg_match__3D__(_5) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_6))
  @staticmethod
  def _match_alt_eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match__3D__(_5) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_6))
  @staticmethod
  def _eval_1add_1list_alt__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=_t__6
   _1 = mosek_fusion_ExprCode._eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,_3,_4,_5,_6):
   _7=_6._allocf64_I(int((_0).shape[0]))
   _8=0
   _9=(_6.f64)
   _8 = fragments._c_closure_283(_5,_0,_2,_3,_1,_7,_8,_4,_9) # src/fusion/Parameter.monty:3059:8-3097:9
   _8 = numpy.int32(_8) # postprocess
   _6._clear_()
  @staticmethod
  def _match_eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2) and __arg_match__3D__(_3) and __arg_match__3D__(_4) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_5))
  @staticmethod
  def _match_alt_eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 6: return False
    _0,_1,_2,_3,_4,_5, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2) and __arg_alt_match__3D__(_3) and __arg_alt_match__3D__(_4) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_5))
  @staticmethod
  def _eval_1add_1list_alt__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprCode._eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _eval_1add_1list__3I_3I_3D_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,_3,_4,_5):
   mosek.fusion.ExprCode._eval_1add_1list__3I_3I_3DI_3D_3DLmosek_4fusion_4WorkStack_2(_0,_1,_2,0,_3,_4,_5)
  @staticmethod
  def _match_emit_1sum__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_emit_1sum__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _emit_1sum_alt__3III(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _1 = mosek_fusion_ExprCode._emit_1sum__3III(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1sum__3III(_0,_1,_2):
   _0[_1] = 8
   _0[(_1 + 1)] = _2
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1inv__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1inv__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1inv_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1inv__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1inv__3II(_0,_1):
   _0[_1] = 6
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1mul__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1mul__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1mul_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1mul__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1mul__3II(_0,_1):
   _0[_1] = 5
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1neg__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1neg__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1neg_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1neg__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1neg__3II(_0,_1):
   _0[_1] = 4
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1add__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1add__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1add_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1add__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1add__3II(_0,_1):
   _0[_1] = 3
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1constref__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_emit_1constref__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _emit_1constref_alt__3III(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _1 = mosek_fusion_ExprCode._emit_1constref__3III(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1constref__3III(_0,_1,_2):
   _0[_1] = 2
   _0[(_1 + 1)] = _2
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1paramref__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_emit_1paramref__3III(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _emit_1paramref_alt__3III(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _1 = mosek_fusion_ExprCode._emit_1paramref__3III(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1paramref__3III(_0,_1,_2):
   _0[_1] = 1
   _0[(_1 + 1)] = _2
   return numpy.int32(2)
  @staticmethod
  def _match_emit_1nop__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_emit_1nop__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _emit_1nop_alt__3II(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprCode._emit_1nop__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _emit_1nop__3II(_0,_1):
   _0[_1] = 0
   _0[(_1 + 1)] = 0
   return numpy.int32(2)
 return ExprCode
mosek_fusion_ExprCode=__mk_mosek_fusion_ExprCode()
del __mk_mosek_fusion_ExprCode
#BEFORE CLASS
def __mk_mosek_fusion_Param():
 class Param(object):
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Param._match_hstack__3Lmosek_4fusion_4Parameter_2(*args): # []mosek.fusion.Parameter
      return mosek_fusion_Param._hstack__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack__3Lmosek_4fusion_4Parameter_2(*args): # []mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_alt__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.hstack(array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.hstack(mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.hstack(mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Param._match_repeat_Lmosek_4fusion_4Parameter_2II(*args): # mosek.fusion.Parameter,int32,int32
      return mosek_fusion_Param._repeat_Lmosek_4fusion_4Parameter_2II(*args)
    elif mosek_fusion_Param._match_alt_repeat_Lmosek_4fusion_4Parameter_2II(*args): # mosek.fusion.Parameter,int32,int32
      return mosek_fusion_Param._repeat_alt_Lmosek_4fusion_4Parameter_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.repeat(mosek.fusion.Parameter,int32,int32)')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Param._match_vstack__3Lmosek_4fusion_4Parameter_2(*args): # []mosek.fusion.Parameter
      return mosek_fusion_Param._vstack__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack__3Lmosek_4fusion_4Parameter_2(*args): # []mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_alt__3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.vstack(array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.vstack(mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.vstack(mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Param._match_stack__3_3Lmosek_4fusion_4Parameter_2(*args): # [][]mosek.fusion.Parameter
      return mosek_fusion_Param._stack__3_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack__3_3Lmosek_4fusion_4Parameter_2(*args): # [][]mosek.fusion.Parameter
      return mosek_fusion_Param._stack_alt__3_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_I_3Lmosek_4fusion_4Parameter_2(*args): # int32,[]mosek.fusion.Parameter
      return mosek_fusion_Param._stack_I_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_I_3Lmosek_4fusion_4Parameter_2(*args): # int32,[]mosek.fusion.Parameter
      return mosek_fusion_Param._stack_alt_I_3Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # int32,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # int32,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # int32,mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Param._match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args): # int32,mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter
      return mosek_fusion_Param._stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Param.stack(array(array(mosek.fusion.Parameter,ndim=1),ndim=1))\n\tmosek.fusion.Param.stack(int32,array(mosek.fusion.Parameter,ndim=1))\n\tmosek.fusion.Param.stack(int32,mosek.fusion.Parameter,mosek.fusion.Parameter)\n\tmosek.fusion.Param.stack(int32,mosek.fusion.Parameter,mosek.fusion.Parameter,mosek.fusion.Parameter)')
  def __repr__(self): return 'mosek.fusion.Param'
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Parameter_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Parameter_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Parameter_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Param._repeat_Lmosek_4fusion_4Parameter_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Parameter_2II(_0,_1,_2):
   return (mosek.fusion.Param._stack_I_3Lmosek_4fusion_4Parameter_2(_2,numpy.array([_0 for _3 in range(0,_1)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_2) and __arg_match_Lmosek_4fusion_4Parameter_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2,_3):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_1,_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Param._stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_1,_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Param._stack_I_3Lmosek_4fusion_4Parameter_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_1,_0))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Parameter_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Param._stack__3_3Lmosek_4fusion_4Parameter_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Parameter_2(_0):
   return (mosek.fusion.Param._vstack__3Lmosek_4fusion_4Parameter_2(numpy.array([mosek.fusion.Param._hstack__3Lmosek_4fusion_4Parameter_2(_0[_1]) for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Param._hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Parameter_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Param._hstack__3Lmosek_4fusion_4Parameter_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Parameter_2(_0):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_0,1))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1,_2):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Param._vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Parameter_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Parameter_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Param._vstack__3Lmosek_4fusion_4Parameter_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Parameter_2(_0):
   return (mosek.fusion.Param._dstack__3Lmosek_4fusion_4Parameter_2I(_0,0))
  @staticmethod
  def _dstack_alt__3Lmosek_4fusion_4Parameter_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Param._dstack__3Lmosek_4fusion_4Parameter_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dstack__3Lmosek_4fusion_4Parameter_2I(_0,_1):
   if (_1 < 0): # src/fusion/Parameter.monty:2857:12-19
    raise mosek_fusion_IndexError._ctor_S("Invalid stacking dimension")
   _2=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((int((_0).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _5=_0[0]._getND_()
   for _6 in range(1,int((_0).shape[0])):
    if (_5 < _0[_6]._getND_()): # src/fusion/Parameter.monty:2863:60-78
     _5 = _0[_6]._getND_()
   if (_1 < _5): # src/fusion/Parameter.monty:2864:12-21
    _7=0
    while ((_7 < int((_0).shape[0])) and (_5!=_0[_7]._getND_())):
     _7 += 1
    _4 = _0[_7]._getShape_()
    _8=0
    while ((_8 < int((_0).shape[0])) and (_5!=_0[_8]._getND_())):
     _8 += 1
    _4 = _0[_8]._getShape_()
   else:
    _4 = numpy.array([1 for _9 in range(0,(_1 + 1))], dtype=numpy.dtype(numpy.int32))
    _10=0
    while ((_10 < int((_0).shape[0])) and (_5!=_0[_10]._getND_())):
     _10 += 1
    _11=_0[_10]._getND_()
    _12=_0[_10]._getShape_()
    fragments._c_closure_284(_11,_4,_12) # src/fusion/Parameter.monty:2878:12-55
   _5 = int((_4).shape[0])
   _13=0
   _14=False
   for _15 in range(0,int((_0).shape[0])):
    _16=_0[_15]._getShape_()
    _3[_15] = mosek.fusion.Set._size__3I(_16)
    _14 = fragments._c_closure_285(_1,_14,_4,_16) # src/fusion/Parameter.monty:2888:12-2889:71
    _14,_13 = fragments._c_closure_286(_1,_14,_13,_2,_15,_5,_4,_16) # src/fusion/Parameter.monty:2890:12-2899:13
    _13 = numpy.int32(_13) # postprocess
   if _14: # src/fusion/Parameter.monty:2901:14-20
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions for stacking")
   _4[_1] = _13
   _17=numpy.array([_0[_18]._getNumNonzero_() for _18 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _19=0
   _19 = fragments._c_closure_287(_17,_19) # src/fusion/Parameter.monty:2907:22-65
   _19 = numpy.int32(_19) # postprocess
   _20=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int64))
   _21=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _22=1
   _22 = fragments._c_closure_288(_1,_22,_4) # src/fusion/Parameter.monty:2912:28-67
   _22 = numpy.int64(_22) # postprocess
   _23=_13
   _24=1
   _24 = fragments._c_closure_289(_1,_24,_5,_4) # src/fusion/Parameter.monty:2914:28-71
   _24 = numpy.int64(_24) # postprocess
   _25=0
   _26=0
   for _27 in range(0,int((_0).shape[0])):
    _28=_0[_27]._getNumNonzero_()
    _0[_27]._getSp__3JI(_20,_25)
    _0[_27]._getAllIndexes__3II(_21,_25)
    _26 = fragments._c_closure_290(_1,_24,_13,_2,_27,_3,_28,_25,_26,_20) # src/fusion/Parameter.monty:2923:12-2937:13
    _26 = numpy.int64(_26) # postprocess
    _25 += _28
   _29=_4[0]
   _29 = fragments._c_closure_291(_29,_5,_4) # src/fusion/Parameter.monty:2945:34-98
   _29 = numpy.int32(_29) # postprocess
   _30=numpy.zeros(((_29 + 1),), dtype=numpy.dtype(numpy.int32))
   _31=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _32=numpy.zeros((_19,), dtype=numpy.dtype(numpy.int32))
   _33=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int64))
   _33[(_5 - 1)] = 1
   fragments._c_closure_292(_5,_4,_33) # src/fusion/Parameter.monty:2949:59-132
   fragments._c_closure_293(_31,_19) # src/fusion/Parameter.monty:2950:8-42
   for _34 in range(0,_5):
    _35=((_5 - _34) - 1)
    fragments._c_closure_294(_29,_30) # src/fusion/Parameter.monty:2953:10-48
    fragments._c_closure_295(_35,_30,_19,_4,_33,_20) # src/fusion/Parameter.monty:2954:10-73
    fragments._c_closure_296(_29,_30) # src/fusion/Parameter.monty:2955:10-54
    fragments._c_closure_297(_35,_31,_32,_30,_19,_4,_33,_20) # src/fusion/Parameter.monty:2956:10-124
    _36=_32
    _32 = _31
    _31 = _36
   _37=numpy.array([_20[_31[_38]] for _38 in range(0,_19)], dtype=numpy.dtype(numpy.int64))
   _39=numpy.array([_21[_31[_40]] for _40 in range(0,_19)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(_0[0]._getModel_(),_4,_37,_39))
 return Param
mosek_fusion_Param=__mk_mosek_fusion_Param()
del __mk_mosek_fusion_Param
#BEFORE CLASS
def __mk_mosek_fusion_ParameterImpl():
 class ParameterImpl(mosek_fusion_Parameter,object):
  __slots__ = ['_ParameterImpl__size','_ParameterImpl__nidxs','_ParameterImpl__sp','_ParameterImpl__shape','_ParameterImpl__model']
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_ParameterImpl._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_ParameterImpl._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.slice(int32,int32)\n\tmosek.fusion.ParameterImpl.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getND()')
  def asExpr(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_asExpr_(*args): # 
      return self._asExpr_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_asExpr_(*args): # 
      return self._asExpr_alt_(*args)
    else:
      raise ValueError('Invalid argument list asExpr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.asExpr()')
  def clone(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_clone_Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Model
      return self._clone_Lmosek_4fusion_4Model_2(*args)
    elif mosek_fusion_ParameterImpl._match_alt_clone_Lmosek_4fusion_4Model_2(*args): # mosek.fusion.Model
      return self._clone_alt_Lmosek_4fusion_4Model_2(*args)
    else:
      raise ValueError('Invalid argument list clone('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.clone(mosek.fusion.Model)')
  def reshape(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_reshape__3I(*args): # []int32
      return self._reshape__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_reshape__3I(*args): # []int32
      return self._reshape_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.reshape(array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.toString()')
  def getNumNonzero(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getNumNonzero_(*args): # 
      return self._getNumNonzero_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getNumNonzero_(*args): # 
      return self._getNumNonzero_alt_(*args)
    else:
      raise ValueError('Invalid argument list getNumNonzero('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getNumNonzero()')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getDim(int32)')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getSize()')
  def getSp(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getSp__3JI(*args): # []int64,int32
      return self._getSp__3JI(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getSp__3JI(*args): # []int64,int32
      return self._getSp_alt__3JI(*args)
    else:
      raise ValueError('Invalid argument list getSp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getSp(array(int64,ndim=1),int32)')
  def setValue(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_setValue_D(*args): # double
      return self._setValue_D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue_D(*args): # double
      return self._setValue_alt_D(*args)
    elif mosek_fusion_ParameterImpl._match_setValue__3D(*args): # []double
      return self._setValue__3D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue__3D(*args): # []double
      return self._setValue_alt__3D(*args)
    elif mosek_fusion_ParameterImpl._match_setValue__3_5D(*args): # [,]double
      return self._setValue__3_5D(*args)
    elif mosek_fusion_ParameterImpl._match_alt_setValue__3_5D(*args): # [,]double
      return self._setValue_alt__3_5D(*args)
    else:
      raise ValueError('Invalid argument list setValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.setValue(double)\n\tmosek.fusion.ParameterImpl.setValue(array(double,ndim=1))\n\tmosek.fusion.ParameterImpl.setValue(array(double,ndim=2))')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_ParameterImpl._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.pick(array(int32,ndim=1))\n\tmosek.fusion.ParameterImpl.pick(array(int32,ndim=2))')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_ParameterImpl._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.index(int32)\n\tmosek.fusion.ParameterImpl.index(array(int32,ndim=1))')
  def getValue(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getValue_(*args): # 
      return self._getValue_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getValue_(*args): # 
      return self._getValue_alt_(*args)
    else:
      raise ValueError('Invalid argument list getValue('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getValue()')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.isSparse()')
  def getIndex(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getIndex_I(*args): # int32
      return self._getIndex_I(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getIndex_I(*args): # int32
      return self._getIndex_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getIndex('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getIndex(int32)')
  def getModel(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getModel_(*args): # 
      return self._getModel_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getModel_(*args): # 
      return self._getModel_alt_(*args)
    else:
      raise ValueError('Invalid argument list getModel('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getModel()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ParameterImpl._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getShape()')
  def getAllIndexes(self,*args):
    if False: pass
    elif mosek_fusion_ParameterImpl._match_getAllIndexes__3II(*args): # []int32,int32
      return self._getAllIndexes__3II(*args)
    elif mosek_fusion_ParameterImpl._match_alt_getAllIndexes__3II(*args): # []int32,int32
      return self._getAllIndexes_alt__3II(*args)
    else:
      raise ValueError('Invalid argument list getAllIndexes('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ParameterImpl.getAllIndexes(array(int32,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.ParameterImpl'
  @staticmethod
  def _ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model):
    o = ParameterImpl.__new__(ParameterImpl)
    o._ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    other,model, = args
    return (__arg_match_Lmosek_4fusion_4ParameterImpl_2__(other) and __arg_match_Lmosek_4fusion_4Model_2__(model))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(*args):
    if len(args) != 2: return False
    other,model, = args
    return (__arg_alt_match_Lmosek_4fusion_4ParameterImpl_2__(other) and __arg_alt_match_Lmosek_4fusion_4Model_2__(model))
  def _ctor_alt_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,other,model):
    self._ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(other,model)
  def _ctor_init_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,other,model):
   (self.__model) = model
   (self.__shape) = (other.__shape)
   (self.__sp) = (other.__sp)
   (self.__size) = (other.__size)
   (self.__nidxs) = (other.__nidxs)
  @staticmethod
  def _ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(model,shape,sp,nidxs):
    o = ParameterImpl.__new__(ParameterImpl)
    o._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(model,shape,sp,nidxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(*args):
    if len(args) != 4: return False
    model,shape,sp,nidxs, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(model) and __arg_match__3I__(shape) and __arg_match__3J__(sp) and __arg_match__3I__(nidxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(*args):
    if len(args) != 4: return False
    model,shape,sp,nidxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(model) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sp) and __arg_alt_match__3I__(nidxs))
  def _ctor_alt_init_Lmosek_4fusion_4Model_2_3I_3J_3I(self,model,shape,sp,nidxs):
    self._ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(model,numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sp,dtype=numpy.dtype(numpy.int64)),numpy.array(nidxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Model_2_3I_3J_3I(self,model,shape,sp,nidxs):
   (self.__model) = model
   (self.__shape) = mosek.fusion.Utils.Tools._arraycopy__3I(shape)
   (self.__sp) = sp
   (self.__size) = mosek.fusion.Set._size__3I(shape)
   (self.__nidxs) = mosek.fusion.Utils.Tools._arraycopy__3I(nidxs)
  @staticmethod
  def _match_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0))
  @staticmethod
  def _match_alt_clone_Lmosek_4fusion_4Model_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0))
  def _clone_alt_Lmosek_4fusion_4Model_2(self,_t__0):
    return self._clone_Lmosek_4fusion_4Model_2(_0)
  def _clone_Lmosek_4fusion_4Model_2(self,_0):
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4ParameterImpl_2Lmosek_4fusion_4Model_2(self,_0))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("Parameter((")
   if (int((self.__shape).shape[0]) > 0): # src/fusion/Parameter.monty:402:12-26
    _0._a_I(self.__shape[0])
    for _1 in range(1,int((self.__shape).shape[0])):
     _0._a_S(",")._a_I(self.__shape[_1])
   _0._a_S(")")
   if (self.__sp is not None): # src/fusion/Parameter.monty:408:12-22
    _0._a_S(",sparse")
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   raise mosek_fusion_UnimplementedError._ctor_S("Not implemented")
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   raise mosek_fusion_UnimplementedError._ctor_S("Not implemented")
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   if (int((self.__shape).shape[0])!=int((_0).shape[0])): # src/fusion/Parameter.monty:364:12-38
    raise mosek_fusion_DimensionError._ctor_S("Index has incorrect dimension")
   else:
    for _1 in range(0,int((_0).shape[0])):
     if ((_0[_1] < 0) or (_0[_1] >= self.__shape[_1])): # src/fusion/Parameter.monty:368:16-56
      raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   if (self.__sp is None): # src/fusion/Parameter.monty:371:12-22
    _2=int((_0).shape[0])
    _3=_0[(_2 - 1)]
    _3 = fragments._c_closure_298(_0,_3,_2,self.__shape) # src/fusion/Parameter.monty:374:10-70
    _3 = numpy.int64(_3) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_3]], dtype=numpy.dtype(numpy.int32))))
   else:
    _4=int((_0).shape[0])
    _5=_0[(_4 - 1)]
    _5 = fragments._c_closure_299(_0,_5,_4,self.__shape) # src/fusion/Parameter.monty:381:10-70
    _5 = numpy.int64(_5) # postprocess
    _6=0
    _6 = fragments._c_closure_300(_5,_6,self.__sp) # src/fusion/Parameter.monty:383:21-60
    _6 = numpy.int32(_6) # postprocess
    if ((_6 < int((self.__sp).shape[0])) and (self.__sp[_6]==_5)): # src/fusion/Parameter.monty:384:14-41
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_6]], dtype=numpy.dtype(numpy.int32))))
    else:
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   if (int((self.__shape).shape[0])!=1): # src/fusion/Parameter.monty:346:12-27
    raise mosek_fusion_DimensionError._ctor_S("Index has incorrect dimension")
   elif ((_0 < 0) or (_0 >= self.__shape[0])): # src/fusion/Parameter.monty:348:16-38
    raise mosek_fusion_IndexError._ctor_S("Index out of bounds")
   if (self.__sp is None): # src/fusion/Parameter.monty:351:12-22
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_0]], dtype=numpy.dtype(numpy.int32))))
   else:
    _1=0
    _1 = fragments._c_closure_301(_0,_1,self.__sp) # src/fusion/Parameter.monty:355:21-59
    _1 = numpy.int32(_1) # postprocess
    if ((_1 < int((self.__sp).shape[0])) and (self.__sp[_1]==_0)): # src/fusion/Parameter.monty:356:14-40
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_1]], dtype=numpy.dtype(numpy.int32))))
    else:
     return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__shape).shape[0])
   _4=int((self.__nidxs).shape[0])
   _5=(self.__sp is not None)
   _0._alloc_1expr_IIIZI(_3,_4,int((self.__nidxs).shape[0]),_5,int((self.__nidxs).shape[0]))
   _6=(_0.i32)
   _7=(_0.i64)
   _8=(_0.f64)
   _9=(_0.ptr_base)
   _10=(_0.nidxs_base)
   _11=(_0.cof_base)
   _12=(_0.shape_base)
   _13=(_0.codeptr_base)
   _14=(_0.code_base)
   _15=(_0.cconst_base)
   _16=(_0.sp_base)
   fragments._c_closure_302(_5,_3,_4,self.__nidxs,_15,_14,_13,_11,_8,_6,_7,_10,_9,_12,_16,self.__shape,self.__sp) # src/fusion/Parameter.monty:326:8-341:9
  @staticmethod
  def _match_getSp__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3J__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_getSp__3JI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3J__(_0) and __arg_alt_match_I__(_1))
  def _getSp_alt__3JI(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.int32(_t__1)
   _1 = self._getSp__3JI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getSp__3JI(self,_0,_1):
   fragments._c_closure_303(_0,self.__nidxs,_1,self.__sp) # src/fusion/Parameter.monty:294:59-301:7
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return ((self.__sp is not None))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((self.__shape).shape[0]))): # src/fusion/Parameter.monty:235:12-66
    raise mosek_fusion_DimensionError._ctor_S("Invalid index dimension")
   _2=int((_0).shape[0])
   for _3 in range(0,_2):
    if ((_0[_3] < 0) or ((_0[_3] >= _1[_3]) or (_1[_3] > self.__shape[_3]))): # src/fusion/Parameter.monty:239:14-75
     raise mosek_fusion_IndexError._ctor_S("Invalid index")
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _4[(_2 - 1)] = 1
   fragments._c_closure_304(_2,self.__shape,_4) # src/fusion/Parameter.monty:241:53-114
   _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([(_1[_7] - _0[_7]) for _7 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   if (self.__sp is None): # src/fusion/Parameter.monty:245:12-22
    _8=1
    _8 = fragments._c_closure_305(_8,_2,_6) # src/fusion/Parameter.monty:246:25-64
    _8 = numpy.int32(_8) # postprocess
    _9=numpy.zeros((_8,), dtype=numpy.dtype(numpy.int32))
    _10=0
    _10 = fragments._c_closure_306(_0,_1,_5,_10,_2,self.__nidxs,_9,self.__shape,_4) # src/fusion/Parameter.monty:251:10-259:11
    _10 = numpy.int32(_10) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_6,None,_9))
   else:
    _11=0
    _11 = fragments._c_closure_307(_0,_1,_11,_5,_2,self.__nidxs,self.__shape,self.__sp,_4) # src/fusion/Parameter.monty:264:10-269:11
    _11 = numpy.int32(_11) # postprocess
    _12=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int32))
    _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
    _14=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
    _14[(_2 - 1)] = 1
    fragments._c_closure_308(_2,_6,_14) # src/fusion/Parameter.monty:274:57-121
    _15=0
    _15 = fragments._c_closure_309(_0,_1,_5,_15,_2,self.__nidxs,_12,_13,_14,self.__shape,self.__sp,_4) # src/fusion/Parameter.monty:277:10-287:11
    _15 = numpy.int32(_15) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_6,_13,_12))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   if (int((self.__shape).shape[0])!=1): # src/fusion/Parameter.monty:208:12-27
    raise mosek_fusion_DimensionError._ctor_S("Invalid index dimension")
   if ((_0 < 0) or ((_1 >= _1) or (_1 > self.__size))): # src/fusion/Parameter.monty:210:12-52
    raise mosek_fusion_IndexError._ctor_S("Invalid index")
   if (self.__sp is None): # src/fusion/Parameter.monty:213:12-22
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.array([0,(_1 - _0)], dtype=numpy.dtype(numpy.int32)),None,numpy.array([self.__nidxs[_2] for _2 in range(_0,_1)], dtype=numpy.dtype(numpy.int32))))
   else:
    _3=0
    _3 = fragments._c_closure_310(_3,self.__sp,_0,_1) # src/fusion/Parameter.monty:218:10-220:22
    _3 = numpy.int32(_3) # postprocess
    _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
    _6=0
    _6 = fragments._c_closure_311(_6,self.__nidxs,_4,_5,self.__sp,_0,_1) # src/fusion/Parameter.monty:224:10-229:13
    _6 = numpy.int32(_6) # postprocess
    return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,numpy.array([0,(_1 - _0)], dtype=numpy.dtype(numpy.int32)),_5,_4))
  @staticmethod
  def _match_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_reshape__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _reshape_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._reshape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _reshape__3I(self,_0):
   if (mosek.fusion.Set._size__3I(_0)!=mosek.fusion.Set._size__3I(self.__shape)): # src/fusion/Parameter.monty:202:12-45
    raise mosek_fusion_DimensionError._ctor_S("Incompatible shape for resize")
   return (mosek_fusion_ParameterImpl._ctor_Lmosek_4fusion_4Model_2_3I_3J_3I(self.__model,_0,self.__sp,self.__nidxs))
  @staticmethod
  def _match_asExpr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_asExpr_(*args):
    if len(args) != 0: return False
    return True
  def _asExpr_alt_(self,):
    return self._asExpr_()
  def _asExpr_(self,):
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(mosek.fusion.Set._size__3I(self.__shape))
  @staticmethod
  def _match_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getNumNonzero_(*args):
    if len(args) != 0: return False
    return True
  def _getNumNonzero_alt_(self,):
    return self._getNumNonzero_()
  def _getNumNonzero_(self,):
   return numpy.int32(int((self.__nidxs).shape[0]))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   return numpy.int32(self.__shape[_0])
  @staticmethod
  def _match_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_getAllIndexes__3II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_I__(_1))
  def _getAllIndexes_alt__3II(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.int32(_t__1)
   _1 = self._getAllIndexes__3II(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getAllIndexes__3II(self,_0,_1):
   fragments._c_closure_312(_0,self.__nidxs,_1) # src/fusion/Parameter.monty:188:58-191:7
  @staticmethod
  def _match_getIndex_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getIndex_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getIndex_alt_I(self,_t__0):
    return self._getIndex_I(numpy.int32(__0))
  def _getIndex_I(self,_0):
   return numpy.int32(self.__nidxs[_0])
  @staticmethod
  def _match_getValue_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getValue_(*args):
    if len(args) != 0: return False
    return True
  def _getValue_alt_(self,):
    return self._getValue_()
  def _getValue_(self,):
   return (self.__model._getParameterValue__3I(self.__nidxs))
  @staticmethod
  def _match_setValue__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_setValue__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  def _setValue_alt__3_5D(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = self._setValue__3_5D(_0)
   return _1
  def _setValue__3_5D(self,_0):
   if ((self._getND_()!=2) or ((int((_0).shape[0])!=self.__shape[0]) or (int((_0).shape[1])!=self.__shape[1]))): # src/fusion/Parameter.monty:159:12-84
    raise mosek_fusion_LengthError._ctor_S("Mismatching value shape")
   if (self.__sp is None): # src/fusion/Parameter.monty:162:12-22
    _1=numpy.zeros(((self.__shape[0] * self.__shape[1]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_313(self.__shape,_1,_0) # src/fusion/Parameter.monty:164:10-166:48
    self.__model._setParameterValue__3I_3D(self.__nidxs,_1)
   else:
    _2=numpy.zeros((int((self.__sp).shape[0]),), dtype=numpy.dtype(numpy.float64))
    fragments._c_closure_314(self.__shape,self.__sp,_2,_0) # src/fusion/Parameter.monty:171:10-173:11
    self.__model._setParameterValue__3I_3D(self.__nidxs,_2)
  @staticmethod
  def _match_setValue__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_setValue__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  def _setValue_alt__3D(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = self._setValue__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _setValue__3D(self,_0):
   if (self.__sp is None): # src/fusion/Parameter.monty:140:12-22
    if (int((_0).shape[0])!=int((self.__nidxs).shape[0])): # src/fusion/Parameter.monty:141:14-39
     raise mosek_fusion_LengthError._ctor_S("Length of value array is incorrect")
    else:
     self.__model._setParameterValue__3I_3D(self.__nidxs,_0)
   else:
    if (int((_0).shape[0])!=self._getSize_()): # src/fusion/Parameter.monty:147:14-38
     raise mosek_fusion_LengthError._ctor_S("Length of value array is incorrect")
    else:
     _1=numpy.zeros((int((self.__nidxs).shape[0]),), dtype=numpy.dtype(numpy.float64))
     fragments._c_closure_315(_1,self.__nidxs,self.__sp,_0) # src/fusion/Parameter.monty:151:12-152:39
     self.__model._setParameterValue__3I_3D(self.__nidxs,_1)
  @staticmethod
  def _match_setValue_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_setValue_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _setValue_alt_D(self,_t__0):
    return self._setValue_D(numpy.float64(__0))
  def _setValue_D(self,_0):
   _1=numpy.zeros((self.__size,), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_316(self.__size,_1,_0) # src/fusion/Parameter.monty:134:8-135:26
   self.__model._setParameterValue__3I_3D(self.__nidxs,_1)
  @staticmethod
  def _match_getModel_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getModel_(*args):
    if len(args) != 0: return False
    return True
  def _getModel_alt_(self,):
    return self._getModel_()
  def _getModel_(self,):
   return (self.__model)
 return ParameterImpl
mosek_fusion_ParameterImpl=__mk_mosek_fusion_ParameterImpl()
del __mk_mosek_fusion_ParameterImpl
#BEFORE CLASS
def __mk_mosek_fusion_BaseExpression():
 class BaseExpression(mosek_fusion_Expression,object):
  __slots__ = ['_BaseExpression__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I(*args): # []int32
      self._ctor_init__3I(*args)
    elif self.__match_alt_ctor__3I(*args):# []int32
      self._ctor_alt_init__3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.BaseExpression.ctor(array(int32,ndim=1))')
  def pick(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_pick__3I(*args): # []int32
      return self._pick__3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_pick__3I(*args): # []int32
      return self._pick_alt__3I(*args)
    elif mosek_fusion_BaseExpression._match_pick__3_5I(*args): # [,]int32
      return self._pick__3_5I(*args)
    elif mosek_fusion_BaseExpression._match_alt_pick__3_5I(*args): # [,]int32
      return self._pick_alt__3_5I(*args)
    else:
      raise ValueError('Invalid argument list pick('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.pick(array(int32,ndim=1))\n\tmosek.fusion.BaseExpression.pick(array(int32,ndim=2))')
  def index(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_index_I(*args): # int32
      return self._index_I(*args)
    elif mosek_fusion_BaseExpression._match_alt_index_I(*args): # int32
      return self._index_alt_I(*args)
    elif mosek_fusion_BaseExpression._match_index__3I(*args): # []int32
      return self._index__3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_index__3I(*args): # []int32
      return self._index_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list index('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.index(int32)\n\tmosek.fusion.BaseExpression.index(array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_BaseExpression._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.toString()')
  def getSize(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getSize_(*args): # 
      return self._getSize_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getSize_(*args): # 
      return self._getSize_alt_(*args)
    else:
      raise ValueError('Invalid argument list getSize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getSize()')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_BaseExpression._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_BaseExpression._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_BaseExpression._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.slice(int32,int32)\n\tmosek.fusion.BaseExpression.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def getND(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getND_(*args): # 
      return self._getND_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getND_(*args): # 
      return self._getND_alt_(*args)
    else:
      raise ValueError('Invalid argument list getND('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getND()')
  def getDim(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getDim_I(*args): # int32
      return self._getDim_I(*args)
    elif mosek_fusion_BaseExpression._match_alt_getDim_I(*args): # int32
      return self._getDim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list getDim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getDim(int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_BaseExpression._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def getShape(self,*args):
    if False: pass
    elif mosek_fusion_BaseExpression._match_getShape_(*args): # 
      return self._getShape_(*args)
    elif mosek_fusion_BaseExpression._match_alt_getShape_(*args): # 
      return self._getShape_alt_(*args)
    else:
      raise ValueError('Invalid argument list getShape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.BaseExpression.getShape()')
  def __repr__(self): return 'mosek.fusion.BaseExpression'
  @staticmethod
  def _ctor__3I(shape):
    o = BaseExpression.__new__(BaseExpression)
    o._ctor_init__3I(shape)
    return o
  @staticmethod
  def __match_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_match__3I__(shape))
  @staticmethod
  def __match_alt_ctor__3I(*args):
    if len(args) != 1: return False
    shape, = args
    return (__arg_alt_match__3I__(shape))
  def _ctor_alt_init__3I(self,shape):
    self._ctor_init__3I(numpy.array(shape,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init__3I(self,shape):
   (self.__shape) = shape
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("Expression()")
  def _printStack_alt_Lmosek_4fusion_4WorkStack_2(self,_t__0):
    return self._printStack_Lmosek_4fusion_4WorkStack_2(_0)
  def _printStack_Lmosek_4fusion_4WorkStack_2(self,_0):
   _1=(_0.i32)
   _2=(_0.i64)
   _3=(_0.f64)
   _4=(_0.ptr_base)
   _5=(_0.nidxs_base)
   _6=(_0.cof_base)
   _7=(_0.shape_base)
   _8=(_0.codeptr_base)
   _9=(_0.code_base)
   _10=(_0.cconst_base)
   _11=(_0.sp_base)
   _12=(_0.nelem)
   _13=(_0.nnz)
   _14=(_0.ncodeatom)
   _15=(_0.nd)
   _16=(_0.hassp)
   mosek.fusion.Debug._o_()._p_S("### ")._p_S(self._toString_())._p_S(" ###")._lf_()._p_S("  nelem     = ")._p_I(_12)._lf_()._p_S("  nnz       = ")._p_I(_13)._lf_()._p_S("  hassp     = ")._p_Z(_16)._p_S(" / ")._p_I(_1[(((_0.pi32) - _15) - 4)])._lf_()._p_S("  shape     = ")._p__3I(numpy.array([_1[(_7 + _17)] for _17 in range(0,_15)], dtype=numpy.dtype(numpy.int32)))._lf_()._p_S("  ptr       = ")._p__3I(numpy.array([_1[(_4 + _18)] for _18 in range(0,(_12 + 1))], dtype=numpy.dtype(numpy.int32)))._lf_()
   if (_0.hassp): # src/fusion/BaseExpression.monty:463:12-20
    mosek.fusion.Debug._o_()._p_S("  sp       = ")._p__3J(numpy.array([_2[(_11 + _19)] for _19 in range(0,_12)], dtype=numpy.dtype(numpy.int64)))._lf_()
   for _20 in range(0,_12):
    mosek.fusion.Debug._o_()._p_S("  row[")._p_I(_20)._p_S("]")._lf_()
    mosek.fusion.Debug._o_()._p_S("    nidx : ")._p__3J(numpy.array([_2[(_5 + _21)] for _21 in range(_1[(_4 + _20)],_1[((_4 + _20) + 1)])], dtype=numpy.dtype(numpy.int64)))._lf_()._p_S("    cof  : ")._p__3D(numpy.array([_3[(_6 + _22)] for _22 in range(_1[(_4 + _20)],_1[((_4 + _20) + 1)])], dtype=numpy.dtype(numpy.float64)))._lf_()
    if (_14 > 0): # src/fusion/BaseExpression.monty:473:14-28
     for _23 in range(_1[(_4 + _20)],_1[((_4 + _20) + 1)]):
      mosek.fusion.Debug._o_()._p_S("      code[")._p_J(_2[(_5 + _23)])._p_S("] ")._p__3I(numpy.array([_1[(_9 + _24)] for _24 in range(_1[(_8 + _23)],_1[((_8 + _23) + 1)])], dtype=numpy.dtype(numpy.int32)))._p__3D(numpy.array([_3[(_10 + _25)] for _25 in range(_1[(_8 + _23)],_1[((_8 + _23) + 1)])], dtype=numpy.dtype(numpy.float64)))._lf_()
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5I__(_0))
  @staticmethod
  def _match_alt_pick__3_5I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5I__(_0))
  def _pick_alt__3_5I(self,_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3_5I(_0)
   return _1
  def _pick__3_5I(self,_0):
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_0))
  @staticmethod
  def _match_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_pick__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _pick_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._pick__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _pick__3I(self,_0):
   _1=numpy.zeros((int((_0).shape[0]),1,), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_317(_1,_0) # src/fusion/BaseExpression.monty:427:45-98
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_index__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  def _index_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self._index__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _index__3I(self,_0):
   _1=numpy.zeros((1,int((_0).shape[0]),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_318(_1,_0) # src/fusion/BaseExpression.monty:423:45-98
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_index_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _index_alt_I(self,_t__0):
    return self._index_I(numpy.int32(__0))
  def _index_I(self,_0):
   _1=numpy.zeros((1,1,), dtype=numpy.dtype(numpy.int32))
   _1[0,0] = _0
   return (mosek_fusion_ExprPick._ctor_Lmosek_4fusion_4Expression_2_3_5I(self,_1))
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   return (mosek_fusion_ExprSlice._ctor_Lmosek_4fusion_4Expression_2_3I_3I(self,_0,_1))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_ExprSlice._ctor_Lmosek_4fusion_4Expression_2_3I_3I(self,numpy.array([_0], dtype=numpy.dtype(numpy.int32)),numpy.array([_1], dtype=numpy.dtype(numpy.int32))))
  @staticmethod
  def _match_getSize_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getSize_(*args):
    if len(args) != 0: return False
    return True
  def _getSize_alt_(self,):
    return self._getSize_()
  def _getSize_(self,):
   return numpy.int64(mosek.fusion.Set._size__3I(self.__shape))
  @staticmethod
  def _match_getND_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getND_(*args):
    if len(args) != 0: return False
    return True
  def _getND_alt_(self,):
    return self._getND_()
  def _getND_(self,):
   return numpy.int32(int((self.__shape).shape[0]))
  @staticmethod
  def _match_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_getDim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _getDim_alt_I(self,_t__0):
    return self._getDim_I(numpy.int32(__0))
  def _getDim_I(self,_0):
   return numpy.int32(self.__shape[_0])
  @staticmethod
  def _match_getShape_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getShape_(*args):
    if len(args) != 0: return False
    return True
  def _getShape_alt_(self,):
    return self._getShape_()
  def _getShape_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3I(self.__shape))
 return BaseExpression
mosek_fusion_BaseExpression=__mk_mosek_fusion_BaseExpression()
del __mk_mosek_fusion_BaseExpression
#BEFORE CLASS
def __mk_mosek_fusion_ExprParameter():
 class ExprParameter(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprParameter__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Parameter
      self._ctor_init_Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2(*args):# mosek.fusion.Parameter
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprParameter.ctor(mosek.fusion.Parameter)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprParameter._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprParameter._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def slice(self,*args):
    if False: pass
    elif mosek_fusion_ExprParameter._match_slice_II(*args): # int32,int32
      return self._slice_II(*args)
    elif mosek_fusion_ExprParameter._match_alt_slice_II(*args): # int32,int32
      return self._slice_alt_II(*args)
    elif mosek_fusion_ExprParameter._match_slice__3I_3I(*args): # []int32,[]int32
      return self._slice__3I_3I(*args)
    elif mosek_fusion_ExprParameter._match_alt_slice__3I_3I(*args): # []int32,[]int32
      return self._slice_alt__3I_3I(*args)
    else:
      raise ValueError('Invalid argument list slice('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.slice(int32,int32)\n\tmosek.fusion.ExprParameter.slice(array(int32,ndim=1),array(int32,ndim=1))')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprParameter._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprParameter._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprParameter.toString()')
  def __repr__(self): return 'mosek.fusion.ExprParameter'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2(p):
    o = ExprParameter.__new__(ExprParameter)
    o._ctor_init_Lmosek_4fusion_4Parameter_2(p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    p, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 1: return False
    p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2(self,p):
    self._ctor_init_Lmosek_4fusion_4Parameter_2(p)
  def _ctor_init_Lmosek_4fusion_4Parameter_2(self,p):
   mosek_fusion_BaseExpression._ctor_init__3I(self,p._getShape_())
   (self.__p) = p
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__p._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  @staticmethod
  def _match_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_slice__3I_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1))
  def _slice_alt__3I_3I(self,_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = self._slice__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _slice__3I_3I(self,_0,_1):
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self.__p._slice__3I_3I(_0,_1)))
  @staticmethod
  def _match_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_slice_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _slice_alt_II(self,_t__0,_t__1):
    return self._slice_II(numpy.int32(__0),numpy.int32(__1))
  def _slice_II(self,_0,_1):
   return (mosek_fusion_ExprParameter._ctor_Lmosek_4fusion_4Parameter_2(self.__p._slice_II(_0,_1)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprParameter(")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprParameter
mosek_fusion_ExprParameter=__mk_mosek_fusion_ExprParameter()
del __mk_mosek_fusion_ExprParameter
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamScalarExpr():
 class ExprMulParamScalarExpr(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamScalarExpr__e','_ExprMulParamScalarExpr__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamScalarExpr.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamScalarExpr._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamScalarExpr._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalarExpr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamScalarExpr._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamScalarExpr._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalarExpr.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamScalarExpr'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamScalarExpr.__new__(ExprMulParamScalarExpr)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,p._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (e._getND_()!=0): # src/fusion/Parameter.monty:2631:12-26
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   if (_6!=0): # src/fusion/Parameter.monty:2646:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.sp_base)
   _13=(_1.nidxs_base)
   _14=(_1.cof_base)
   _15=(_1.cconst_base)
   _16=(_1.codeptr_base)
   _17=(_1.code_base)
   _18=self.__p._getND_()
   _19=self.__p._getNumNonzero_()
   _20=(_8 * self.__p._getNumNonzero_())
   _21=(self.__p._getNumNonzero_() < self.__p._getSize_())
   _22=(((_11 * _19) + (_20 * 4)) if ((_11 > 0) ) else (_20 * 3))
   _23=_2._alloci32_I(self.__p._getNumNonzero_())
   _24=(_2.i32)
   self.__p._getAllIndexes__3II(_24,_23)
   _0._alloc_1expr_IIIZI(_18,_19,_20,_21,_22)
   _25=(_0.i64)
   _26=(_0.f64)
   _27=(_0.i32)
   _28=(_0.ptr_base)
   _29=(_0.nidxs_base)
   _30=(_0.sp_base)
   _31=(_0.cof_base)
   _32=(_0.hassp)
   _33=(_0.shape_base)
   _34=(_0.codeptr_base)
   _35=(_0.code_base)
   _36=(_0.cconst_base)
   fragments._c_closure_319(_31,_26,_20) # src/fusion/Parameter.monty:2692:10-56
   fragments._c_closure_320(_8,_27,_19,_28) # src/fusion/Parameter.monty:2693:10-57
   for _37 in range(0,_18):
    _27[(_33 + _37)] = self.__p._getDim_I(_37)
   if _32: # src/fusion/Parameter.monty:2696:14-20
    self.__p._getSp__3JI(_25,_30)
   fragments._c_closure_321(_25,_29,_20) # src/fusion/Parameter.monty:2699:10-54
   fragments._c_closure_322(_13,_8,_25,_19,_29,_4) # src/fusion/Parameter.monty:2700:10-2707:11
   if (_22 > 0): # src/fusion/Parameter.monty:2709:14-28
    _27[_34] = 0
   fragments._c_closure_323(_15,_17,_14,_11,_8,_23,_16,_36,_35,_34,_26,_27,_19,_5,_3,_24) # src/fusion/Parameter.monty:2712:10-2764:11
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamScalarExpr(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamScalarExpr
mosek_fusion_ExprMulParamScalarExpr=__mk_mosek_fusion_ExprMulParamScalarExpr()
del __mk_mosek_fusion_ExprMulParamScalarExpr
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamScalar():
 class ExprMulParamScalar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamScalar__e','_ExprMulParamScalar__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamScalar.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamScalar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamScalar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamScalar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamScalar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamScalar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamScalar'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamScalar.__new__(ExprMulParamScalar)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=0): # src/fusion/Parameter.monty:2505:12-26
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   _19=_6
   _20=_7
   _21=_8
   _22=(self.__p._getNumNonzero_() < self.__p._getSize_())
   _23=((_8 * 3) if ((_11==0) ) else ((_8 * 4) + _11))
   _0._alloc_1expr_IIIZI(_19,_20,_21,_22,_23)
   _24=(_0.i64)
   _25=(_0.f64)
   _26=(_0.i32)
   _27=(_0.ptr_base)
   _28=(_0.nidxs_base)
   _29=(_0.sp_base)
   _30=(_0.cof_base)
   _31=(_0.hassp)
   _32=(_0.shape_base)
   _33=(_0.codeptr_base)
   _34=(_0.code_base)
   _35=(_0.cconst_base)
   _36=self.__p._getIndex_I(0)
   fragments._c_closure_324(_16,_18,_15,_11,_14,_8,_36,_10,_17,_35,_34,_33,_30,_25,_31,_26,_24,_23,_19,_20,_28,_21,_27,_32,_29,_12,_13,_5,_3,_4) # src/fusion/Parameter.monty:2570:8-2616:9
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamScalar(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamScalar
mosek_fusion_ExprMulParamScalar=__mk_mosek_fusion_ExprMulParamScalar()
del __mk_mosek_fusion_ExprMulParamScalar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamDiagLeft():
 class ExprMulParamDiagLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamDiagLeft__e','_ExprMulParamDiagLeft__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamDiagLeft.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamDiagLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamDiagLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamDiagLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamDiagLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamDiagLeft'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamDiagLeft.__new__(ExprMulParamDiagLeft)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([e._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)): # src/fusion/Parameter.monty:2136:12-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if ((p._getDim_I(1)!=e._getDim_I(0)) or (p._getDim_I(0)!=e._getDim_I(1))): # src/fusion/Parameter.monty:2138:12-2139:38
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   if ((_6!=2) or ((_3[_12]!=self.__p._getDim_I(1)) or (_3[(_12 + 1)]!=self.__p._getDim_I(0)))): # src/fusion/Parameter.monty:2166:12-81
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   _19=self.__p._getNumNonzero_()
   _20=_2._alloci64_I(_19)
   _21=(_2.i64)
   self.__p._getSp__3JI(_21,_20)
   _22=self.__p._getDim_I(0)
   _23=self.__p._getDim_I(1)
   _24=_3[_12]
   _25=_3[(_12 + 1)]
   _26=_2._alloci32_I(self.__p._getNumNonzero_())
   _27=(_2.i32)
   self.__p._getAllIndexes__3II(_27,_26)
   if _9: # src/fusion/Parameter.monty:2183:12-17
    _28=_2._alloci32_I(_7)
    _29=_2._alloci32_I((_25 + 1))
    _30=(_2.i32)
    fragments._c_closure_325(_25,_29,_30) # src/fusion/Parameter.monty:2196:10-52
    fragments._c_closure_326(_25,_29,_7,_13,_4,_30) # src/fusion/Parameter.monty:2197:10-65
    fragments._c_closure_327(_25,_29,_30) # src/fusion/Parameter.monty:2198:3-57
    fragments._c_closure_328(_25,_28,_29,_7,_13,_4,_30) # src/fusion/Parameter.monty:2199:3-2203:4
    _31=0
    _32=0
    _33=0
    _33,_31,_32 = fragments._c_closure_329(_17,_25,_28,_11,_7,_23,_19,_20,_10,_33,_31,_32,_13,_3,_4,_30,_21) # src/fusion/Parameter.monty:2210:3-2248:4
    _33 = numpy.int32(_33) # postprocess
    _31 = numpy.int32(_31) # postprocess
    _32 = numpy.int32(_32) # postprocess
    _34=1
    _35=(_31 < _22)
    _0._alloc_1expr_IIIZI(_34,_31,_32,_35,_33)
    _36=(_0.ptr_base)
    _37=(_0.nidxs_base)
    _38=((_0.sp_base) if (_35 ) else _0._alloci64_I(_31))
    _39=(_0.cof_base)
    _40=(_0.hassp)
    _41=(_0.shape_base)
    _42=(_0.codeptr_base)
    _43=(_0.code_base)
    _44=(_0.cconst_base)
    _45=(_0.i64)
    _46=(_0.f64)
    _47=(_0.i32)
    fragments._c_closure_330(_16,_18,_17,_15,_25,_28,_11,_7,_14,_22,_23,_26,_19,_20,_10,_44,_43,_42,_39,_46,_47,_45,_31,_37,_32,_36,_41,_38,_13,_5,_3,_4,_30,_21) # src/fusion/Parameter.monty:2277:10-2345:4
    if (not _40): # src/fusion/Parameter.monty:2354:7-17
     _0._popi64_I(_31)
    _2._clear_()
   else:
    _48=0
    _49=0
    _50=0
    _51=(_2.i32)
    _50,_48,_49 = fragments._c_closure_331(_17,_25,_11,_23,_19,_20,_10,_50,_48,_49,_3,_21) # src/fusion/Parameter.monty:2374:3-2400:11
    _50 = numpy.int32(_50) # postprocess
    _48 = numpy.int32(_48) # postprocess
    _49 = numpy.int32(_49) # postprocess
    _52=1
    _53=(_48 < _22)
    _0._alloc_1expr_IIIZI(_52,_48,_49,_53,_50)
    _54=(_0.ptr_base)
    _55=(_0.nidxs_base)
    _56=((_0.sp_base) if (_53 ) else _0._alloci64_I(_48))
    _57=(_0.cof_base)
    _58=(_0.hassp)
    _59=(_0.shape_base)
    _60=(_0.codeptr_base)
    _61=(_0.code_base)
    _62=(_0.cconst_base)
    _63=(_0.i64)
    _64=(_0.f64)
    _65=(_0.i32)
    fragments._c_closure_332(_16,_18,_17,_15,_25,_11,_14,_22,_23,_26,_19,_20,_10,_62,_61,_60,_57,_64,_65,_63,_50,_55,_54,_59,_56,_5,_3,_4,_51,_21) # src/fusion/Parameter.monty:2429:3-2483:11
    if (not _58): # src/fusion/Parameter.monty:2485:7-17
     _0._popi64_I(_48)
    _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamDiagLeft(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamDiagLeft
mosek_fusion_ExprMulParamDiagLeft=__mk_mosek_fusion_ExprMulParamDiagLeft()
del __mk_mosek_fusion_ExprMulParamDiagLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamDiagRight():
 class ExprMulParamDiagRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamDiagRight__e','_ExprMulParamDiagRight__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):# mosek.fusion.Expression,mosek.fusion.Parameter
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamDiagRight.ctor(mosek.fusion.Expression,mosek.fusion.Parameter)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamDiagRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamDiagRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamDiagRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamDiagRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamDiagRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamDiagRight'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p):
    o = ExprMulParamDiagRight.__new__(ExprMulParamDiagRight)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([e._getDim_I(0)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)): # src/fusion/Parameter.monty:1755:12-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if ((p._getDim_I(1)!=e._getDim_I(0)) or (p._getDim_I(0)!=e._getDim_I(1))): # src/fusion/Parameter.monty:1757:12-1758:38
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   if ((_6!=2) or ((_3[_12]!=self.__p._getDim_I(1)) or (_3[(_12 + 1)]!=self.__p._getDim_I(0)))): # src/fusion/Parameter.monty:1787:5-74
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   _19=self.__p._getNumNonzero_()
   _20=_2._alloci64_I(_19)
   _21=(_2.i64)
   _22=_2._alloci32_I(self.__p._getNumNonzero_())
   _23=(_2.i32)
   self.__p._getAllIndexes__3II(_23,_22)
   self.__p._getSp__3JI(_21,_20)
   _24=self.__p._getDim_I(0)
   _25=self.__p._getDim_I(1)
   _26=_3[_12]
   _27=_3[(_12 + 1)]
   _28=_2._alloci32_I(_19)
   _29=_2._alloci32_I((_25 + 1))
   _30=(_2.i32)
   fragments._c_closure_333(_25,_29,_30) # src/fusion/Parameter.monty:1808:8-50
   fragments._c_closure_334(_25,_19,_29,_20,_30,_21) # src/fusion/Parameter.monty:1809:8-63
   fragments._c_closure_335(_25,_29,_30) # src/fusion/Parameter.monty:1810:8-62
   fragments._c_closure_336(_25,_19,_28,_29,_20,_30,_21) # src/fusion/Parameter.monty:1811:8-1815:9
   if _9: # src/fusion/Parameter.monty:1817:5-10
    _31=0
    _32=0
    _33=0
    _34=0
    _35=0
    _35,_34,_31,_32,_33 = fragments._c_closure_337(_17,_27,_35,_34,_11,_7,_25,_19,_28,_20,_10,_31,_32,_33,_13,_3,_4,_30,_21) # src/fusion/Parameter.monty:1822:3-1860:11
    _35 = numpy.int32(_35) # postprocess
    _34 = numpy.int32(_34) # postprocess
    _31 = numpy.int32(_31) # postprocess
    _32 = numpy.int32(_32) # postprocess
    _33 = numpy.int32(_33) # postprocess
    _36=1
    _37=(_32 < _26)
    _0._alloc_1expr_IIIZI(_36,_32,_33,_37,_31)
    _38=(_0.ptr_base)
    _39=(_0.nidxs_base)
    _40=((_0.sp_base) if (_37 ) else _0._alloci64_I(_32))
    _41=(_0.cof_base)
    _42=(_0.hassp)
    _43=(_0.shape_base)
    _44=(_0.codeptr_base)
    _45=(_0.code_base)
    _46=(_0.cconst_base)
    _47=(_0.i64)
    _48=(_0.f64)
    _49=(_0.i32)
    if (_32 > 0): # src/fusion/Parameter.monty:1897:14-24
     _49[_38] = 0
     if (_31 > 0): # src/fusion/Parameter.monty:1899:16-30
      _49[_44] = 0
     _49[_43] = numpy.int32(_26)
     _50=0
     _51=0
     _52=0
     _53=0
     _54=0
     _50,_51,_54,_53,_52 = fragments._c_closure_338(_16,_18,_50,_17,_15,_27,_51,_54,_53,_11,_7,_14,_52,_25,_22,_19,_28,_20,_10,_46,_45,_44,_41,_48,_49,_47,_39,_38,_40,_13,_5,_3,_4,_30,_21) # src/fusion/Parameter.monty:1906:5-1967:6
     _50 = numpy.int32(_50) # postprocess
     _51 = numpy.int32(_51) # postprocess
     _54 = numpy.int32(_54) # postprocess
     _53 = numpy.int32(_53) # postprocess
     _52 = numpy.int32(_52) # postprocess
     if (_32 > _49[_43]): # src/fusion/Parameter.monty:1971:16-37
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid shape")
     if (_51!=_32): # src/fusion/Parameter.monty:1972:16-30
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num elements")
     if (_52!=_33): # src/fusion/Parameter.monty:1973:16-27
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num nonzeros")
    if (not _42): # src/fusion/Parameter.monty:1983:14-24
     _0._popi64_I(_32)
    _2._clear_()
   else:
    _55=0
    _56=0
    _57=0
    _58=0
    _58,_55,_56,_57 = fragments._c_closure_339(_17,_27,_58,_11,_25,_19,_28,_20,_10,_55,_56,_57,_3,_30,_21) # src/fusion/Parameter.monty:1998:10-2018:11
    _58 = numpy.int32(_58) # postprocess
    _55 = numpy.int32(_55) # postprocess
    _56 = numpy.int32(_56) # postprocess
    _57 = numpy.int32(_57) # postprocess
    _59=1
    _60=(_56 < _26)
    _0._alloc_1expr_IIIZI(_59,_56,_57,_60,_55)
    _61=(_0.ptr_base)
    _62=(_0.nidxs_base)
    _63=((_0.sp_base) if (_60 ) else _0._alloci64_I(_56))
    _64=(_0.cof_base)
    _65=(_0.hassp)
    _66=(_0.shape_base)
    _67=(_0.codeptr_base)
    _68=(_0.code_base)
    _69=(_0.cconst_base)
    _70=(_0.i64)
    _71=(_0.f64)
    _72=(_0.i32)
    _72[_61] = 0
    if (_55 > 0): # src/fusion/Parameter.monty:2056:16-30
     _72[_67] = 0
    _72[_66] = numpy.int32(_26)
    _73=0
    _74=0
    _75=0
    _76=0
    _73,_74,_76,_75 = fragments._c_closure_340(_16,_18,_73,_17,_15,_27,_74,_76,_11,_14,_75,_25,_22,_19,_28,_20,_10,_69,_68,_67,_64,_71,_72,_70,_62,_61,_63,_5,_3,_4,_30,_21) # src/fusion/Parameter.monty:2061:12-2103:13
    _73 = numpy.int32(_73) # postprocess
    _74 = numpy.int32(_74) # postprocess
    _76 = numpy.int32(_76) # postprocess
    _75 = numpy.int32(_75) # postprocess
    if (_56 > _72[_66]): # src/fusion/Parameter.monty:2109:16-37
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid shape")
    if (_74!=_56): # src/fusion/Parameter.monty:2110:16-30
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num elements")
    if (_75!=_57): # src/fusion/Parameter.monty:2111:16-27
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num nonzeros")
    if (not _65): # src/fusion/Parameter.monty:2119:14-24
     _0._popi64_I(_56)
    _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamDiagRight(")._a_S(self.__e._toString_())._a_S(",")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprMulParamDiagRight
mosek_fusion_ExprMulParamDiagRight=__mk_mosek_fusion_ExprMulParamDiagRight()
del __mk_mosek_fusion_ExprMulParamDiagRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprDotParam():
 class ExprDotParam(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDotParam__e','_ExprDotParam__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDotParam.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprDotParam._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDotParam._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDotParam.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprDotParam._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprDotParam._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDotParam.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDotParam'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprDotParam.__new__(ExprDotParam)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=e._getND_()): # src/fusion/Parameter.monty:1554:12-34
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   for _0 in range(0,p._getND_()):
    if (p._getDim_I(_0)!=e._getDim_I(_0)): # src/fusion/Parameter.monty:1557:14-40
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   _19=self.__p._getNumNonzero_()
   _20=_2._alloci64_I(_19)
   self.__p._getSp__3JI((_2.i64),_20)
   _21=_2._alloci32_I(self.__p._getNumNonzero_())
   _22=(_2.i32)
   self.__p._getAllIndexes__3II(_22,_21)
   _23=(_2.i64)
   _24=0
   _25=1
   _26=0
   _26,_24 = fragments._c_closure_341(_17,_9,_11,_7,_19,_20,_10,_26,_24,_13,_3,_4,_23) # src/fusion/Parameter.monty:1599:8-1622:9
   _26 = numpy.int32(_26) # postprocess
   _24 = numpy.int32(_24) # postprocess
   _27=1
   _27 = fragments._c_closure_342(_6,_27,_12,_3) # src/fusion/Parameter.monty:1625:27-68
   _27 = numpy.int64(_27) # postprocess
   _0._alloc_1expr_IIIZI(0,_25,_24,False,_26)
   _28=(_0.ptr_base)
   _29=(_0.nidxs_base)
   _30=(_0.cof_base)
   _31=(_0.hassp)
   _32=(_0.shape_base)
   _33=(_0.codeptr_base)
   _34=(_0.code_base)
   _35=(_0.cconst_base)
   _36=(_0.i64)
   _37=(_0.f64)
   _38=(_0.i32)
   _38[_28] = 0
   _38[(_28 + 1)] = _24
   if (_26 > 0): # src/fusion/Parameter.monty:1645:12-26
    _38[_33] = 0
   if _9: # src/fusion/Parameter.monty:1647:12-17
    _39=0
    _40=0
    _41=0
    _42=0
    _43=0
    _39,_42,_40,_43 = fragments._c_closure_343(_16,_18,_39,_17,_15,_42,_11,_7,_14,_40,_43,_21,_19,_20,_10,_35,_34,_33,_30,_37,_38,_36,_29,_13,_5,_3,_4,_22,_23) # src/fusion/Parameter.monty:1650:10-1688:11
    _39 = numpy.int32(_39) # postprocess
    _42 = numpy.int32(_42) # postprocess
    _40 = numpy.int32(_40) # postprocess
    _43 = numpy.int32(_43) # postprocess
    if (_41!=_25): # src/fusion/Parameter.monty:1689:14-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken elmi")
    if (_40!=_24): # src/fusion/Parameter.monty:1690:14-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken nzi")
    if (_39!=_26): # src/fusion/Parameter.monty:1691:14-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken codei")
   else:
    _44=0
    _45=0
    _44,_45 = fragments._c_closure_344(_16,_18,_44,_17,_15,_11,_14,_45,_21,_19,_20,_10,_35,_34,_33,_30,_37,_38,_36,_29,_5,_3,_4,_22,_23) # src/fusion/Parameter.monty:1695:10-1727:11
    _44 = numpy.int32(_44) # postprocess
    _45 = numpy.int32(_45) # postprocess
    if (_45!=_24): # src/fusion/Parameter.monty:1735:14-25
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nzi")
    if (_44!=_26): # src/fusion/Parameter.monty:1736:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid codei")
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDotParam(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprDotParam
mosek_fusion_ExprDotParam=__mk_mosek_fusion_ExprDotParam()
del __mk_mosek_fusion_ExprDotParam
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamElem():
 class ExprMulParamElem(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamElem__e','_ExprMulParamElem__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamElem.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamElem._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamElem._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamElem.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamElem._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamElem._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamElem.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamElem'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamElem.__new__(ExprMulParamElem)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e._getShape_())
   (self.__p) = p
   (self.__e) = e
   if (p._getND_()!=e._getND_()): # src/fusion/Parameter.monty:1323:12-34
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   for _0 in range(0,p._getND_()):
    if (p._getDim_I(_0)!=e._getDim_I(_0)): # src/fusion/Parameter.monty:1326:14-40
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   _19=self.__p._getNumNonzero_()
   _20=_2._alloci64_I(_19)
   self.__p._getSp__3JI((_2.i64),_20)
   _21=_2._alloci32_I(self.__p._getNumNonzero_())
   _22=(_2.i32)
   self.__p._getAllIndexes__3II(_22,_21)
   _23=(_2.i64)
   _24=_6
   _25=0
   _26=0
   _27=0
   _27,_26,_25 = fragments._c_closure_345(_17,_9,_11,_7,_19,_20,_10,_27,_26,_25,_13,_3,_4,_23) # src/fusion/Parameter.monty:1369:8-1396:9
   _27 = numpy.int32(_27) # postprocess
   _26 = numpy.int32(_26) # postprocess
   _25 = numpy.int32(_25) # postprocess
   _28=1
   _28 = fragments._c_closure_346(_6,_28,_12,_3) # src/fusion/Parameter.monty:1399:27-68
   _28 = numpy.int64(_28) # postprocess
   _29=(_26 < _28)
   _0._alloc_1expr_IIIZI(_24,_26,_25,_29,_27)
   _30=(_0.ptr_base)
   _31=(_0.nidxs_base)
   _32=((_0.sp_base) if (_29 ) else _0._alloci64_I(_26))
   _33=(_0.cof_base)
   _34=(_0.hassp)
   _35=(_0.shape_base)
   _36=(_0.codeptr_base)
   _37=(_0.code_base)
   _38=(_0.cconst_base)
   _39=(_0.i64)
   _40=(_0.f64)
   _41=(_0.i32)
   fragments._c_closure_347(_6,_41,_35,_12,_3) # src/fusion/Parameter.monty:1420:8-1421:41
   _41[_30] = 0
   if (_27 > 0): # src/fusion/Parameter.monty:1424:12-26
    _41[_36] = 0
   if _9: # src/fusion/Parameter.monty:1426:12-17
    _42=0
    _43=0
    _44=0
    _45=0
    _46=0
    _42,_45,_44,_43,_46 = fragments._c_closure_348(_16,_18,_42,_17,_15,_45,_44,_11,_7,_14,_43,_46,_21,_19,_20,_10,_38,_37,_36,_33,_40,_41,_39,_31,_30,_32,_13,_5,_3,_4,_22,_23) # src/fusion/Parameter.monty:1429:10-1474:11
    _42 = numpy.int32(_42) # postprocess
    _45 = numpy.int32(_45) # postprocess
    _44 = numpy.int32(_44) # postprocess
    _43 = numpy.int32(_43) # postprocess
    _46 = numpy.int32(_46) # postprocess
    if (_44!=_26): # src/fusion/Parameter.monty:1475:14-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken elmi")
    if (_43!=_25): # src/fusion/Parameter.monty:1476:14-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken nzi")
    if (_42!=_27): # src/fusion/Parameter.monty:1477:14-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: broken codei")
   else:
    _47=0
    _48=0
    _47,_48 = fragments._c_closure_349(_16,_18,_47,_17,_15,_11,_14,_48,_21,_19,_20,_10,_38,_37,_36,_33,_40,_41,_39,_31,_30,_32,_5,_3,_4,_22,_23) # src/fusion/Parameter.monty:1481:10-1516:11
    _47 = numpy.int32(_47) # postprocess
    _48 = numpy.int32(_48) # postprocess
    if (_27!=_47): # src/fusion/Parameter.monty:1517:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Invalid code list result")
   if (not _34): # src/fusion/Parameter.monty:1535:12-22
    _0._popi64_I(_26)
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamElem(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamElem
mosek_fusion_ExprMulParamElem=__mk_mosek_fusion_ExprMulParamElem()
del __mk_mosek_fusion_ExprMulParamElem
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamRight():
 class ExprMulParamRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamRight__e','_ExprMulParamRight__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):# mosek.fusion.Expression,mosek.fusion.Parameter
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamRight.ctor(mosek.fusion.Expression,mosek.fusion.Parameter)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamRight'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p):
    o = ExprMulParamRight.__new__(ExprMulParamRight)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e) and __arg_match_Lmosek_4fusion_4Parameter_2__(p))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    e,p, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(p))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(e,p)
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(self,e,p):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([e._getDim_I(0),p._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)): # src/fusion/Parameter.monty:941:12-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if (p._getDim_I(0)!=e._getDim_I(1)): # src/fusion/Parameter.monty:943:12-38
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ptr_base)
   _11=(_1.ncodeatom)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.cconst_base)
   _17=(_1.codeptr_base)
   _18=(_1.code_base)
   if ((_6!=2) or (self.__p._getDim_I(0)!=_3[(_12 + 1)])): # src/fusion/Parameter.monty:972:12-51
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _19=_3[_12]
   _20=_3[(_12 + 1)]
   _21=self.__p._getDim_I(0)
   _22=self.__p._getDim_I(1)
   _23=self.__p._getNumNonzero_()
   _24=_2._alloci32_I(self.__p._getNumNonzero_())
   _25=(_2.i32)
   self.__p._getAllIndexes__3II(_25,_24)
   _26=_2._alloci32_I(_23)
   _27=_2._alloci64_I(_23)
   self.__p._getSp__3JI((_2.i64),_27)
   _28=_2._alloci32_I((_22 + 1))
   _29=(_2.i32)
   _30=(_2.i64)
   fragments._c_closure_350(_22,_28,_29) # src/fusion/Parameter.monty:997:10-52
   fragments._c_closure_351(_22,_23,_28,_27,_29,_30) # src/fusion/Parameter.monty:998:10-69
   fragments._c_closure_352(_22,_28,_29) # src/fusion/Parameter.monty:999:10-64
   fragments._c_closure_353(_22,_23,_26,_28,_27,_29,_30) # src/fusion/Parameter.monty:1000:10-1003:11
   _31=(_2.i32)
   _32=(_2.i64)
   _33=0
   _34=0
   _35=0
   if ((not self.__p._isSparse_()) and (not _9)): # src/fusion/Parameter.monty:1011:12-42
    _35 = (_8 * _22)
    _34 = (_19 * _22)
    _33 = (((_11 + (_8 * 4)) * _22) if ((_11 > 0) ) else ((_8 * _22) * 3))
   elif (not _9): # src/fusion/Parameter.monty:1017:16-25
    _33,_34,_35 = fragments._c_closure_354(_17,_19,_20,_11,_22,_23,_26,_27,_10,_33,_34,_35,_3,_31,_32) # src/fusion/Parameter.monty:1017:27-1040:9
    _33 = numpy.int32(_33) # postprocess
    _34 = numpy.int32(_34) # postprocess
    _35 = numpy.int32(_35) # postprocess
   else:
    _33,_34,_35 = fragments._c_closure_355(_17,_20,_11,_7,_22,_23,_26,_27,_10,_33,_34,_35,_13,_3,_4,_31,_32) # src/fusion/Parameter.monty:1042:13-1122:9
    _33 = numpy.int32(_33) # postprocess
    _34 = numpy.int32(_34) # postprocess
    _35 = numpy.int32(_35) # postprocess
   _36=2
   _37=(_34 < (_22 * _19))
   _0._alloc_1expr_IIIZI(_36,_34,_35,_37,_33)
   _38=(_0.ptr_base)
   _39=(_0.nidxs_base)
   _40=((_0.sp_base) if (_37 ) else _0._alloci64_I(_34))
   _41=(_0.cof_base)
   _42=(_0.hassp)
   _43=(_0.shape_base)
   _44=(_0.codeptr_base)
   _45=(_0.code_base)
   _46=(_0.cconst_base)
   _47=(_0.i64)
   _48=(_0.f64)
   _49=(_0.i32)
   _49[_38] = 0
   if (_33 > 0): # src/fusion/Parameter.monty:1151:12-26
    _49[_44] = 0
   _49[_43] = _19
   _49[(_43 + 1)] = _22
   _50=0
   _51=0
   _52=0
   _50,_51,_52 = fragments._c_closure_356(_16,_18,_50,_17,_15,_19,_20,_51,_9,_11,_7,_14,_52,_22,_24,_23,_26,_27,_10,_46,_45,_44,_41,_48,_49,_47,_39,_38,_40,_13,_5,_3,_4,_31,_32) # src/fusion/Parameter.monty:1164:8-1292:9
   _50 = numpy.int32(_50) # postprocess
   _51 = numpy.int32(_51) # postprocess
   _52 = numpy.int32(_52) # postprocess
   if (not _42): # src/fusion/Parameter.monty:1300:12-22
    _0._popi64_I(_34)
   if (_51!=_34): # src/fusion/Parameter.monty:1304:12-29
    raise mosek_fusion_UnexpectedError._ctor_S("broken elmi")
   if (_52!=_35): # src/fusion/Parameter.monty:1305:12-27
    raise mosek_fusion_UnexpectedError._ctor_S("broken nzi")
   if (_50!=_33): # src/fusion/Parameter.monty:1306:12-33
    raise mosek_fusion_UnexpectedError._ctor_S("broken codei")
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamRight(")._a_S(self.__e._toString_())._a_S(",")._a_S(self.__p._toString_())._a_S(")")._toString_())
 return ExprMulParamRight
mosek_fusion_ExprMulParamRight=__mk_mosek_fusion_ExprMulParamRight()
del __mk_mosek_fusion_ExprMulParamRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulParamLeft():
 class ExprMulParamLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulParamLeft__e','_ExprMulParamLeft__p']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Parameter,mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulParamLeft.ctor(mosek.fusion.Parameter,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulParamLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulParamLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulParamLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulParamLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulParamLeft'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e):
    o = ExprMulParamLeft.__new__(ExprMulParamLeft)
    o._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    p,e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(p) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
    self._ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(p,e)
  def _ctor_init_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(self,p,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([p._getDim_I(0),e._getDim_I(1)], dtype=numpy.dtype(numpy.int32)))
   (self.__p) = p
   (self.__e) = e
   if ((p._getND_()!=2) or (e._getND_()!=2)): # src/fusion/Parameter.monty:446:12-44
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
   if (p._getDim_I(1)!=e._getDim_I(0)): # src/fusion/Parameter.monty:448:12-38
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ncodeatom)
   _11=(_1.ptr_base)
   _12=(_1.code_base)
   _13=(_1.cconst_base)
   _14=(_1.codeptr_base)
   _15=(_1.shape_base)
   _16=(_1.sp_base)
   _17=(_1.nidxs_base)
   _18=(_1.cof_base)
   _19=(_1.cconst_base)
   if ((_6!=2) or (_3[_15]!=self.__p._getDim_I(1))): # src/fusion/Parameter.monty:479:12-49
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _20=self.__p._getDim_I(0)
   _21=self.__p._getDim_I(1)
   _22=_3[_15]
   _23=_3[(_15 + 1)]
   _24=self.__p._getNumNonzero_()
   _25=_2._alloci32_I(self.__p._getNumNonzero_())
   _26=(_2.i32)
   self.__p._getAllIndexes__3II(_26,_25)
   if ((not _9) and (not self.__p._isSparse_())): # src/fusion/Parameter.monty:494:12-42
    _27=2
    _28=(_23 * self.__p._getDim_I(0))
    _29=(_8 * self.__p._getDim_I(0))
    _30=(((self.__p._getDim_I(0) * _10) + (4 * _29)) if ((_10 > 0) ) else (3 * _29))
    _31=False
    _0._alloc_1expr_IIIZI(_27,_28,_29,_31,_30)
    _32=(_0.i64)
    _33=(_0.f64)
    _34=(_0.i32)
    _35=(_0.ptr_base)
    _36=(_0.nidxs_base)
    _37=(_0.cof_base)
    _38=(_0.code_base)
    _39=(_0.codeptr_base)
    _40=(_0.cconst_base)
    _41=(_0.hassp)
    _42=(_0.shape_base)
    _34[_42] = _20
    _34[(_42 + 1)] = _23
    _34[_35] = 0
    _34[_39] = 0
    _43=0
    _44=0
    _45=0
    for _46 in range(0,self.__p._getDim_I(0)):
     for _47 in range(0,self.__e._getDim_I(1)):
      for _48 in range(0,self.__p._getDim_I(1)):
       _45,_43 = fragments._c_closure_357(_13,_12,_45,_14,_18,_23,_46,_47,_48,_10,_17,_43,_21,_25,_11,_40,_38,_39,_37,_33,_34,_32,_36,_5,_3,_4,_26) # src/fusion/Parameter.monty:530:45-559:17
       _45 = numpy.int32(_45) # postprocess
       _43 = numpy.int32(_43) # postprocess
      _34[((_35 + _44) + 1)] = _43
      _44 += 1
    if (_45!=_30): # src/fusion/Parameter.monty:569:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect a-code length")
    if (_43!=_29): # src/fusion/Parameter.monty:570:16-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_44!=_28): # src/fusion/Parameter.monty:571:16-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    for _49 in range(0,_28):
     if (_34[(_35 + _49)] > _34[((_35 + _49) + 1)]): # src/fusion/Parameter.monty:572:40-69
      raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr indexes")
   elif (not _9): # src/fusion/Parameter.monty:577:16-25
    _50=_7
    _51=_24
    _52=_2._alloci64_I(_51)
    _53=(_2.i64)
    self.__p._getSp__3JI(_53,_52)
    _54=0
    _55=0
    _56=0
    _56,_54,_55 = fragments._c_closure_358(_14,_23,_10,_21,_24,_11,_56,_54,_55,_3,_53,_52) # src/fusion/Parameter.monty:590:10-614:11
    _56 = numpy.int32(_56) # postprocess
    _54 = numpy.int32(_54) # postprocess
    _55 = numpy.int32(_55) # postprocess
    _57=(_54 < (_20 * _23))
    _58=2
    _0._alloc_1expr_IIIZI(_58,_54,_55,_57,_56)
    _59=(_0.ptr_base)
    _60=(_0.nidxs_base)
    _61=((_0.sp_base) if (_57 ) else _0._alloci64_I(_54))
    _62=(_0.cof_base)
    _63=(_0.hassp)
    _64=(_0.shape_base)
    _65=(_0.codeptr_base)
    _66=(_0.code_base)
    _67=(_0.cconst_base)
    _68=(_0.i64)
    _69=(_0.f64)
    _70=(_0.i32)
    _70[_64] = _20
    _70[(_64 + 1)] = _23
    _71=0
    _72=0
    _73=0
    if (_56 > 0): # src/fusion/Parameter.monty:644:16-30
     _70[_65] = 0
    _70[_59] = 0
    fragments._c_closure_359(_62,_69,_55) # src/fusion/Parameter.monty:647:12-53
    _74=0
    _73,_72,_74,_71 = fragments._c_closure_360(_13,_12,_73,_14,_18,_23,_72,_74,_10,_17,_71,_21,_25,_24,_11,_67,_66,_65,_69,_70,_68,_60,_59,_61,_5,_3,_4,_26,_53,_52) # src/fusion/Parameter.monty:650:12-691:13
    _73 = numpy.int32(_73) # postprocess
    _72 = numpy.int32(_72) # postprocess
    _74 = numpy.int32(_74) # postprocess
    _71 = numpy.int32(_71) # postprocess
    if (_73!=_56): # src/fusion/Parameter.monty:702:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect code list")
    if (_71!=_55): # src/fusion/Parameter.monty:703:16-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_72!=_54): # src/fusion/Parameter.monty:704:16-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    if (_70[(_59 + _54)]!=_55): # src/fusion/Parameter.monty:705:16-41
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr")
    if (not _63): # src/fusion/Parameter.monty:708:14-24
     _0._popi64_I(_54)
    _2._clear_()
   else:
    _75=_7
    _76=_2._alloci32_I(_75)
    _77=self.__p._getNumNonzero_()
    _78=_2._alloci64_I(_77)
    _79=_2._alloci32_I((_3[(_15 + 1)] + 1))
    _80=(_2.i32)
    _81=(_2.i64)
    self.__p._getSp__3JI(_81,_78)
    fragments._c_closure_361(_7,_15,_16,_3,_4,_80,_76,_79) # src/fusion/Parameter.monty:728:10-737:11
    _82=0
    _83=0
    _84=0
    _85=_3[(_15 + 1)]
    _86=_3[_15]
    _87=self.__p._getDim_I(1)
    _88=self.__p._getDim_I(0)
    _84,_82,_83 = fragments._c_closure_362(_14,_85,_10,_7,_87,_77,_11,_84,_82,_83,_16,_3,_4,_80,_81,_76,_78) # src/fusion/Parameter.monty:749:10-793:11
    _84 = numpy.int32(_84) # postprocess
    _82 = numpy.int32(_82) # postprocess
    _83 = numpy.int32(_83) # postprocess
    _89=2
    _90=(_82 < (_88 * _85))
    _0._alloc_1expr_IIIZI(_89,_82,_83,_90,_84)
    _91=(_0.ptr_base)
    _92=(_0.nidxs_base)
    _93=((_0.sp_base) if (_90 ) else _0._alloci64_I(_82))
    _94=(_0.cof_base)
    _95=(_0.shape_base)
    _96=(_0.codeptr_base)
    _97=(_0.code_base)
    _98=(_0.cconst_base)
    _99=(_0.i64)
    _100=(_0.f64)
    _101=(_0.i32)
    fragments._c_closure_363(_101,_82,_91) # src/fusion/Parameter.monty:820:10-57
    _101[_91] = 0
    if (_84 > 0): # src/fusion/Parameter.monty:824:16-30
     _101[_96] = 0
    _101[_95] = _88
    _101[(_95 + 1)] = _85
    _102=0
    _103=0
    _104=0
    fragments._c_closure_364(_94,_100,_83) # src/fusion/Parameter.monty:834:12-56
    _105=0
    _104,_103,_102,_105 = fragments._c_closure_365(_13,_12,_104,_14,_18,_85,_103,_10,_7,_17,_102,_87,_25,_77,_105,_11,_98,_97,_96,_100,_101,_99,_92,_91,_93,_16,_5,_3,_4,_80,_81,_76,_78) # src/fusion/Parameter.monty:837:12-906:13
    _104 = numpy.int32(_104) # postprocess
    _103 = numpy.int32(_103) # postprocess
    _102 = numpy.int32(_102) # postprocess
    _105 = numpy.int32(_105) # postprocess
    if (_104!=_84): # src/fusion/Parameter.monty:914:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect a-code length")
    if (_102!=_83): # src/fusion/Parameter.monty:915:16-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nnz length")
    if (_103!=_82): # src/fusion/Parameter.monty:916:16-31
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect nelem length")
    if (_101[(_91 + _103)]!=_83): # src/fusion/Parameter.monty:918:16-39
     raise mosek_fusion_UnexpectedError._ctor_S("Internal! Incorrect ptr")
    if (not _90): # src/fusion/Parameter.monty:920:14-24
     _0._popi64_I(_82)
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulParamLeft(")._a_S(self.__p._toString_())._a_S(",")._a_S(self.__e._toString_())._a_S(")")._toString_())
 return ExprMulParamLeft
mosek_fusion_ExprMulParamLeft=__mk_mosek_fusion_ExprMulParamLeft()
del __mk_mosek_fusion_ExprMulParamLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprOptimizeCode():
 class ExprOptimizeCode(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprOptimizeCode__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprOptimizeCode.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprOptimizeCode._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprOptimizeCode._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprOptimizeCode.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprOptimizeCode._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprOptimizeCode._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprOptimizeCode.toString()')
  def __repr__(self): return 'mosek.fusion.ExprOptimizeCode'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprOptimizeCode.__new__(ExprOptimizeCode)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def __compress_1code_alt_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9,_t__10,_t__11,_t__12):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.int32(_t__5)
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.int32(_t__7)
   _8=numpy.array(_t__8,dtype=numpy.dtype(numpy.float64))
   _9=numpy.int32(_t__9)
   _10=numpy.int32(_t__10)
   _11=numpy.int32(_t__11)
   _12=numpy.int32(_t__12)
   _1 = mosek_fusion_ExprOptimizeCode.__compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__8[:] = _8
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9,_10,_11,_12):
   _13=_4[(_5 + _1)]
   _14=_0._alloci32_I((_13 + 2))
   _15=0
   _16=_0._alloci32_I((_13 + 2))
   _17=_0._alloci32_I((_13 + 3))
   _18=_0._allocf64_I((_13 + 2))
   _19=_0._alloci32_I((_13 + 2))
   _20=0
   _21=(- 1)
   _22=(_0.i32)
   _23=(_0.f64)
   _24=_22
   _25=_23
   _26=_22
   _27=(_0.pi32)
   _28=(_0.pi64)
   _29=(_0.pf64)
   _26[_12] = 0
   _30=0
   _30,_21,_15,_20 = fragments._c_closure_366(_16,_17,_2,_3,_8,_9,_30,_21,_6,_7,_1,_4,_5,_14,_15,_24,_10,_25,_11,_26,_12,_18,_19,_20,_23,_22) # src/fusion/ExprCompress.monty:821:8-1204:9
   _30 = numpy.int32(_30) # postprocess
   _21 = numpy.int32(_21) # postprocess
   _15 = numpy.int32(_15) # postprocess
   _20 = numpy.int32(_20) # postprocess
   (_0.pi32) = _27
   (_0.pi64) = _28
   (_0.pf64) = _29
   if (_21 >= 0): # src/fusion/ExprCompress.monty:1211:12-25
    raise mosek_fusion_UnexpectedError._ctor_S("Internal error: Invalid parameterization code list")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._peek_1expr_()
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.hassp)
   _8=(_1.ncodeatom)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   if (_8==0): # src/fusion/ExprCompress.monty:552:12-26
    _0._alloc_1expr_IIIZI(_3,_5,_6,_7,0)
    _19=(_0.ptr_base)
    _20=(_0.sp_base)
    _21=(_0.nidxs_base)
    _22=(_0.cof_base)
    _23=(_0.shape_base)
    _24=(_0.i32)
    _25=(_0.i64)
    _26=(_0.f64)
    fragments._c_closure_367(_5,_9,_24,_19,_16) # src/fusion/ExprCompress.monty:564:10-64
    fragments._c_closure_368(_3,_24,_23,_4,_16) # src/fusion/ExprCompress.monty:565:10-66
    fragments._c_closure_369(_11,_6,_25,_21,_17) # src/fusion/ExprCompress.monty:566:10-66
    fragments._c_closure_370(_12,_6,_22,_26,_18) # src/fusion/ExprCompress.monty:567:10-64
    fragments._c_closure_371(_7,_5,_25,_20,_10,_17) # src/fusion/ExprCompress.monty:568:10-569:63
   else:
    _27=_2._alloci32_I((_8 + (_6 * 2)))
    _28=_2._alloci32_I((_6 + 1))
    _29=_2._allocf64_I((_8 + (_6 * 2)))
    mosek.fusion.ExprOptimizeCode.__compress_1code_Lmosek_4fusion_4WorkStack_2I_3II_3II_3DI_3DIIII(_2,_6,_16,_13,_16,_14,_18,_12,_18,_15,_27,_29,_28)
    _30=(_2.i32)
    _31=(_2.f64)
    _32=0
    _33=0
    _34=0
    _32,_34,_33 = fragments._c_closure_372(_12,_5,_9,_32,_34,_33,_18,_16,_27,_28,_30) # src/fusion/ExprCompress.monty:605:10-626:11
    _32 = numpy.int32(_32) # postprocess
    _34 = numpy.int32(_34) # postprocess
    _33 = numpy.int32(_33) # postprocess
    _35=False
    _35 = fragments._c_closure_373(_3,_35,_34,_4,_16) # src/fusion/ExprCompress.monty:630:10-635:11
    _0._alloc_1expr_IIIZI(_3,_34,_33,_35,_32)
    _36=(_0.ptr_base)
    _37=(_0.sp_base)
    _38=(_0.shape_base)
    _39=(_0.nidxs_base)
    _40=(_0.cof_base)
    _41=(_0.code_base)
    _42=(_0.codeptr_base)
    _43=(_0.cconst_base)
    _44=(_0.i32)
    _45=(_0.i64)
    _46=(_0.f64)
    fragments._c_closure_374(_3,_44,_38,_4,_16) # src/fusion/ExprCompress.monty:652:10-61
    if (_32==0): # src/fusion/ExprCompress.monty:654:14-29
     fragments._c_closure_375(_12,_7,_5,_11,_6,_9,_40,_46,_44,_45,_39,_36,_37,_10,_18,_17) # src/fusion/ExprCompress.monty:654:31-660:11
    else:
     _47=0
     _48=0
     _49=0
     _44[_36] = 0
     if (_32 > 0): # src/fusion/ExprCompress.monty:665:16-30
      _44[_42] = 0
     _47,_48,_49 = fragments._c_closure_376(_47,_12,_48,_5,_11,_49,_9,_43,_41,_42,_40,_46,_35,_44,_45,_39,_36,_37,_10,_18,_16,_17,_29,_27,_28,_31,_30) # src/fusion/ExprCompress.monty:669:12-735:13
     _47 = numpy.int32(_47) # postprocess
     _48 = numpy.int32(_48) # postprocess
     _49 = numpy.int32(_49) # postprocess
     if (_48!=_34): # src/fusion/ExprCompress.monty:741:16-31
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result nelem")
     if (_49!=_33): # src/fusion/ExprCompress.monty:742:16-29
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result nnz")
     if (_47!=_32): # src/fusion/ExprCompress.monty:743:16-35
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect result num code atoms")
     if (_32 > 0): # src/fusion/ExprCompress.monty:744:16-30
      if (_44[(_42 + _33)]!=_32): # src/fusion/ExprCompress.monty:745:18-51
       raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprOptimizeCode(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprOptimizeCode
mosek_fusion_ExprOptimizeCode=__mk_mosek_fusion_ExprOptimizeCode()
del __mk_mosek_fusion_ExprOptimizeCode
#BEFORE CLASS
def __mk_mosek_fusion_ExprCompress():
 class ExprCompress(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCompress__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCompress.ctor(mosek.fusion.Expression)')
  @staticmethod
  def arg_sort(*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32
      return mosek_fusion_ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args)
    elif mosek_fusion_ExprCompress._match_alt_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32
      return mosek_fusion_ExprCompress._arg_1sort_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args)
    else:
      raise ValueError('Invalid argument list arg_sort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.arg_sort(mosek.fusion.WorkStack,mosek.fusion.WorkStack,int32,int32,int32,int32,int32)')
  @staticmethod
  def merge_sort(*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_merge_1sort_IIIIII_3I_3J(*args): # int32,int32,int32,int32,int32,int32,[]int32,[]int64
      return mosek_fusion_ExprCompress._merge_1sort_IIIIII_3I_3J(*args)
    elif mosek_fusion_ExprCompress._match_alt_merge_1sort_IIIIII_3I_3J(*args): # int32,int32,int32,int32,int32,int32,[]int32,[]int64
      return mosek_fusion_ExprCompress._merge_1sort_alt_IIIIII_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list merge_sort('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.merge_sort(int32,int32,int32,int32,int32,int32,array(int32,ndim=1),array(int64,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCompress._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprCompress._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprCompress._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCompress.toString()')
  def __repr__(self): return 'mosek.fusion.ExprCompress'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprCompress.__new__(ExprCompress)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5) and __arg_match_I__(_6))
  @staticmethod
  def _match_alt_arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(*args):
    if len(args) != 7: return False
    _0,_1,_2,_3,_4,_5,_6, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5) and __arg_alt_match_I__(_6))
  @staticmethod
  def _arg_1sort_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
    return mosek_fusion_ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_0,_1,numpy.int32(__2),numpy.int32(__3),numpy.int32(__4),numpy.int32(__5),numpy.int32(__6))
  @staticmethod
  def _arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_0,_1,_2,_3,_4,_5,_6):
   _7=0
   _8=(_0.i32)
   _7 = fragments._c_closure_377(_7,_3,_5,_8) # src/fusion/ExprCompress.monty:382:8-383:89
   _7 = numpy.int32(_7) # postprocess
   _9=(_1._alloci32_I((_7 * 2)) if ((_7 > 2) ) else 99999)
   _10=(_1.i32)
   _8 = (_0.i32)
   _11=(_0.i64)
   fragments._c_closure_378(_3,_6,_2,_5,_8,_11,_9,_10) # src/fusion/ExprCompress.monty:390:8-501:9
  @staticmethod
  def _match_merge_1sort_IIIIII_3I_3J(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_I__(_3) and __arg_match_I__(_4) and __arg_match_I__(_5) and __arg_match__3I__(_6) and __arg_match__3J__(_7))
  @staticmethod
  def _match_alt_merge_1sort_IIIIII_3I_3J(*args):
    if len(args) != 8: return False
    _0,_1,_2,_3,_4,_5,_6,_7, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_I__(_3) and __arg_alt_match_I__(_4) and __arg_alt_match_I__(_5) and __arg_alt_match__3I__(_6) and __arg_alt_match__3J__(_7))
  @staticmethod
  def _merge_1sort_alt_IIIIII_3I_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.int32(_t__3)
   _4=numpy.int32(_t__4)
   _5=numpy.int32(_t__5)
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.int32))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_ExprCompress._merge_1sort_IIIIII_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7)
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _merge_1sort_IIIIII_3I_3J(_0,_1,_2,_3,_4,_5,_6,_7):
   fragments._c_closure_379(_2,_5,_3,_0,_1,_4,_6,_7) # src/fusion/ExprCompress.monty:315:36-369:7
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.hassp)
   _8=(_1.ncodeatom)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=True
   _20=(_2.i32)
   _21=(_2.i64)
   _22=(_2.f64)
   _19 = fragments._c_closure_380(_19,_5,_11,_9,_16,_17) # src/fusion/ExprCompress.monty:66:10-68:75
   _19 = fragments._c_closure_381(_15,_13,_14,_12,_19,_8,_6,_18,_16) # src/fusion/ExprCompress.monty:71:10-84:99
   if _19: # src/fusion/ExprCompress.monty:89:12-21
    _0._alloc_1expr_IIIZI(_3,_5,_6,_7,_8)
    _23=(_0.ptr_base)
    _24=(_0.nidxs_base)
    _25=(_0.sp_base)
    _26=(_0.cof_base)
    _27=(_0.shape_base)
    _28=(_0.code_base)
    _29=(_0.codeptr_base)
    _30=(_0.cconst_base)
    _31=(_0.i32)
    _32=(_0.i64)
    _33=(_0.f64)
    fragments._c_closure_382(_15,_13,_14,_12,_7,_8,_3,_5,_11,_6,_9,_30,_28,_29,_26,_33,_31,_32,_24,_23,_27,_25,_4,_10,_18,_16,_17) # src/fusion/ExprCompress.monty:114:10-127:11
    if (_8 > 0): # src/fusion/ExprCompress.monty:136:14-27
     if (_31[(_29 + _6)]!=_8): # src/fusion/ExprCompress.monty:137:16-47
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
   else:
    _34=_2._alloci32_I(_6)
    mosek.fusion.ExprCompress._arg_1sort_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2IIIII(_1,_2,_34,_5,_6,_9,_11)
    _35=(_2.i32)
    _36=0
    _37=_8
    _38=(_0.i32)
    _37,_36 = fragments._c_closure_383(_12,_8,_5,_11,_34,_9,_37,_36,_18,_16,_17,_35) # src/fusion/ExprCompress.monty:154:12-180:13
    _37 = numpy.int32(_37) # postprocess
    _36 = numpy.int32(_36) # postprocess
    _0._alloc_1expr_IIIZI(_3,_5,_36,_7,_37)
    _39=(_0.nidxs_base)
    _40=(_0.shape_base)
    _41=(_0.sp_base)
    _42=(_0.cof_base)
    _43=(_0.ptr_base)
    _44=(_0.code_base)
    _45=(_0.codeptr_base)
    _46=(_0.cconst_base)
    _47=(_0.i32)
    _48=(_0.i64)
    _49=(_0.f64)
    fragments._c_closure_384(_3,_47,_40,_4,_16) # src/fusion/ExprCompress.monty:209:12-210:45
    fragments._c_closure_385(_7,_5,_48,_41,_10,_17) # src/fusion/ExprCompress.monty:211:12-212:62
    _50=0
    _51=0
    _51,_50 = fragments._c_closure_386(_15,_13,_51,_14,_12,_8,_5,_11,_50,_34,_9,_46,_44,_45,_42,_49,_47,_48,_37,_39,_43,_18,_16,_17,_35) # src/fusion/ExprCompress.monty:216:12-281:13
    _51 = numpy.int32(_51) # postprocess
    _50 = numpy.int32(_50) # postprocess
    if (_37!=_51): # src/fusion/ExprCompress.monty:290:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ncodeatom")
    if (_50!=_36): # src/fusion/ExprCompress.monty:291:16-34
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
    if (_36!=_47[(_43 + _5)]): # src/fusion/ExprCompress.monty:292:16-46
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
    if (_37 > 0): # src/fusion/ExprCompress.monty:295:14-28
     if (_47[(_45 + _36)]!=_37): # src/fusion/ExprCompress.monty:296:16-49
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect codeptr")
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprCompress(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprCompress
mosek_fusion_ExprCompress=__mk_mosek_fusion_ExprCompress()
del __mk_mosek_fusion_ExprCompress
#BEFORE CLASS
def __mk_mosek_fusion_ExprConst():
 class ExprConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprConst__sparsity','_ExprConst__bfix']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3I_3J_3D(*args): # []int32,[]int64,[]double
      self._ctor_init__3I_3J_3D(*args)
    elif self.__match_alt_ctor__3I_3J_3D(*args):# []int32,[]int64,[]double
      self._ctor_alt_init__3I_3J_3D(*args)
    elif self.__match_ctor__3I_3JD(*args): # []int32,[]int64,double
      self._ctor_init__3I_3JD(*args)
    elif self.__match_alt_ctor__3I_3JD(*args):# []int32,[]int64,double
      self._ctor_alt_init__3I_3JD(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprConst.ctor(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.ExprConst.ctor(array(int32,ndim=1),array(int64,ndim=1),double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprConst'
  @staticmethod
  def _ctor__3I_3J_3D(shape,sparsity,bfix):
    o = ExprConst.__new__(ExprConst)
    o._ctor_init__3I_3J_3D(shape,sparsity,bfix)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match__3D__(bfix))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match__3D__(bfix))
  def _ctor_alt_init__3I_3J_3D(self,shape,sparsity,bfix):
    self._ctor_init__3I_3J_3D(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,shape,sparsity,bfix):
   mosek_fusion_BaseExpression._ctor_init__3I(self,shape)
   (self.__bfix) = mosek.fusion.Utils.Tools._arraycopy__3D(bfix)
   (self.__sparsity) = (mosek.fusion.Utils.Tools._arraycopy__3J(sparsity) if ((sparsity is not None) ) else None)
   mosek.fusion.ExprConst.__validate__3I_3D_3J(shape,bfix,sparsity)
  @staticmethod
  def _ctor__3I_3JD(shape,sparsity,bfix):
    o = ExprConst.__new__(ExprConst)
    o._ctor_init__3I_3JD(shape,sparsity,bfix)
    return o
  @staticmethod
  def __match_ctor__3I_3JD(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_match__3I__(shape) and __arg_match__3J__(sparsity) and __arg_match_D__(bfix))
  @staticmethod
  def __match_alt_ctor__3I_3JD(*args):
    if len(args) != 3: return False
    shape,sparsity,bfix, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match__3J__(sparsity) and __arg_alt_match_D__(bfix))
  def _ctor_alt_init__3I_3JD(self,shape,sparsity,bfix):
    self._ctor_init__3I_3JD(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(sparsity,dtype=numpy.dtype(numpy.int64)),numpy.float64(bfix))
  def _ctor_init__3I_3JD(self,shape,sparsity,bfix):
   mosek_fusion_BaseExpression._ctor_init__3I(self,shape)
   _0=(mosek.fusion.Set._size__3I(shape) if ((sparsity is None) ) else int((sparsity).shape[0]))
   (self.__bfix) = numpy.array([bfix for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64))
   (self.__sparsity) = (mosek.fusion.Utils.Tools._arraycopy__3J(sparsity) if ((sparsity is not None) ) else None)
   mosek.fusion.ExprConst.__validate__3I_3D_3J(shape,(self.__bfix),sparsity)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self._getShape_()
   _4=int((_3).shape[0])
   _5=0
   _5 = fragments._c_closure_387(self.__bfix,_5) # src/fusion/ExprConst.monty:48:23-101
   _5 = numpy.int32(_5) # postprocess
   _6=int((self.__bfix).shape[0])
   _7=((self.__sparsity is not None) and (int((self.__sparsity).shape[0]) < mosek.fusion.Set._size__3I(_3)))
   _0._alloc_1expr_IIIZI(_4,_6,_5,_7,0)
   _8=(_0.shape_base)
   _9=(_0.ptr_base)
   _10=(_0.sp_base)
   _11=(_0.nidxs_base)
   _12=(_0.cof_base)
   _13=(_0.i32)
   _14=(_0.i64)
   _15=(_0.f64)
   fragments._c_closure_388(_4,_13,_8,_3) # src/fusion/ExprConst.monty:64:8-54
   _16=0
   _13[_9] = 0
   fragments._c_closure_389(_7,_6,_14,_10,self.__sparsity) # src/fusion/ExprConst.monty:67:8-69:38
   _16 = fragments._c_closure_390(self.__bfix,_6,_16,_12,_15,_13,_14,_11,_9) # src/fusion/ExprConst.monty:70:8-77:9
   _16 = numpy.int32(_16) # postprocess
  @staticmethod
  def __validate_alt__3I_3D_3J(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_ExprConst.__validate__3I_3D_3J(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate__3I_3D_3J(_0,_1,_2):
   _3=mosek.fusion.Set._size__3I(_0)
   if (_2 is not None): # src/fusion/ExprConst.monty:12:12-28
    if (int((_2).shape[0])!=int((_1).shape[0])): # src/fusion/ExprConst.monty:13:14-40
     raise mosek_fusion_LengthError._ctor_S("Mismatching data lengths")
    _4=False
    _4 = fragments._c_closure_391(_4,_2,_3) # src/fusion/ExprConst.monty:16:10-18:25
    if _4: # src/fusion/ExprConst.monty:19:14-17
     raise mosek_fusion_IndexError._ctor_S("Invalid sparsity index")
   else:
    if (int((_1).shape[0])!=_3): # src/fusion/ExprConst.monty:23:14-29
     raise mosek_fusion_LengthError._ctor_S("Mismatching data length")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprConst()")
 return ExprConst
mosek_fusion_ExprConst=__mk_mosek_fusion_ExprConst()
del __mk_mosek_fusion_ExprConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprPick():
 class ExprPick(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprPick__idxs','_ExprPick__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args): # mosek.fusion.Expression,[,]int32
      self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):# mosek.fusion.Expression,[,]int32
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3J(*args): # mosek.fusion.Expression,[]int64
      self._ctor_init_Lmosek_4fusion_4Expression_2_3J(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3J(*args):# mosek.fusion.Expression,[]int64
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPick.ctor(mosek.fusion.Expression,array(int32,ndim=2))\n\tmosek.fusion.ExprPick.ctor(mosek.fusion.Expression,array(int64,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprPick._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprPick._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPick.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprPick._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprPick._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPick.toString()')
  def __repr__(self): return 'mosek.fusion.ExprPick'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3_5I(expr,idxs):
    o = ExprPick.__new__(ExprPick)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(expr,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3_5I__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3_5I__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I(self,expr,idxs):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I(expr,numpy.array(idxs,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3_5I(self,expr,idxs):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([int((idxs).shape[0])], dtype=numpy.dtype(numpy.int32)))
   _0=expr._getShape_()
   _1=int((_0).shape[0])
   (self.__expr) = expr
   (self.__idxs) = numpy.zeros((int((idxs).shape[0]),), dtype=numpy.dtype(numpy.int64))
   _2=(self.__idxs)
   if (int((idxs).shape[1])!=_1): # src/fusion/ExprSlice.monty:218:12-29
    raise mosek_fusion_DimensionError._ctor_S("Mismatching shape and index dimensions")
   _3=False
   _3 = fragments._c_closure_392(idxs,_1,_0,_3) # src/fusion/ExprSlice.monty:222:8-225:32
   if _3: # src/fusion/ExprSlice.monty:226:12-22
    raise mosek_fusion_IndexError._ctor_S("Pick index out of bounds")
   fragments._c_closure_393(idxs,_1,_0,_2) # src/fusion/ExprSlice.monty:229:8-237:9
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3J(expr,idxs):
    o = ExprPick.__new__(ExprPick)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3J(expr,idxs)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3J__(idxs))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3J(*args):
    if len(args) != 2: return False
    expr,idxs, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3J__(idxs))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3J(self,expr,idxs):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3J(expr,numpy.array(idxs,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3J(self,expr,idxs):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([int((idxs).shape[0])], dtype=numpy.dtype(numpy.int32)))
   (self.__expr) = expr
   _0=expr._getShape_()
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   _2 = fragments._c_closure_394(idxs,_1,_2) # src/fusion/ExprSlice.monty:198:8-200:30
   if _2: # src/fusion/ExprSlice.monty:201:12-22
    raise mosek_fusion_IndexError._ctor_S("Pick index out of bounds")
   (self.__idxs) = mosek.fusion.Utils.Tools._arraycopy__3J(idxs)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=(self.__idxs)
   if (not _8): # src/fusion/ExprSlice.monty:264:12-21
    _20=int((_19).shape[0])
    _21=1
    _22=0
    _23=0
    _23,_22 = fragments._c_closure_395(_14,_19,_7,_9,_23,_22,_16) # src/fusion/ExprSlice.monty:270:10-274:11
    _23 = numpy.int32(_23) # postprocess
    _22 = numpy.int32(_22) # postprocess
    _0._alloc_1expr_IIIZI(_21,_20,_22,False,_23)
    _24=(_0.cof_base)
    _25=(_0.nidxs_base)
    _26=(_0.ptr_base)
    _27=(_0.shape_base)
    _28=(_0.code_base)
    _29=(_0.codeptr_base)
    _30=(_0.cconst_base)
    pass
    _31=(_0.i32)
    _32=(_0.i64)
    _33=(_0.f64)
    _31[_27] = int((_19).shape[0])
    _34=0
    _35=0
    _31[_26] = 0
    _34,_35 = fragments._c_closure_396(_15,_13,_34,_14,_12,_19,_35,_7,_11,_9,_30,_28,_29,_24,_33,_31,_32,_25,_26,_18,_16,_17) # src/fusion/ExprSlice.monty:295:10-310:11
    _34 = numpy.int32(_34) # postprocess
    _35 = numpy.int32(_35) # postprocess
   else:
    _36=1
    _37=int((_19).shape[0])
    _38=0
    _39=0
    _40=(self.__idxs)
    _41=_2._alloci32_I(int((_40).shape[0]))
    _42=(_2.i32)
    _39,_38 = fragments._c_closure_397(_14,_40,_7,_5,_9,_39,_38,_10,_41,_16,_17,_42) # src/fusion/ExprSlice.monty:323:10-341:11
    _39 = numpy.int32(_39) # postprocess
    _38 = numpy.int32(_38) # postprocess
    _0._alloc_1expr_IIIZI(_36,_37,_38,False,_39)
    _43=(_0.ptr_base)
    _44=(_0.nidxs_base)
    _45=(_0.cof_base)
    _46=(_0.shape_base)
    _47=(_0.code_base)
    _48=(_0.codeptr_base)
    _49=(_0.cconst_base)
    _50=(_0.i32)
    _51=(_0.i64)
    _52=(_0.f64)
    _50[_46] = int((_40).shape[0])
    _50[_43] = 0
    _53=0
    _54=0
    _53,_54 = fragments._c_closure_398(_15,_13,_53,_14,_12,_40,_54,_7,_11,_9,_49,_47,_48,_45,_52,_50,_51,_44,_43,_41,_18,_16,_17,_42) # src/fusion/ExprSlice.monty:362:10-383:11
    _53 = numpy.int32(_53) # postprocess
    _54 = numpy.int32(_54) # postprocess
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprPick()")
 return ExprPick
mosek_fusion_ExprPick=__mk_mosek_fusion_ExprPick()
del __mk_mosek_fusion_ExprPick
#BEFORE CLASS
def __mk_mosek_fusion_ExprSlice():
 class ExprSlice(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSlice__last','_ExprSlice__first','_ExprSlice__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args): # mosek.fusion.Expression,[]int32,[]int32
      self._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):# mosek.fusion.Expression,[]int32,[]int32
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3I_3I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSlice.ctor(mosek.fusion.Expression,array(int32,ndim=1),array(int32,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSlice._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSlice._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSlice.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprSlice._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprSlice._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSlice.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSlice'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3I_3I(expr,first,last):
    o = ExprSlice.__new__(ExprSlice)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(expr,first,last)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
    if len(args) != 3: return False
    expr,first,last, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match__3I__(first) and __arg_match__3I__(last))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3I_3I(*args):
    if len(args) != 3: return False
    expr,first,last, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match__3I__(first) and __arg_alt_match__3I__(last))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3I_3I(self,expr,first,last):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(expr,numpy.array(first,dtype=numpy.dtype(numpy.int32)),numpy.array(last,dtype=numpy.dtype(numpy.int32)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3I_3I(self,expr,first,last):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprSlice.__makeShape__3I_3I_3I(expr._getShape_(),first,last))
   (self.__expr) = expr
   (self.__first) = first
   (self.__last) = last
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _19[(_3 - 1)] = 1
   fragments._c_closure_399(_3,_8,_19,_16) # src/fusion/ExprSlice.monty:60:45-111
   _20=0
   _21=0
   _22=0
   _20,_21,_22 = fragments._c_closure_400(_14,self.__first,_7,self.__last,_6,_3,_4,_9,_20,_21,_22,_8,_10,_19,_16,_17) # src/fusion/ExprSlice.monty:64:8-92:9
   _20 = numpy.int32(_20) # postprocess
   _21 = numpy.int32(_21) # postprocess
   _22 = numpy.int32(_22) # postprocess
   _23=numpy.array([(self.__last[_24] - self.__first[_24]) for _24 in range(0,_3)], dtype=numpy.dtype(numpy.int32))
   _25=(_21 < mosek.fusion.Set._size__3I(_23))
   _0._alloc_1expr_IIIZI(_3,_21,_22,_25,_20)
   _26=(_0.shape_base)
   _27=(_0.cof_base)
   _28=(_0.nidxs_base)
   _29=((_0.sp_base) if (_25 ) else _0._alloci64_I(_21))
   _30=(_0.ptr_base)
   _31=(_0.code_base)
   _32=(_0.codeptr_base)
   _33=(_0.cconst_base)
   _34=(_0.i32)
   _35=(_0.i64)
   _36=(_0.f64)
   fragments._c_closure_401(_3,_34,_23,_26) # src/fusion/ExprSlice.monty:113:8-60
   _34[_30] = 0
   if (_6 > 0): # src/fusion/ExprSlice.monty:116:12-25
    _34[_32] = 0
   _37=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _37[(_3 - 1)] = 1
   fragments._c_closure_402(_3,_23,_37) # src/fusion/ExprSlice.monty:118:47-106
   _38=0
   _39=0
   _40=0
   _38,_39,_40 = fragments._c_closure_403(_15,_13,_38,_14,_12,self.__first,_7,_39,_40,self.__last,_6,_3,_4,_11,_9,_33,_31,_32,_27,_36,_34,_35,_28,_30,_29,_37,_8,_10,_19,_18,_16,_17) # src/fusion/ExprSlice.monty:122:8-177:9
   _38 = numpy.int32(_38) # postprocess
   _39 = numpy.int32(_39) # postprocess
   _40 = numpy.int32(_40) # postprocess
   if (not _25): # src/fusion/ExprSlice.monty:178:12-22
    _0._popi64_I(_21)
  @staticmethod
  def __makeShape_alt__3I_3I_3I(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprSlice.__makeShape__3I_3I_3I(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __makeShape__3I_3I_3I(_0,_1,_2):
   if ((int((_0).shape[0])!=int((_1).shape[0])) or (int((_0).shape[0])!=int((_2).shape[0]))): # src/fusion/ExprSlice.monty:18:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid or mismatching index lengths")
   for _3 in range(0,int((_0).shape[0])):
    if ((_1[_3] < 0) or ((_2[_3] < _1[_3]) or (_2[_3] > _0[_3]))): # src/fusion/ExprSlice.monty:21:14-70
     raise mosek_fusion_IndexError._ctor_S("Slice is out of bounds")
   return (numpy.array([(_2[_4] - _1[_4]) for _4 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprSlice([")._a_I(self.__first[0])._a_S(":")._a_I(self.__last[0])
   for _1 in range(1,int((self.__first).shape[0])):
    _0._a_S(",")._a_I(self.__first[_1])._a_S(":")._a_I(self.__last[_1])
   _0._a_S("],")._a_S(self.__expr._toString_())._a_S(")")
   return (_0._toString_())
 return ExprSlice
mosek_fusion_ExprSlice=__mk_mosek_fusion_ExprSlice()
del __mk_mosek_fusion_ExprSlice
#BEFORE CLASS
def __mk_mosek_fusion_ExprPermuteDims():
 class ExprPermuteDims(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprPermuteDims__dperm','_ExprPermuteDims__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3ILmosek_4fusion_4Expression_2(*args): # []int32,mosek.fusion.Expression
      self._ctor_init__3ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):# []int32,mosek.fusion.Expression
      self._ctor_alt_init__3ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprPermuteDims.ctor(array(int32,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprPermuteDims._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprPermuteDims._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprPermuteDims.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprPermuteDims'
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2(perm,expr):
    o = ExprPermuteDims.__new__(ExprPermuteDims)
    o._ctor_init__3ILmosek_4fusion_4Expression_2(perm,expr)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    perm,expr, = args
    return (__arg_match__3I__(perm) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    perm,expr, = args
    return (__arg_alt_match__3I__(perm) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2(self,perm,expr):
    self._ctor_init__3ILmosek_4fusion_4Expression_2(numpy.array(perm,dtype=numpy.dtype(numpy.int32)),expr)
  def _ctor_init__3ILmosek_4fusion_4Expression_2(self,perm,expr):
   mosek_fusion_ExprPermuteDims._ctor_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,1)
   _0=expr._getShape_()
   if (int((perm).shape[0])!=int((_0).shape[0])): # src/fusion/ExprTranspose.monty:171:12-35
    raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
   _1=numpy.array([0 for _2 in range(0,int((perm).shape[0]))], dtype=numpy.dtype(numpy.int32))
   for _3 in range(0,int((_1).shape[0])):
    if ((perm[_3] < 0) or (perm[_3] > int((_0).shape[0]))): # src/fusion/ExprTranspose.monty:176:14-49
     raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
    _1[perm[_3]] += 1
   for _4 in range(0,int((_1).shape[0])):
    if ((_1[_4] < 1) or (_1[_4] > 1)): # src/fusion/ExprTranspose.monty:182:14-42
     raise mosek_fusion_LengthError._ctor_S("Invalid dimension permutation")
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2I(perm,expr,validated):
    o = ExprPermuteDims.__new__(ExprPermuteDims)
    o._ctor_init__3ILmosek_4fusion_4Expression_2I(perm,expr,validated)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 3: return False
    perm,expr,validated, = args
    return (__arg_match__3I__(perm) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 3: return False
    perm,expr,validated, = args
    return (__arg_alt_match__3I__(perm) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,validated):
    self._ctor_init__3ILmosek_4fusion_4Expression_2I(numpy.array(perm,dtype=numpy.dtype(numpy.int32)),expr,numpy.int32(validated))
  def _ctor_init__3ILmosek_4fusion_4Expression_2I(self,perm,expr,validated):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprPermuteDims.__computeshape__3I_3I(perm,expr._getShape_()))
   (self.__expr) = expr
   self.__dperm = mosek.fusion.Utils.Tools._arraycopy__3I(perm)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _9[(_3 - 1)] = 1
   for _10 in range(1,_3):
    _9[((_3 - _10) - 1)] = (_9[(_3 - _10)] * (_1.i32)[((_8 + _3) - _10)])
   _11=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _11[(_3 - 1)] = 1
   for _12 in range(1,_3):
    _11[((_3 - _12) - 1)] = (_11[(_3 - _12)] * (_1.i32)[(_8 + self.__dperm[(_3 - _12)])])
   _13=(_1.ptr_base)
   _14=(_1.sp_base)
   _15=(_1.nidxs_base)
   _16=(_1.cof_base)
   _17=(_1.code_base)
   _18=(_1.codeptr_base)
   _19=(_1.cconst_base)
   _20=(_1.i32)
   _21=(_1.i64)
   _22=(_1.f64)
   _0._alloc_1expr_IIIZI(_3,_4,_5,_7,_6)
   _23=(_0.ptr_base)
   _24=(_0.shape_base)
   _25=(_0.nidxs_base)
   _26=(_0.sp_base)
   _27=(_0.cof_base)
   _28=(_0.code_base)
   _29=(_0.codeptr_base)
   _30=(_0.cconst_base)
   _31=(_0.i32)
   _32=(_0.i64)
   _33=(_0.f64)
   fragments._c_closure_404(self.__dperm,_3,_31,_24,_8,_20) # src/fusion/ExprTranspose.monty:225:8-71
   if _7: # src/fusion/ExprTranspose.monty:227:12-17
    _34=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
    fragments._c_closure_405(self.__dperm,_11,_14,_3,_4,_8,_34,_9,_20,_21) # src/fusion/ExprTranspose.monty:229:10-235:11
    _35=numpy.array([_36 for _36 in range(0,_4)], dtype=numpy.dtype(numpy.int64))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_35,_34,None,0,_4)
    _31[_23] = 0
    if (_6 > 0): # src/fusion/ExprTranspose.monty:242:14-27
     _31[_29] = 0
    _37=0
    _38=0
    _39=0
    _37,_38,_39 = fragments._c_closure_406(_19,_17,_37,_18,_16,_15,_13,_38,_39,_6,_4,_35,_30,_28,_29,_27,_33,_31,_32,_25,_23,_26,_34,_22,_20,_21) # src/fusion/ExprTranspose.monty:246:10-265:11
    _37 = numpy.int32(_37) # postprocess
    _38 = numpy.int32(_38) # postprocess
    _39 = numpy.int32(_39) # postprocess
   else:
    fragments._c_closure_407(_19,_17,_18,self.__dperm,_11,_16,_15,_13,_6,_3,_4,_30,_28,_29,_27,_33,_31,_32,_25,_23,_8,_9,_22,_20,_21) # src/fusion/ExprTranspose.monty:267:13-293:9
  @staticmethod
  def __computeshape_alt__3I_3I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprPermuteDims.__computeshape__3I_3I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape__3I_3I(_0,_1):
   return (numpy.array([_1[_0[_2]] for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int32)))
 return ExprPermuteDims
mosek_fusion_ExprPermuteDims=__mk_mosek_fusion_ExprPermuteDims()
del __mk_mosek_fusion_ExprPermuteDims
#BEFORE CLASS
def __mk_mosek_fusion_ExprTranspose():
 class ExprTranspose(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprTranspose__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprTranspose.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprTranspose._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprTranspose._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprTranspose.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprTranspose._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprTranspose._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprTranspose.toString()')
  def __repr__(self): return 'mosek.fusion.ExprTranspose'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprTranspose.__new__(ExprTranspose)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprTranspose.__transposeShape__3I(expr._getShape_()))
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   if ((_1.nd)!=2): # src/fusion/ExprTranspose.monty:27:12-22
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   else:
    _3=(_1.shape_base)
    _4=(_1.nelem)
    _5=(_1.nnz)
    _6=(_1.hassp)
    _7=(_1.ncodeatom)
    _8=(_1.ptr_base)
    _9=(_1.sp_base)
    _10=(_1.nidxs_base)
    _11=(_1.cof_base)
    _12=(_1.code_base)
    _13=(_1.codeptr_base)
    _14=(_1.cconst_base)
    _15=(_1.i32)[_3]
    _16=(_1.i32)[(_3 + 1)]
    _17=(_1.i32)
    _18=(_1.i64)
    _19=(_1.f64)
    _0._alloc_1expr_IIIZI(2,_4,_5,_6,_7)
    _20=(_0.ptr_base)
    _21=(_0.nidxs_base)
    _22=(_0.sp_base)
    _23=(_0.cof_base)
    _24=(_0.shape_base)
    _25=(_0.code_base)
    _26=(_0.codeptr_base)
    _27=(_0.cconst_base)
    _28=(_0.i32)
    _29=(_0.i64)
    _30=(_0.f64)
    _28[_24] = _16
    _28[(_24 + 1)] = _15
    _28[_20] = 0
    if (_7 > 0): # src/fusion/ExprTranspose.monty:68:14-27
     _28[_26] = 0
    if _6: # src/fusion/ExprTranspose.monty:71:14-19
     _31=_2._alloci32_I(_4)
     _32=_2._alloci32_I((_16 + 1))
     _33=(_2.i32)
     fragments._c_closure_408(_14,_12,_13,_15,_16,_11,_10,_8,_9,_7,_4,_31,_32,_27,_25,_26,_23,_30,_28,_29,_21,_20,_22,_19,_17,_18,_33) # src/fusion/ExprTranspose.monty:76:12-113:13
    else:
     fragments._c_closure_409(_14,_12,_13,_15,_16,_11,_10,_8,_7,_27,_25,_26,_23,_30,_28,_29,_21,_20,_19,_17,_18) # src/fusion/ExprTranspose.monty:115:15-140:11
    _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprTranspose(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
  @staticmethod
  def __transposeShape_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprTranspose.__transposeShape__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __transposeShape__3I(_0):
   if (int((_0).shape[0])!=2): # src/fusion/ExprTranspose.monty:8:12-27
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   else:
    return (numpy.array([_0[1],_0[0]], dtype=numpy.dtype(numpy.int32)))
 return ExprTranspose
mosek_fusion_ExprTranspose=__mk_mosek_fusion_ExprTranspose()
del __mk_mosek_fusion_ExprTranspose
#BEFORE CLASS
def __mk_mosek_fusion_ExprRepeat():
 class ExprRepeat(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprRepeat__n','_ExprRepeat__dim','_ExprRepeat__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      self._ctor_init_Lmosek_4fusion_4Expression_2II(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2II(*args):# mosek.fusion.Expression,int32,int32
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprRepeat.ctor(mosek.fusion.Expression,int32,int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprRepeat._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprRepeat._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprRepeat.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprRepeat._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprRepeat._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprRepeat.toString()')
  def __repr__(self): return 'mosek.fusion.ExprRepeat'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2II(expr,dim,n):
    o = ExprRepeat.__new__(ExprRepeat)
    o._ctor_init_Lmosek_4fusion_4Expression_2II(expr,dim,n)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    expr,dim,n, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(dim) and __arg_match_I__(n))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    expr,dim,n, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(dim) and __arg_alt_match_I__(n))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2II(self,expr,dim,n):
    self._ctor_init_Lmosek_4fusion_4Expression_2II(expr,numpy.int32(dim),numpy.int32(n))
  def _ctor_init_Lmosek_4fusion_4Expression_2II(self,expr,dim,n):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprRepeat.__getshape_Lmosek_4fusion_4Expression_2II(expr,dim,n))
   (self.__expr) = expr
   (self.__dim) = dim
   (self.__n) = n
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=(_3 if ((self.__dim < _3) ) else (_3 + 1))
   _20=(_5 * self.__n)
   _21=(_6 * self.__n)
   _22=(_7 * self.__n)
   _0._alloc_1expr_IIIZI(_19,_20,_21,_8,_22)
   _23=(_0.i32)
   _24=(_0.i64)
   _25=(_0.f64)
   _26=(_0.shape_base)
   _27=(_0.ptr_base)
   _28=(_0.sp_base)
   _29=(_0.nidxs_base)
   _30=(_0.cof_base)
   _31=(_0.code_base)
   _32=(_0.codeptr_base)
   _33=(_0.cconst_base)
   _34=1
   _34 = fragments._c_closure_410(_34,self.__dim,_4,_16) # src/fusion/ExprStack.monty:510:21-62
   _34 = numpy.int32(_34) # postprocess
   _35=(_16[(_4 + self.__dim)] if ((self.__dim < _3) ) else 1)
   _36=(self.__n * _35)
   _37=1
   _37 = fragments._c_closure_411(_37,self.__dim,_3,_4,_16) # src/fusion/ExprStack.monty:513:21-65
   _37 = numpy.int32(_37) # postprocess
   fragments._c_closure_412(_15,_13,_14,_12,_34,_35,_37,self.__dim,_8,self.__n,_7,_3,_5,_11,_9,_33,_31,_32,_30,_36,_25,_23,_24,_22,_29,_27,_26,_28,_4,_10,_18,_16,_17) # src/fusion/ExprStack.monty:516:8-619:9
  @staticmethod
  def __getshape_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_ExprRepeat.__getshape_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def __getshape_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   _3=_0._getShape_()
   _4=int((_3).shape[0])
   if (_1 < _4): # src/fusion/ExprStack.monty:447:12-20
    _3[_1] *= _2
    return (_3)
   else:
    _5=(numpy.zeros(((_4 + 1),), dtype=numpy.dtype(numpy.int32)) if ((_1==_4) ) else _3)
    fragments._c_closure_413(_4,_5,_3) # src/fusion/ExprStack.monty:453:10-51
    _5[_1] = _2
    return (_5)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprRepeat(dim=")._a_I(self.__dim)._a_S(",")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprRepeat
mosek_fusion_ExprRepeat=__mk_mosek_fusion_ExprRepeat()
del __mk_mosek_fusion_ExprRepeat
#BEFORE CLASS
def __mk_mosek_fusion_ExprStack():
 class ExprStack(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprStack__dim','_ExprStack__exprs']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Expression_2I(*args): # []mosek.fusion.Expression,int32
      self._ctor_init__3Lmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Expression_2I(*args):# []mosek.fusion.Expression,int32
      self._ctor_alt_init__3Lmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprStack.ctor(array(mosek.fusion.Expression,ndim=1),int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprStack._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprStack._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprStack.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprStack._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprStack._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprStack.toString()')
  def __repr__(self): return 'mosek.fusion.ExprStack'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2I(exprs,dim):
    o = ExprStack.__new__(ExprStack)
    o._ctor_init__3Lmosek_4fusion_4Expression_2I(exprs,dim)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    exprs,dim, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(exprs) and __arg_match_I__(dim))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    exprs,dim, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(exprs) and __arg_alt_match_I__(dim))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2I(self,exprs,dim):
    self._ctor_init__3Lmosek_4fusion_4Expression_2I(numpy.array(exprs,dtype=numpy.dtype(object)),numpy.int32(dim))
  def _ctor_init__3Lmosek_4fusion_4Expression_2I(self,exprs,dim):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprStack.__getshape__3Lmosek_4fusion_4Expression_2I(exprs,dim))
   (self.__exprs) = numpy.array([exprs[_0] for _0 in range(0,int((exprs).shape[0]))], dtype=numpy.dtype(object))
   (self.__dim) = dim
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__exprs).shape[0])
   if (_3==1): # src/fusion/ExprStack.monty:59:12-18
    self.__exprs[0]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
   else:
    for _4 in range(0,_3):
     self.__exprs[((_3 - _4) - 1)]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
    _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _10=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _11=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _12=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _13=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _14=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _15=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _16=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _17=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    for _18 in range(0,_3):
     _1._pop_1expr_()
     _5[_18] = (_1.nd)
     _6[_18] = (_1.shape_base)
     _7[_18] = (_1.nelem)
     _8[_18] = (_1.nnz)
     _9[_18] = (_1.ncodeatom)
     _10[_18] = (1 if ((_1.hassp) ) else 0)
     _11[_18] = (_1.ptr_base)
     _13[_18] = (_1.sp_base)
     _12[_18] = (_1.nidxs_base)
     _14[_18] = (_1.cof_base)
     _15[_18] = (_1.code_base)
     _16[_18] = (_1.codeptr_base)
     _17[_18] = (_1.cconst_base)
    _19=(_1.i32)
    _20=(_1.i64)
    _21=(_1.f64)
    _22=_5[0]
    _23=_6[0]
    _24=(_10[0]==0)
    _25=False
    _24,_25 = fragments._c_closure_414(_24,self.__dim,_10,_25,_3,_22,_5,_23,_6,_19) # src/fusion/ExprStack.monty:109:10-118:11
    if _25: # src/fusion/ExprStack.monty:119:14-30
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression dimensions")
    _26=0
    _26 = fragments._c_closure_415(self.__dim,_3,_22,_26,_6,_19) # src/fusion/ExprStack.monty:123:10-124:24
    _26 = numpy.int32(_26) # postprocess
    _27=(_22 if ((self.__dim < _22) ) else (_22 + 1))
    if (_27!=self._getND_()): # src/fusion/ExprStack.monty:128:14-28
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Mismatching dimensions")
    _28=0
    _29=0
    _30=0
    _31=False
    _31,_28,_29,_30 = fragments._c_closure_416(_3,_9,_7,_8,_31,_28,_29,_30) # src/fusion/ExprStack.monty:134:10-140:11
    _28 = numpy.int32(_28) # postprocess
    _29 = numpy.int32(_29) # postprocess
    _30 = numpy.int32(_30) # postprocess
    _32=1
    _32 = fragments._c_closure_417(_32,self.__dim,_23,_19) # src/fusion/ExprStack.monty:142:26-70
    _32 = numpy.int32(_32) # postprocess
    _33=(numpy.array([_19[(_6[_34] + self.__dim)] for _34 in range(0,_3)], dtype=numpy.dtype(numpy.int32)) if ((self.__dim < _22) ) else numpy.array([1 for _35 in range(0,_3)], dtype=numpy.dtype(numpy.int32)))
    _36=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
    _36[0] = 0
    fragments._c_closure_418(_33,_3,_36) # src/fusion/ExprStack.monty:144:51-105
    _37=0
    _37 = fragments._c_closure_419(_37,_33,_3) # src/fusion/ExprStack.monty:145:26-58
    _37 = numpy.int32(_37) # postprocess
    _38=1
    _38 = fragments._c_closure_420(_38,self.__dim,_22,_23,_19) # src/fusion/ExprStack.monty:146:26-70
    _38 = numpy.int32(_38) # postprocess
    if _24: # src/fusion/ExprStack.monty:148:14-19
     _0._alloc_1expr_IIIZI(_27,_29,_30,False,_28)
     _39=(_0.ptr_base)
     _40=(_0.shape_base)
     _41=(_0.nidxs_base)
     _42=(_0.cof_base)
     _43=(_0.code_base)
     _44=(_0.codeptr_base)
     _45=(_0.cconst_base)
     _46=(_0.i32)
     _47=(_0.i64)
     _48=(_0.f64)
     _49=(_2._alloci32_I((_29 + 1)) if ((_28 > 0) ) else (- 9999))
     _50=(_2.i32)
     fragments._c_closure_421(_22,_46,_40,_23,_19) # src/fusion/ExprStack.monty:166:12-63
     _46[(_40 + self.__dim)] = _26
     fragments._c_closure_422(_17,_15,_16,_14,_32,_33,_38,_3,_9,_12,_31,_11,_45,_43,_44,_42,_48,_46,_47,_41,_39,_21,_19,_20) # src/fusion/ExprStack.monty:169:12-207:13
    else:
     _51=1
     _51 = fragments._c_closure_423(self.__dim,_51,_23,_19) # src/fusion/ExprStack.monty:211:12-61
     _51 = numpy.int32(_51) # postprocess
     _51 *= _26
     _51 = fragments._c_closure_424(self.__dim,_22,_51,_23,_19) # src/fusion/ExprStack.monty:213:12-64
     _51 = numpy.int32(_51) # postprocess
     _52=(_29 < _51)
     _0._alloc_1expr_IIIZI(_27,_29,_30,_52,_28)
     _53=(_0.ptr_base)
     _54=(_0.nidxs_base)
     _55=((_0.sp_base) if (_52 ) else _0._alloci64_I(_29))
     _56=(_0.cof_base)
     _57=(_0.code_base)
     _58=(_0.codeptr_base)
     _59=(_0.cconst_base)
     _60=(_0.shape_base)
     for _61 in range(0,_22):
      (_0.i32)[(_60 + _61)] = _19[(_23 + _61)]
     (_0.i32)[(_60 + self.__dim)] = _26
     _62=(_0.i32)
     _63=(_0.i64)
     _64=(_0.f64)
     if (self.__dim==0): # src/fusion/ExprStack.monty:241:16-24
      fragments._c_closure_425(_17,_15,_16,_14,_10,_3,_9,_22,_7,_12,_11,_59,_57,_58,_56,_64,_62,_63,_28,_54,_53,_55,_6,_13,_21,_19,_20) # src/fusion/ExprStack.monty:241:26-299:13
     else:
      _65=0
      _65 = fragments._c_closure_426(_65,_62,_27,_60) # src/fusion/ExprStack.monty:302:30-104
      _65 = numpy.int32(_65) # postprocess
      _66=_2._alloci64_I(_29)
      _67=_2._alloci32_I(_29)
      _68=_2._alloci32_I(_29)
      _69=_2._alloci32_I(_29)
      _70=_2._alloci32_I(_29)
      _71=_2._alloci32_I((_65 + 1))
      _72=(_2.i32)
      _73=(_2.i64)
      fragments._c_closure_427(_33,_38,_10,_3,_7,_36,_26,_13,_67,_68,_66,_20,_72,_73) # src/fusion/ExprStack.monty:314:14-347:15
      _69,_70 = fragments._c_closure_428(_69,_62,_27,_29,_60,_70,_66,_72,_73,_71) # src/fusion/ExprStack.monty:352:14-379:15
      _69 = numpy.int32(_69) # postprocess
      _70 = numpy.int32(_70) # postprocess
      fragments._c_closure_429(_17,_15,_16,_14,_69,_9,_12,_31,_11,_59,_57,_58,_56,_64,_62,_63,_28,_29,_54,_53,_55,_67,_68,_66,_21,_19,_20,_72,_73) # src/fusion/ExprStack.monty:384:14-423:15
     if (not _52): # src/fusion/ExprStack.monty:425:16-26
      _0._popi64_I(_29)
  @staticmethod
  def __getshape_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_ExprStack.__getshape__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __getshape__3Lmosek_4fusion_4Expression_2I(_0,_1):
   if (int((_0).shape[0])==0): # src/fusion/ExprStack.monty:17:12-24
    raise mosek_fusion_LengthError._ctor_S("Cannot stack empty list")
   elif (int((_0).shape[0])==1): # src/fusion/ExprStack.monty:19:16-28
    return (_0[0]._getShape_())
   else:
    _2=_monty.initJaggedArray([_0[_3]._getShape_() for _3 in range(0,int((_0).shape[0]))], 1)
    _4=_2[0]
    _5=int((_4).shape[0])
    for _6 in range(1,int((_2).shape[0])):
     if (_5!=int((_2[_6]).shape[0])): # src/fusion/ExprStack.monty:26:16-36
      raise mosek_fusion_DimensionError._ctor_S("Mismatching expression dimensions")
     for _7 in range(0,_1):
      if (_4[_7]!=_2[_6][_7]): # src/fusion/ExprStack.monty:29:18-42
       raise mosek_fusion_DimensionError._ctor_S("mismatching expression dimensions")
     for _8 in range((_1 + 1),_5):
      if (_4[_8]!=_2[_6][_8]): # src/fusion/ExprStack.monty:32:18-42
       raise mosek_fusion_DimensionError._ctor_S("mismatching expression dimensions")
    if (_1==_5): # src/fusion/ExprStack.monty:35:14-23
     _9=numpy.zeros(((_5 + 1),), dtype=numpy.dtype(numpy.int32))
     fragments._c_closure_430(_5,_9,_4) # src/fusion/ExprStack.monty:36:43-86
     _9[_5] = int((_2).shape[0])
     return (_9)
    else:
     _10=_4
     fragments._c_closure_431(_1,_10,_2) # src/fusion/ExprStack.monty:42:12-43:46
     return (_10)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprStack(dim=")._a_I(self.__dim)._a_S(",[")._a_S(self.__exprs[0]._toString_())
   for _1 in range(1,int((self.__exprs).shape[0])):
    _0._a_S(",")._a_S(self.__exprs[_1]._toString_())
   _0._a_S("])")
   return (_0._toString_())
 return ExprStack
mosek_fusion_ExprStack=__mk_mosek_fusion_ExprStack()
del __mk_mosek_fusion_ExprStack
#BEFORE CLASS
def __mk_mosek_fusion_ExprInner():
 class ExprInner(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprInner__vcof','_ExprInner__vsub','_ExprInner__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3D(*args):# mosek.fusion.Expression,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args): # mosek.fusion.Expression,[]int64,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):# mosek.fusion.Expression,[]int64,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3J_3D(*args)
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args): # mosek.fusion.Expression,[,]int32,[]double
      self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):# mosek.fusion.Expression,[,]int32,[]double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.ExprInner.ctor(mosek.fusion.Expression,array(int32,ndim=2),array(double,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprInner._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprInner._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprInner.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprInner._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprInner._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprInner.toString()')
  def __repr__(self): return 'mosek.fusion.ExprInner'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3J_3D(expr3,vsub3,vcof3):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(expr3,vsub3,vcof3)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
    if len(args) != 3: return False
    expr3,vsub3,vcof3, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr3) and __arg_match__3J__(vsub3) and __arg_match__3D__(vcof3))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3J_3D(*args):
    if len(args) != 3: return False
    expr3,vsub3,vcof3, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr3) and __arg_alt_match__3J__(vsub3) and __arg_alt_match__3D__(vcof3))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr3,vsub3,vcof3):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(expr3,numpy.array(vsub3,dtype=numpy.dtype(numpy.int64)),numpy.array(vcof3,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr3,vsub3,vcof3):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   (self.__expr) = expr3
   (self.__vsub) = vsub3
   (self.__vcof) = vcof3
   if (int((vsub3).shape[0])!=int((vcof3).shape[0])): # src/fusion/ExprMul.monty:2359:12-36
    raise mosek_fusion_LengthError._ctor_S("Mismatching lengths of vcof and vsub")
   _0=expr3._getShape_()
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   _3=False
   _3,_2 = fragments._c_closure_432(_3,_2,_1,vsub3) # src/fusion/ExprMul.monty:2367:8-2375:9
   if _2: # src/fusion/ExprMul.monty:2376:12-22
    raise mosek_fusion_IndexError._ctor_S("Unordered coefficcient subscripts")
   if _3: # src/fusion/ExprMul.monty:2378:12-22
    raise mosek_fusion_IndexError._ctor_S("Coefficient subscript out of bounds")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3D(expr2,vcof2):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3D(expr2,vcof2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    expr2,vcof2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr2) and __arg_match__3D__(vcof2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    expr2,vcof2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr2) and __arg_alt_match__3D__(vcof2))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3D(self,expr2,vcof2):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3D(expr2,numpy.array(vcof2,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3D(self,expr2,vcof2):
   mosek_fusion_ExprInner._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr2,mosek.fusion.ExprInner.__range_I(int((vcof2).shape[0])),vcof2)
   _0=expr2._getShape_()
   if ((int((_0).shape[0])!=1) or (_0[0]!=int((vcof2).shape[0]))): # src/fusion/ExprMul.monty:2347:12-55
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions of operands")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(expr1,vsub1,vcof1):
    o = ExprInner.__new__(ExprInner)
    o._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(expr1,vsub1,vcof1)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
    if len(args) != 3: return False
    expr1,vsub1,vcof1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr1) and __arg_match__3_5I__(vsub1) and __arg_match__3D__(vcof1))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2_3_5I_3D(*args):
    if len(args) != 3: return False
    expr1,vsub1,vcof1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr1) and __arg_alt_match__3_5I__(vsub1) and __arg_alt_match__3D__(vcof1))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2_3_5I_3D(self,expr1,vsub1,vcof1):
    self._ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(expr1,numpy.array(vsub1,dtype=numpy.dtype(numpy.int32)),numpy.array(vcof1,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_Lmosek_4fusion_4Expression_2_3_5I_3D(self,expr1,vsub1,vcof1):
   mosek_fusion_ExprInner._ctor_init_Lmosek_4fusion_4Expression_2_3J_3D(self,expr1,mosek.fusion.ExprInner.__convert__3I_3_5I(expr1._getShape_(),vsub1),vcof1)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.nidxs_base)
   _11=(_1.sp_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=0
   _19 = fragments._c_closure_433(_7,_4,_9,_19,_11,self.__vsub,_16,_17) # src/fusion/ExprMul.monty:2407:8-2422:9
   _19 = numpy.int32(_19) # postprocess
   _20=((_6 + (2 * _5)) if ((_6 > 0) ) else 0)
   _0._alloc_1expr_IIIZI(0,1,_19,False,_20)
   _21=(_0.ptr_base)
   _22=(_0.nidxs_base)
   _23=(_0.cof_base)
   _24=(_0.code_base)
   _25=(_0.codeptr_base)
   _26=(_0.cconst_base)
   _27=(_0.i32)
   _28=(_0.i64)
   _29=(_0.f64)
   _27[_21] = 0
   _27[(_21 + 1)] = _19
   if (_20 > 0): # src/fusion/ExprMul.monty:2442:12-26
    _27[_25] = 0
   _30=0
   _31=0
   _30,_31 = fragments._c_closure_434(_15,_13,_30,_14,_12,_7,_31,_4,_10,_9,_26,_24,_25,_23,_29,_27,_28,_20,_22,_11,self.__vcof,self.__vsub,_18,_16,_17) # src/fusion/ExprMul.monty:2447:8-2510:9
   _30 = numpy.int32(_30) # postprocess
   _31 = numpy.int32(_31) # postprocess
  @staticmethod
  def __range_alt_I(_t__0):
    return mosek_fusion_ExprInner.__range_I(numpy.int32(__0))
  @staticmethod
  def __range_I(_0):
   return (numpy.array([_1 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.int64)))
  @staticmethod
  def __convert_alt__3I_3_5I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprInner.__convert__3I_3_5I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __convert__3I_3_5I(_0,_1):
   _2=int((_0).shape[0])
   _3=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int64))
   _3[(_2 - 1)] = 1
   fragments._c_closure_435(_2,_3,_0) # src/fusion/ExprMul.monty:2329:43-97
   _4=numpy.zeros((int((_1).shape[0]),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_436(_2,_4,_3,_1) # src/fusion/ExprMul.monty:2331:8-2333:39
   return (_4)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprInner()")
 return ExprInner
mosek_fusion_ExprInner=__mk_mosek_fusion_ExprInner()
del __mk_mosek_fusion_ExprInner
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulDiagRight():
 class ExprMulDiagRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulDiagRight__expr','_ExprMulDiagRight__mval','_ExprMulDiagRight__msubj','_ExprMulDiagRight__msubi','_ExprMulDiagRight__mdim1','_ExprMulDiagRight__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulDiagRight.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulDiagRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulDiagRight'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulDiagRight.__new__(ExprMulDiagRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim1], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulDiagRight.__new__(ExprMulDiagRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   mosek_fusion_ExprMulDiagRight._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulDiagRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.codeptr_base)
   _14=(_1.code_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=_16[_8]
   _20=_16[(_8 + 1)]
   _21=int((self.__mval).shape[0])
   _22=_2._alloci32_I(_21)
   _23=_2._alloci32_I((self.__mdim1 + 1))
   _24=(_2.i32)
   fragments._c_closure_437(self.__mdim1,_21,self.__msubj,_24,_23,_22) # src/fusion/ExprMul.monty:2100:8-2106:9
   _25=0
   _26=0
   _27=0
   _25,_27,_26 = fragments._c_closure_438(_13,_20,_7,self.__mdim1,_21,self.__msubi,self.__msubj,_6,_5,_9,_25,_27,_26,_10,_16,_17,_24,_22) # src/fusion/ExprMul.monty:2115:8-2159:9
   _25 = numpy.int32(_25) # postprocess
   _27 = numpy.int32(_27) # postprocess
   _26 = numpy.int32(_26) # postprocess
   _28=(_27 < _19)
   _0._alloc_1expr_IIIZI(1,_27,_26,_28,_25)
   _29=(_0.ptr_base)
   _30=(_0.nidxs_base)
   _31=((_0.sp_base) if (_28 ) else _0._alloci64_I(_27))
   _32=(_0.cof_base)
   _33=(_0.shape_base)
   _34=(_0.code_base)
   _35=(_0.codeptr_base)
   _36=(_0.cconst_base)
   _37=(_0.i64)
   _38=(_0.f64)
   _39=(_0.i32)
   _40=(_2.i32)
   _41=0
   _42=0
   _43=0
   _39[_29] = 0
   if (_25 > 0): # src/fusion/ExprMul.monty:2189:14-28
    _39[_35] = 0
   _39[_33] = self.__mdim1
   _41,_43,_42 = fragments._c_closure_439(_15,_14,_41,_13,_12,_20,_43,_7,self.__mdim1,_21,self.__msubi,self.__msubj,self.__mval,_6,_5,_11,_42,_9,_36,_34,_35,_32,_38,_39,_37,_30,_29,_31,_10,_18,_16,_17,_40,_22) # src/fusion/ExprMul.monty:2194:10-2305:11
   _41 = numpy.int32(_41) # postprocess
   _43 = numpy.int32(_43) # postprocess
   _42 = numpy.int32(_42) # postprocess
   if (not _28): # src/fusion/ExprMul.monty:2306:14-24
    _0._popi64_I(_27)
   if (not (_26==_42)): # src/fusion/ExprMul.monty:2310:14-31
    raise mosek_fusion_UnexpectedError._ctor_S("Incorrect number of non-zeros")
   if (not (_27==_43)): # src/fusion/ExprMul.monty:2311:14-32
    raise mosek_fusion_UnexpectedError._ctor_S("Incorrect number of elements")
   _2._clear_()
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulDiagRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   _6=_5._getShape_()
   if (int((_6).shape[0]) > 2): # src/fusion/ExprMul.monty:1986:12-27
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or ((_1 < 0) or ((_7 < 0) or (_8 < 0)))): # src/fusion/ExprMul.monty:1992:12-60
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_0!=_8) or (_1!=_7)): # src/fusion/ExprMul.monty:1994:12-44
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:1996:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   _11=False
   _10,_11 = fragments._c_closure_440(_10,_11,_0,_1,_9,_2,_3) # src/fusion/ExprMul.monty:2003:8-2013:9
   if _10: # src/fusion/ExprMul.monty:2014:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _11: # src/fusion/ExprMul.monty:2016:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulDiagRight(")._a_S(self.__expr._toString_())._a_S(",m)")._toString_())
 return ExprMulDiagRight
mosek_fusion_ExprMulDiagRight=__mk_mosek_fusion_ExprMulDiagRight()
del __mk_mosek_fusion_ExprMulDiagRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulDiagLeft():
 class ExprMulDiagLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulDiagLeft__expr','_ExprMulDiagLeft__mval','_ExprMulDiagLeft__msubj','_ExprMulDiagLeft__msubi','_ExprMulDiagLeft__mdim1','_ExprMulDiagLeft__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulDiagLeft.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulDiagLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulDiagLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulDiagLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulDiagLeft'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulDiagLeft.__new__(ExprMulDiagLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim0], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulDiagLeft.__new__(ExprMulDiagLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   mosek_fusion_ExprMulDiagLeft._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulDiagLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ncodeatom)
   _11=(_1.ptr_base)
   _12=(_1.code_base)
   _13=(_1.cconst_base)
   _14=(_1.codeptr_base)
   _15=(_1.shape_base)
   _16=(_1.sp_base)
   _17=(_1.nidxs_base)
   _18=(_1.cof_base)
   _19=(_1.cconst_base)
   if (_6!=2): # src/fusion/ExprMul.monty:1710:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _20=_3[_15]
   _21=_3[(_15 + 1)]
   _22=int((self.__msubi).shape[0])
   if (not _9): # src/fusion/ExprMul.monty:1718:12-21
    _23=0
    _24=0
    _25=0
    _26=0
    _26,_25,_24,_23 = fragments._c_closure_441(_14,_21,_26,self.__msubi,self.__msubj,_10,_11,_25,_24,_23,_3) # src/fusion/ExprMul.monty:1725:10-1735:11
    _26 = numpy.int32(_26) # postprocess
    _25 = numpy.int32(_25) # postprocess
    _24 = numpy.int32(_24) # postprocess
    _23 = numpy.int32(_23) # postprocess
    _27=(_24 < self.__mdim0)
    _0._alloc_1expr_IIIZI(1,_24,_23,_27,_25)
    _28=(_0.ptr_base)
    _29=(_0.nidxs_base)
    _30=((_0.sp_base) if (_27 ) else _0._alloci64_I(_24))
    _31=(_0.cof_base)
    _32=(_0.shape_base)
    _33=(_0.code_base)
    _34=(_0.codeptr_base)
    _35=(_0.cconst_base)
    _36=(_0.i64)
    _37=(_0.f64)
    _38=(_0.i32)
    fragments._c_closure_442(_13,_12,_14,_18,_21,self.__mdim0,self.__msubi,self.__msubj,self.__mval,_10,_17,_11,_35,_33,_34,_31,_37,_38,_36,_25,_29,_28,_32,_30,_5,_3,_4) # src/fusion/ExprMul.monty:1752:10-1794:11
    if (not _27): # src/fusion/ExprMul.monty:1795:14-24
     _0._popi64_I(_24)
   else:
    _39=_2._alloci32_I((_21 + 1))
    _40=_2._alloci32_I(_7)
    _41=_2._alloci32_I((self.__mdim0 + 1))
    _42=(_2.i32)
    _43=0
    _44=0
    _45=0
    _43,_45,_44 = fragments._c_closure_443(_14,_21,self.__msubi,self.__msubj,_10,_7,_11,_43,_45,_44,_16,_3,_4,_39,_40,_42) # src/fusion/ExprMul.monty:1807:10-1853:11
    _43 = numpy.int32(_43) # postprocess
    _45 = numpy.int32(_45) # postprocess
    _44 = numpy.int32(_44) # postprocess
    _46=(_45 < self.__mdim0)
    _0._alloc_1expr_IIIZI(1,_45,_44,_46,_43)
    _47=(_0.ptr_base)
    _48=(_0.nidxs_base)
    _49=((_0.sp_base) if (_46 ) else _0._alloci64_I(_45))
    _50=(_0.cof_base)
    _51=(_0.shape_base)
    _52=(_0.code_base)
    _53=(_0.codeptr_base)
    _54=(_0.cconst_base)
    _55=(_0.i64)
    _56=(_0.f64)
    _57=(_0.i32)
    _58=0
    _59=0
    _60=0
    _61=0
    _62=0
    _57[_47] = 0
    if (_10 > 0): # src/fusion/ExprMul.monty:1877:16-29
     _57[_53] = 0
    _57[_51] = self.__mdim0
    _60,_58,_61,_62,_59 = fragments._c_closure_444(_13,_12,_60,_14,_18,_21,_58,_61,_62,self.__msubi,self.__msubj,self.__mval,_10,_7,_17,_59,_11,_54,_52,_53,_50,_56,_57,_55,_48,_47,_49,_16,_5,_3,_4,_40,_42) # src/fusion/ExprMul.monty:1881:12-1933:13
    _60 = numpy.int32(_60) # postprocess
    _58 = numpy.int32(_58) # postprocess
    _61 = numpy.int32(_61) # postprocess
    _62 = numpy.int32(_62) # postprocess
    _59 = numpy.int32(_59) # postprocess
    if (_59!=_44): # src/fusion/ExprMul.monty:1937:16-27
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of non-zeros")
    if (_58!=_45): # src/fusion/ExprMul.monty:1938:16-30
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of elements")
    if (not _46): # src/fusion/ExprMul.monty:1941:14-24
     _0._popi64_I(_45)
   _2._clear_()
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulDiagLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   _6=_5._getShape_()
   if (int((_6).shape[0])!=2): # src/fusion/ExprMul.monty:1601:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:1607:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_1!=_7) or (_0!=_8)): # src/fusion/ExprMul.monty:1609:12-44
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:1611:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   _11=False
   _10,_11 = fragments._c_closure_445(_10,_11,_0,_1,_9,_2,_3) # src/fusion/ExprMul.monty:1618:8-1628:9
   if _10: # src/fusion/ExprMul.monty:1629:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _11: # src/fusion/ExprMul.monty:1631:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulDiagLeft(m,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulDiagLeft
mosek_fusion_ExprMulDiagLeft=__mk_mosek_fusion_ExprMulDiagLeft()
del __mk_mosek_fusion_ExprMulDiagLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulElement():
 class ExprMulElement(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulElement__expr','_ExprMulElement__msp','_ExprMulElement__mcof']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3D_3JLmosek_4fusion_4Expression_2(*args): # []double,[]int64,mosek.fusion.Expression
      self._ctor_init__3D_3JLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):# []double,[]int64,mosek.fusion.Expression
      self._ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulElement.ctor(array(double,ndim=1),array(int64,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulElement._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulElement._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulElement.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulElement._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulElement._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulElement.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulElement'
  @staticmethod
  def _ctor__3D_3JLmosek_4fusion_4Expression_2(mcof,msp,expr):
    o = ExprMulElement.__new__(ExprMulElement)
    o._ctor_init__3D_3JLmosek_4fusion_4Expression_2(mcof,msp,expr)
    return o
  @staticmethod
  def __match_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    mcof,msp,expr, = args
    return (__arg_match__3D__(mcof) and __arg_match__3J__(msp) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    mcof,msp,expr, = args
    return (__arg_alt_match__3D__(mcof) and __arg_alt_match__3J__(msp) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2(self,mcof,msp,expr):
    self._ctor_init__3D_3JLmosek_4fusion_4Expression_2(numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),numpy.array(msp,dtype=numpy.dtype(numpy.int64)),expr)
  def _ctor_init__3D_3JLmosek_4fusion_4Expression_2(self,mcof,msp,expr):
   mosek_fusion_ExprMulElement._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(self,mcof,msp,expr,1)
   _0=expr._getShape_()
   if (int((mcof).shape[0])!=int((msp).shape[0])): # src/fusion/ExprMul.monty:1380:12-33
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix specification")
   _1=mosek.fusion.Set._size__3I(_0)
   _2=False
   _3=False
   _2,_3 = fragments._c_closure_446(_2,_3,msp,_1) # src/fusion/ExprMul.monty:1386:8-1394:9
   if _2: # src/fusion/ExprMul.monty:1395:12-20
    raise mosek_fusion_IndexError._ctor_S("Invalid matrix data")
   if _3: # src/fusion/ExprMul.monty:1398:12-22
    raise mosek_fusion_IndexError._ctor_S("Matrix data not sorted")
  @staticmethod
  def _ctor__3D_3JLmosek_4fusion_4Expression_2I(cof,msp,expr,validated):
    o = ExprMulElement.__new__(ExprMulElement)
    o._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(cof,msp,expr,validated)
    return o
  @staticmethod
  def __match_ctor__3D_3JLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    cof,msp,expr,validated, = args
    return (__arg_match__3D__(cof) and __arg_match__3J__(msp) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor__3D_3JLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    cof,msp,expr,validated, = args
    return (__arg_alt_match__3D__(cof) and __arg_alt_match__3J__(msp) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init__3D_3JLmosek_4fusion_4Expression_2I(self,cof,msp,expr,validated):
    self._ctor_init__3D_3JLmosek_4fusion_4Expression_2I(numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(msp,dtype=numpy.dtype(numpy.int64)),expr,numpy.int32(validated))
  def _ctor_init__3D_3JLmosek_4fusion_4Expression_2I(self,cof,msp,expr,validated):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
   (self.__mcof) = cof
   (self.__msp) = msp
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.nidxs_base)
   _11=(_1.sp_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=0
   _20=0
   _21=0
   _19,_21,_20 = fragments._c_closure_447(_14,_7,self.__msp,_6,_4,_9,_19,_21,_20,_11,_16,_17) # src/fusion/ExprMul.monty:1427:8-1453:9
   _19 = numpy.int32(_19) # postprocess
   _21 = numpy.int32(_21) # postprocess
   _20 = numpy.int32(_20) # postprocess
   _22=1
   _22 = fragments._c_closure_448(_3,_22,_8,_16) # src/fusion/ExprMul.monty:1456:24-67
   _22 = numpy.int64(_22) # postprocess
   _23=(_21 < _22)
   _24=_3
   _0._alloc_1expr_IIIZI(_24,_21,_20,_23,_19)
   _25=(_0.ptr_base)
   _26=(_0.shape_base)
   _27=(_0.nidxs_base)
   _28=((_0.sp_base) if (_23 ) else _0._alloci64_I(_21))
   _29=(_0.cof_base)
   _30=(_0.code_base)
   _31=(_0.codeptr_base)
   _32=(_0.cconst_base)
   _33=(_0.i32)
   _34=(_0.i64)
   _35=(_0.f64)
   fragments._c_closure_449(_15,_13,_14,_12,_7,self.__mcof,self.__msp,_6,_4,_10,_9,_32,_30,_31,_29,_35,_33,_34,_19,_24,_27,_25,_26,_28,_8,_11,_18,_16,_17) # src/fusion/ExprMul.monty:1475:8-1556:9
   if (not _23): # src/fusion/ExprMul.monty:1557:12-22
    _0._popi64_I(_21)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulElement(M,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulElement
mosek_fusion_ExprMulElement=__mk_mosek_fusion_ExprMulElement()
del __mk_mosek_fusion_ExprMulElement
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulScalarConst():
 class ExprMulScalarConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulScalarConst__expr','_ExprMulScalarConst__c']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      self._ctor_init_DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_DLmosek_4fusion_4Expression_2(*args):# double,mosek.fusion.Expression
      self._ctor_alt_init_DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulScalarConst.ctor(double,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulScalarConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulScalarConst'
  @staticmethod
  def _ctor_DLmosek_4fusion_4Expression_2(c,expr):
    o = ExprMulScalarConst.__new__(ExprMulScalarConst)
    o._ctor_init_DLmosek_4fusion_4Expression_2(c,expr)
    return o
  @staticmethod
  def __match_ctor_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    c,expr, = args
    return (__arg_match_D__(c) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    c,expr, = args
    return (__arg_alt_match_D__(c) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_DLmosek_4fusion_4Expression_2(self,c,expr):
    self._ctor_init_DLmosek_4fusion_4Expression_2(numpy.float64(c),expr)
  def _ctor_init_DLmosek_4fusion_4Expression_2(self,c,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__c) = c
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.hassp)
   _10=(_1.ncodeatom)
   _11=(_1.ptr_base)
   _12=(_1.code_base)
   _13=(_1.cconst_base)
   _14=(_1.codeptr_base)
   _15=(_1.shape_base)
   _16=(_1.sp_base)
   _17=(_1.nidxs_base)
   _18=(_1.cof_base)
   _19=(_1.cconst_base)
   _20=(0 if ((_10==0) ) else (_10 + (2 * _8)))
   _0._alloc_1expr_IIIZI(_6,_7,_8,_9,_20)
   _21=(_0.i64)
   _22=(_0.f64)
   _23=(_0.i32)
   _24=(_0.ptr_base)
   _25=(_0.nidxs_base)
   _26=(_0.cof_base)
   _27=(_0.code_base)
   _28=(_0.codeptr_base)
   _29=(_0.cconst_base)
   _30=(_0.hassp)
   _31=(_0.shape_base)
   _32=(_0.sp_base)
   fragments._c_closure_450(self.__c,_13,_12,_14,_18,_9,_10,_6,_7,_17,_8,_11,_29,_27,_28,_26,_22,_23,_21,_25,_24,_31,_32,_15,_16,_5,_3,_4) # src/fusion/ExprMul.monty:1316:8-1347:9
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulScalarConst()")
 return ExprMulScalarConst
mosek_fusion_ExprMulScalarConst=__mk_mosek_fusion_ExprMulScalarConst()
del __mk_mosek_fusion_ExprMulScalarConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprScalarMul():
 class ExprScalarMul(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprScalarMul__expr','_ExprScalarMul__mval','_ExprScalarMul__msubj','_ExprScalarMul__msubi','_ExprScalarMul__mdim1','_ExprScalarMul__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprScalarMul.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprScalarMul._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScalarMul.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprScalarMul._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprScalarMul._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScalarMul.toString()')
  def __repr__(self): return 'mosek.fusion.ExprScalarMul'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprScalarMul.__new__(ExprScalarMul)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdim0,mdim1], dtype=numpy.dtype(numpy.int32)))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprScalarMul.__new__(ExprScalarMul)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   mosek_fusion_ExprScalarMul._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprScalarMul.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nelem)
   _5=(_1.nnz)
   _6=(_1.hassp)
   _7=(_1.ncodeatom)
   _8=(_1.ptr_base)
   _9=(_1.sp_base)
   _10=(_1.nidxs_base)
   _11=(_1.cof_base)
   _12=(_1.code_base)
   _13=(_1.codeptr_base)
   _14=(_1.cconst_base)
   _15=(_1.i32)
   _16=(_1.i64)
   _17=(_1.f64)
   _18=int((self.__mval).shape[0])
   if (_3!=0): # src/fusion/ExprMul.monty:1178:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid expression shape")
   if (_4==0): # src/fusion/ExprMul.monty:1181:12-22
    _0._alloc_1expr_IIIZ(2,0,0,True)
    (_0.i32)[(_0.shape_base)] = self.__mdim0
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdim1
   else:
    _19=(_18 * (_7 + ((2 * _5) if ((_7 > 0) ) else 0)))
    _0._alloc_1expr_IIIZI(2,_18,(_18 * _5),True,_19)
    _20=(_0.ptr_base)
    _21=(_0.nidxs_base)
    _22=(_0.sp_base)
    _23=(_0.cof_base)
    _24=(_0.shape_base)
    _25=(_0.code_base)
    _26=(_0.codeptr_base)
    _27=(_0.cconst_base)
    _28=(_0.i32)
    _29=(_0.i64)
    _30=(_0.f64)
    _28[_24] = self.__mdim0
    _28[(_24 + 1)] = self.__mdim1
    _31=0
    _32=0
    _28[_20] = 0
    _31,_32 = fragments._c_closure_451(_14,_12,_31,_13,_11,self.__mdim1,_18,self.__msubi,self.__msubj,self.__mval,_7,_10,_5,_32,_27,_25,_26,_23,_30,_28,_29,_21,_20,_22,_17,_15,_16) # src/fusion/ExprMul.monty:1207:10-1244:13
    _31 = numpy.int32(_31) # postprocess
    _32 = numpy.int32(_32) # postprocess
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprScalarMul.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   _6=_5._getND_()
   if (_6!=0): # src/fusion/ExprMul.monty:1078:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:1080:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:1082:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _7=int((_2).shape[0])
   _8=False
   _9=False
   _8,_9 = fragments._c_closure_452(_8,_9,_0,_1,_7,_2,_3) # src/fusion/ExprMul.monty:1089:8-1099:9
   if _8: # src/fusion/ExprMul.monty:1100:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _9: # src/fusion/ExprMul.monty:1102:12-22
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprScalarMul(M,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprScalarMul
mosek_fusion_ExprScalarMul=__mk_mosek_fusion_ExprScalarMul()
del __mk_mosek_fusion_ExprScalarMul
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulRight():
 class ExprMulRight(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulRight__expr','_ExprMulRight__mval','_ExprMulRight__msubj','_ExprMulRight__msubi','_ExprMulRight__mdim1','_ExprMulRight__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulRight.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulRight._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulRight._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulRight.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulRight._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulRight._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulRight.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulRight'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulRight.__new__(ExprMulRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulRight.__computeshape_I_3I(mdim1,expr._getShape_()))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulRight.__new__(ExprMulRight)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   mosek_fusion_ExprMulRight._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.i32)
   _4=(_1.i64)
   _5=(_1.f64)
   _6=(_1.nd)
   if (_6!=2): # src/fusion/ExprMul.monty:614:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _7=(_1.nelem)
   _8=(_1.nnz)
   _9=(_1.ncodeatom)
   _10=(_1.hassp)
   _11=(_1.ptr_base)
   _12=(_1.shape_base)
   _13=(_1.sp_base)
   _14=(_1.nidxs_base)
   _15=(_1.cof_base)
   _16=(_1.codeptr_base)
   _17=(_1.code_base)
   _18=(_1.cconst_base)
   _19=_3[_12]
   _20=_3[(_12 + 1)]
   _21=int((self.__mval).shape[0])
   _22=(_21 < (numpy.int64(self.__mdim0) * numpy.int64(self.__mdim1)))
   if _22: # src/fusion/ExprMul.monty:636:12-15
    _23=_2._alloci32_I((self.__mdim1 + 1))
    _24=_2._alloci32_I(_21)
    _25=_2._alloci32_I((_19 + 1))
    _26=(_2.i32)
    fragments._c_closure_453(_19,_25,_23,self.__mdim1,_21,_24,self.__msubj,_26) # src/fusion/ExprMul.monty:644:10-658:11
    if _10: # src/fusion/ExprMul.monty:661:14-19
     _27=0
     _28=0
     _29=0
     _27,_28,_29 = fragments._c_closure_454(_16,_20,_21,_24,self.__msubi,self.__msubj,self.__mval,_9,_7,_11,_27,_28,_29,_13,_3,_4,_26) # src/fusion/ExprMul.monty:669:12-706:13
     _27 = numpy.int32(_27) # postprocess
     _28 = numpy.int32(_28) # postprocess
     _29 = numpy.int64(_29) # postprocess
     _30=(_28 < (_19 * self.__mdim1))
     _0._alloc_1expr_IIIZI(2,_28,numpy.int32(_29),_30,_27)
     _31=(_0.ptr_base)
     _32=(_0.nidxs_base)
     _33=((_0.sp_base) if (_30 ) else _0._alloci64_I(_28))
     _34=(_0.cof_base)
     _35=(_0.shape_base)
     _36=(_0.codeptr_base)
     _37=(_0.code_base)
     _38=(_0.cconst_base)
     _39=(_0.i32)
     _40=(_0.i64)
     _41=(_0.f64)
     _39[_35] = _19
     _39[(_35 + 1)] = self.__mdim1
     _39[_31] = 0
     if (_27 > 0): # src/fusion/ExprMul.monty:729:16-30
      _39[_36] = 0
     _42=0
     _43=0
     _44=0
     _45=0
     _43,_44,_42,_45 = fragments._c_closure_455(_18,_17,_43,_16,_15,_20,_44,_42,self.__mdim1,_21,_24,self.__msubi,self.__msubj,self.__mval,_9,_7,_14,_45,_11,_38,_37,_36,_34,_41,_39,_40,_32,_31,_33,_13,_5,_3,_4,_26) # src/fusion/ExprMul.monty:738:14-795:15
     _43 = numpy.int32(_43) # postprocess
     _44 = numpy.int32(_44) # postprocess
     _42 = numpy.int32(_42) # postprocess
     _45 = numpy.int32(_45) # postprocess
     if (_45!=_29): # src/fusion/ExprMul.monty:801:18-29
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
     if (_44!=_28): # src/fusion/ExprMul.monty:802:18-32
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
     if (_39[(_31 + _28)]!=_29): # src/fusion/ExprMul.monty:803:18-43
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
     if (not _30): # src/fusion/ExprMul.monty:805:16-26
      _0._popi64_I(_28)
    else:
     _46=0
     _47=(_19 * self.__mdim1)
     _48=0
     _46,_48 = fragments._c_closure_456(_16,_19,_20,_23,self.__mdim1,_24,self.__msubi,_9,_11,_46,_48,_3,_26) # src/fusion/ExprMul.monty:814:12-824:15
     _46 = numpy.int32(_46) # postprocess
     _48 = numpy.int32(_48) # postprocess
     _49=(_47 < (_19 * self.__mdim1))
     if (not (_48 <= 2147483647)): # src/fusion/ExprMul.monty:828:16-40
      raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceeded in multiplication")
     _0._alloc_1expr_IIIZI(2,_47,numpy.int32(_48),_49,_46)
     _50=(_0.shape_base)
     _51=(_0.ptr_base)
     _52=(_0.nidxs_base)
     _53=((_0.sp_base) if (_49 ) else _0._alloci64_I(_47))
     _54=(_0.cof_base)
     _55=(_0.code_base)
     _56=(_0.codeptr_base)
     _57=(_0.cconst_base)
     _58=(_0.i32)
     _59=(_0.i64)
     _60=(_0.f64)
     _58[_50] = _19
     _58[(_50 + 1)] = self.__mdim1
     _61=0
     _62=0
     _63=0
     _58[_51] = 0
     if (_46 > 0): # src/fusion/ExprMul.monty:859:16-30
      _58[_56] = 0
     _61,_63,_62 = fragments._c_closure_457(_18,_17,_61,_16,_15,_19,_20,_23,self.__mdim1,_24,self.__msubi,self.__mval,_14,_63,_11,_57,_55,_56,_54,_62,_60,_58,_59,_46,_52,_51,_53,_5,_3,_4,_26) # src/fusion/ExprMul.monty:861:12-900:15
     _61 = numpy.int32(_61) # postprocess
     _63 = numpy.int32(_63) # postprocess
     _62 = numpy.int32(_62) # postprocess
     if (not _49): # src/fusion/ExprMul.monty:902:16-26
      _0._popi64_I(_47)
    _2._clear_()
   else:
    _64=_2._alloci32_I((_19 + 1))
    _65=(_2.i32)
    fragments._c_closure_458(_19,_65,_64) # src/fusion/ExprMul.monty:911:10-55
    _66=(numpy.int64(_8) * self.__mdim1)
    _67=(_19 * self.__mdim1)
    _68=((_9 * self.__mdim1) + (0 if ((_9==0) ) else (numpy.int32(_66) * 2)))
    _69=False
    _70=2
    if (not (_66 <= 2147483647)): # src/fusion/ExprMul.monty:920:14-38
     raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceeded in multiplication")
    _0._alloc_1expr_IIIZI(_70,_67,numpy.int32(_66),_69,_68)
    _71=(_0.i32)
    _72=(_0.i64)
    _73=(_0.f64)
    _74=(_0.shape_base)
    _75=(_0.ptr_base)
    _76=(_0.nidxs_base)
    _77=(_0.sp_base)
    _78=(_0.cof_base)
    _79=(_0.code_base)
    _80=(_0.codeptr_base)
    _81=(_0.cconst_base)
    _71[_74] = _19
    _71[(_74 + 1)] = self.__mdim1
    _82=0
    _83=0
    _84=0
    _71[_75] = 0
    if (_68 > 0): # src/fusion/ExprMul.monty:944:14-28
     _71[_80] = 0
    if _10: # src/fusion/ExprMul.monty:945:14-19
     _82,_84,_83 = fragments._c_closure_459(_18,_17,_82,_16,_15,_19,_20,_84,self.__mdim1,self.__mval,_9,_7,_14,_83,_11,_81,_79,_80,_78,_73,_71,_72,_76,_75,_13,_5,_3,_4,_65,_64) # src/fusion/ExprMul.monty:946:12-986:13
     _82 = numpy.int32(_82) # postprocess
     _84 = numpy.int32(_84) # postprocess
     _83 = numpy.int32(_83) # postprocess
     if (_83!=_66): # src/fusion/ExprMul.monty:987:16-27
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num nonzeros")
     if (_84!=_67): # src/fusion/ExprMul.monty:988:16-30
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num elements")
     if (_82!=_68): # src/fusion/ExprMul.monty:989:16-35
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid num code atoms")
    else:
     _82,_84,_83 = fragments._c_closure_460(_18,_17,_82,_16,_15,_19,_20,_84,self.__mdim1,self.__mval,_9,_14,_83,_11,_81,_79,_80,_78,_73,_71,_72,_76,_75,_5,_3,_4) # src/fusion/ExprMul.monty:991:15-1027:11
     _82 = numpy.int32(_82) # postprocess
     _84 = numpy.int32(_84) # postprocess
     _83 = numpy.int32(_83) # postprocess
    _2._clear_()
  @staticmethod
  def __computeshape_alt_I_3I(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprMulRight.__computeshape_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape_I_3I(_0,_1):
   if (int((_1).shape[0])==1): # src/fusion/ExprMul.monty:569:12-24
    return (numpy.array([1,_0], dtype=numpy.dtype(numpy.int32)))
   else:
    return (numpy.array([_1[0],_0], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulRight.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   _6=_5._getShape_()
   if (int((_6).shape[0])!=2): # src/fusion/ExprMul.monty:507:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _7=_6[0]
   _8=_6[1]
   if ((_0 < 0) or ((_1 < 0) or ((_7 < 0) or (_8 < 0)))): # src/fusion/ExprMul.monty:514:12-60
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if (_0!=_8): # src/fusion/ExprMul.monty:516:12-26
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:518:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _9=int((_2).shape[0])
   _10=False
   _10 = fragments._c_closure_461(_10,_0,_1,_9,_2,_3) # src/fusion/ExprMul.monty:525:10-527:63
   if _10: # src/fusion/ExprMul.monty:528:14-17
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _11=False
   _11 = fragments._c_closure_462(_11,_9,_2,_3) # src/fusion/ExprMul.monty:533:10-535:82
   if _11: # src/fusion/ExprMul.monty:536:14-17
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulRight(M,")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulRight
mosek_fusion_ExprMulRight=__mk_mosek_fusion_ExprMulRight()
del __mk_mosek_fusion_ExprMulRight
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulLeft():
 class ExprMulLeft(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulLeft__expr','_ExprMulLeft__mval','_ExprMulLeft__msubj','_ExprMulLeft__msubi','_ExprMulLeft__mdim1','_ExprMulLeft__mdim0']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Expression
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulLeft.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulLeft._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulLeft._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulLeft.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulLeft._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulLeft._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulLeft.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulLeft'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated):
    o = ExprMulLeft.__new__(ExprMulLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(mdim0,mdim1,msubi,msubj,mval,expr,validated)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(validated))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(*args):
    if len(args) != 7: return False
    mdim0,mdim1,msubi,msubj,mval,expr,validated, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(validated))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr,numpy.int32(validated))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,validated):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulLeft.__computeshape_II_3I(mdim0,mdim1,expr._getShape_()))
   (self.__mdim0) = mdim0
   (self.__mdim1) = mdim1
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mval) = mval
   (self.__expr) = expr
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr):
    o = ExprMulLeft.__new__(ExprMulLeft)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_match_I__(mdim0) and __arg_match_I__(mdim1) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mval) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 6: return False
    mdim0,mdim1,msubi,msubj,mval,expr, = args
    return (__arg_alt_match_I__(mdim0) and __arg_alt_match_I__(mdim1) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mval) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(numpy.int32(mdim0),numpy.int32(mdim1),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mval,dtype=numpy.dtype(numpy.float64)),expr)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2(self,mdim0,mdim1,msubi,msubj,mval,expr):
   mosek_fusion_ExprMulLeft._ctor_init_II_3I_3I_3DLmosek_4fusion_4Expression_2I(self,mdim0,mdim1,msubi,msubj,mval,expr,mosek.fusion.ExprMulLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(mdim0,mdim1,msubi,msubj,mval,expr))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   (self.__expr)._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.codeptr_base)
   _14=(_1.code_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   if (_3!=2): # src/fusion/ExprMul.monty:169:12-19
    raise mosek_fusion_DimensionError._ctor_S("Invalid operator shape for multiplication")
   _19=9999
   _20=9999
   _21=9999
   _22=_16[_8]
   _23=_16[(_8 + 1)]
   _24=int((self.__msubi).shape[0])
   _25=(_24 < (numpy.int64(self.__mdim0) * numpy.int64(self.__mdim1)))
   _26=False
   _27=0
   _28=0
   _29=0
   if _7: # src/fusion/ExprMul.monty:183:12-17
    _19 = _2._alloci32_I(_5)
    _20 = _2._alloci32_I(_5)
    _21 = _2._alloci32_I((_23 + 1))
    _30=(_2.i32)
    fragments._c_closure_463(_23,_19,_21,_5,_10,_17,_30) # src/fusion/ExprMul.monty:191:10-203:11
    _27,_28,_29 = fragments._c_closure_464(_13,_23,_19,_21,self.__mdim0,_25,_24,self.__msubi,self.__msubj,_6,_4,_9,_27,_28,_29,_10,_16,_17,_30) # src/fusion/ExprMul.monty:206:10-241:11
    _27 = numpy.int32(_27) # postprocess
    _28 = numpy.int32(_28) # postprocess
    _29 = numpy.int64(_29) # postprocess
   else:
    _27,_28,_29 = fragments._c_closure_465(_13,_23,self.__mdim0,_25,_24,self.__msubi,self.__msubj,_6,_4,_9,_27,_28,_29,_16) # src/fusion/ExprMul.monty:243:13-272:9
    _27 = numpy.int32(_27) # postprocess
    _28 = numpy.int32(_28) # postprocess
    _29 = numpy.int64(_29) # postprocess
   if (not (_29 <= 2147483647)): # src/fusion/ExprMul.monty:276:12-36
    raise mosek_fusion_LengthError._ctor_S("Maximum number of nonzeros exceeded in multiplication")
   _26 = (_28 < (self.__mdim0 * _23))
   _31=2
   _0._alloc_1expr_IIIZI(_31,_28,numpy.int32(_29),_26,_27)
   _32=(_0.ptr_base)
   _33=(_0.nidxs_base)
   _34=((_0.sp_base) if (_26 ) else _0._alloci64_I(_28))
   _35=(_0.cof_base)
   _36=(_0.shape_base)
   _37=(_0.code_base)
   _38=(_0.codeptr_base)
   _39=(_0.cconst_base)
   _40=(_0.i64)
   _41=(_0.f64)
   _42=(_0.i32)
   _43=(_2.i32)
   _42[_36] = self.__mdim0
   _42[(_36 + 1)] = _23
   _42[_32] = 0
   if (_27 > 0): # src/fusion/ExprMul.monty:312:12-26
    _42[_38] = 0
   if _7: # src/fusion/ExprMul.monty:315:12-17
    if _25: # src/fusion/ExprMul.monty:316:14-19
     fragments._c_closure_466(_15,_14,_13,_12,_23,_19,_21,_24,self.__msubi,self.__msubj,self.__mval,_11,_9,_39,_37,_38,_35,_41,_42,_40,_27,_33,_32,_34,_10,_18,_16,_17,_43) # src/fusion/ExprMul.monty:316:21-366:11
    else:
     _44=0
     _45=0
     _46=0
     _44,_45,_46 = fragments._c_closure_467(_15,_14,_44,_13,_12,_23,_45,_19,_21,self.__mdim0,self.__mdim1,self.__mval,_11,_46,_9,_39,_37,_38,_35,_41,_42,_40,_27,_33,_32,_10,_18,_16,_17,_43) # src/fusion/ExprMul.monty:374:12-405:15
     _44 = numpy.int32(_44) # postprocess
     _45 = numpy.int32(_45) # postprocess
     _46 = numpy.int32(_46) # postprocess
     if (_45!=_28): # src/fusion/ExprMul.monty:407:16-30
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of elements")
     if (_46!=_29): # src/fusion/ExprMul.monty:408:16-28
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of non-zeros")
     if (_44!=_27): # src/fusion/ExprMul.monty:409:16-35
      raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of code atoms")
   else:
    _47=0
    _48=0
    _49=0
    _50=0
    _47,_49,_48,_50 = fragments._c_closure_468(_15,_14,_47,_13,_12,_23,_49,_24,_48,self.__msubi,self.__msubj,self.__mval,_11,_50,_9,_39,_37,_38,_35,_41,_42,_40,_27,_33,_32,_34,_18,_16,_17) # src/fusion/ExprMul.monty:416:10-457:11
    _47 = numpy.int32(_47) # postprocess
    _49 = numpy.int32(_49) # postprocess
    _48 = numpy.int32(_48) # postprocess
    _50 = numpy.int32(_50) # postprocess
    if (_49!=_28): # src/fusion/ExprMul.monty:458:14-28
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of elements")
    if (_50!=_29): # src/fusion/ExprMul.monty:459:14-26
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of non-zeros")
    if (_47!=_27): # src/fusion/ExprMul.monty:460:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Incorrect number of code atoms")
   if (not _26): # src/fusion/ExprMul.monty:463:12-22
    _0._popi64_I(_28)
   _2._clear_()
  @staticmethod
  def __computeshape_alt_II_3I(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprMulLeft.__computeshape_II_3I(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeshape_II_3I(_0,_1,_2):
   if (int((_2).shape[0])!=2): # src/fusion/ExprMul.monty:97:12-24
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   elif (_1!=_2[0]): # src/fusion/ExprMul.monty:99:16-27
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   return (numpy.array([_0,_2[1]], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def __validate_alt_II_3I_3I_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=_t__5
   _1 = mosek_fusion_ExprMulLeft.__validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validate_II_3I_3I_3DLmosek_4fusion_4Expression_2(_0,_1,_2,_3,_4,_5):
   if (_5._getND_()!=2): # src/fusion/ExprMul.monty:36:12-29
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   _6=_5._getDim_I(0)
   _7=_5._getDim_I(0)
   if ((_0 < 0) or (_1 < 0)): # src/fusion/ExprMul.monty:42:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   if (_1!=_6): # src/fusion/ExprMul.monty:44:12-26
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((_2).shape[0])!=int((_3).shape[0])) or (int((_2).shape[0])!=int((_4).shape[0]))): # src/fusion/ExprMul.monty:46:12-63
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   _8=int((_2).shape[0])
   _9=False
   _10=False
   _9,_10 = fragments._c_closure_469(_9,_10,_0,_1,_8,_2,_3) # src/fusion/ExprMul.monty:53:8-61:9
   if _9: # src/fusion/ExprMul.monty:62:12-20
    raise mosek_fusion_LengthError._ctor_S("Invalid matrix data")
   if _10: # src/fusion/ExprMul.monty:64:12-24
    raise mosek_fusion_LengthError._ctor_S("Unsorted matrix data")
   return numpy.int32(1)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulLeft(M(")._a_I(self.__mdim0)._a_S(",")._a_I(self.__mdim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprMulLeft
mosek_fusion_ExprMulLeft=__mk_mosek_fusion_ExprMulLeft()
del __mk_mosek_fusion_ExprMulLeft
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulVar():
 class ExprMulVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulVar__left','_ExprMulVar__x','_ExprMulVar__mcof','_ExprMulVar__msubj','_ExprMulVar__msubi','_ExprMulVar__mdimj','_ExprMulVar__mdimi']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args): # bool,int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):# bool,int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulVar.ctor(bool,int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Variable)')
  def eval_left(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1left_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_left('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval_left(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def eval_right(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_1right_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval_right('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval_right(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.toString()')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprMulVar'
  @staticmethod
  def _ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,mdimi,mdimj,msubi,msubj,mcof,x):
    o = ExprMulVar.__new__(ExprMulVar)
    o._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,mdimi,mdimj,msubi,msubj,mcof,x)
    return o
  @staticmethod
  def __match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 7: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_match_Z__(left) and __arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 7: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_alt_match_Z__(left) and __arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(self,left,mdimi,mdimj,msubi,msubj,mcof,x):
    self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(left,numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x)
  def _ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(self,left,mdimi,mdimj,msubi,msubj,mcof,x):
   mosek_fusion_ExprMulVar._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,1)
   _0=x._getShape_()
   _1=int((_0).shape[0])
   if (_1!=2): # src/fusion/ExprMulVar.monty:265:12-19
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   elif (left and (_0[0]!=mdimj)): # src/fusion/ExprMulVar.monty:267:16-43
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   elif ((not left) and (_0[1]!=mdimi)): # src/fusion/ExprMulVar.monty:269:16-47
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   if ((int((msubi).shape[0])!=int((msubj).shape[0])) or (int((msubi).shape[0])!=int((mcof).shape[0]))): # src/fusion/ExprMulVar.monty:272:12-63
    raise mosek_fusion_LengthError._ctor_S("Mismatching matrix data lengths")
   self.__validate_II_3I_3I_3D(mdimi,mdimj,msubi,msubj,mcof)
  @staticmethod
  def _ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    o = ExprMulVar.__new__(ExprMulVar)
    o._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_)
    return o
  @staticmethod
  def __match_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 8: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_match_Z__(left) and __arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 8: return False
    left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_alt_match_Z__(left) and __arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    self._ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(left,numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x,numpy.int32(unchecked_))
  def _ctor_init_ZII_3I_3I_3DLmosek_4fusion_4Variable_2I(self,left,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprMulVar.__resshape_II_3IZ(mdimi,mdimj,x._getShape_(),left))
   (self.__left) = left
   (self.__x) = x
   (self.__mdimi) = mdimi
   (self.__mdimj) = mdimj
   (self.__msubi) = mosek.fusion.Utils.Tools._arraycopy__3I(msubi)
   (self.__msubj) = mosek.fusion.Utils.Tools._arraycopy__3I(msubj)
   (self.__mcof) = mosek.fusion.Utils.Tools._arraycopy__3D(mcof)
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   if self.__left: # src/fusion/ExprMulVar.monty:741:12-16
    self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
   else:
    self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  @staticmethod
  def _match_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_1right_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_1right_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=(_1.pi32)
   _4=(_1.pi64)
   _5=self.__x._numInst_()
   _6=_1._alloci64_I(_5)
   _7=_1._alloci64_I(_5)
   _8=_1._alloci32_I(_5)
   _9=_1._alloci32_I(_5)
   _10=self.__x._getShape_()
   _11=int((_10).shape[0])
   _12=(_10[0] * _10[1])
   _13=_10[1]
   _14=_10[0]
   _15=_1._alloci32_I((_14 + 1))
   _16=int(((self.__msubi)).shape[0])
   _17=(self.__msubi)
   _18=(self.__msubj)
   _19=(self.__mcof)
   _20=(self.__mdimi)
   _21=(self.__mdimj)
   _22=((_16 // _20)==_21)
   _23=_1._alloci32_I(_16)
   _24=_1._alloci32_I((self.__mdimj + 1))
   _25=(_1.i32)
   _26=(_1.i64)
   _27=0
   _28=0
   self.__x._inst_I_3JI_3J(_7,_26,_6,_26)
   if _22: # src/fusion/ExprMulVar.monty:497:12-22
    _29=0
    _29 = fragments._c_closure_470(_5,_7,_26,_29,_14,_13) # src/fusion/ExprMulVar.monty:501:10-514:11
    _29 = numpy.int32(_29) # postprocess
    _28 = (_29 * _21)
    _27 = (_5 * _21)
    _30=(_29 < _14)
    _0._alloc_1expr_IIIZ(2,_28,_27,_30)
    _31=(_0.ptr_base)
    _32=(_0.shape_base)
    _33=(_0.nidxs_base)
    _34=((_0.sp_base) if (_30 ) else _0._alloci64_I(_28))
    _35=(_0.cof_base)
    _36=(_0.i32)
    _37=(_0.i64)
    _38=(_0.f64)
    _36[_32] = _14
    _36[(_32 + 1)] = _21
    fragments._c_closure_471(_19,_21,_6,_5,_35,_38,_36,_37,_33,_31,_34,_7,_26,_13) # src/fusion/ExprMulVar.monty:534:10-557:11
    if (not _30): # src/fusion/ExprMulVar.monty:558:14-23
     _0._popi64_I(_28)
   else:
    fragments._c_closure_472(_21,self.__mdimj,_24,_18,_16,_23,_25) # src/fusion/ExprMulVar.monty:563:10-582:11
    if ((_5 // _14)==_13): # src/fusion/ExprMulVar.monty:584:14-33
     _39=0
     _39 = fragments._c_closure_473(_18,_39,_16,_23,_25) # src/fusion/ExprMulVar.monty:587:12-594:13
     _39 = numpy.int32(_39) # postprocess
     _28 = (_39 * _14)
     _27 = (_16 * _14)
     _40=(_39 < _21)
     _0._alloc_1expr_IIIZ(2,_28,_27,_40)
     _41=(_0.ptr_base)
     _42=(_0.shape_base)
     _43=(_0.nidxs_base)
     _44=((_0.sp_base) if (_40 ) else _0._alloci64_I(_28))
     _45=(_0.cof_base)
     (_0.i32)[_42] = _14
     (_0.i32)[(_42 + 1)] = _21
     _46=(_0.i32)
     _47=(_0.i64)
     _48=(_0.f64)
     _46[_41] = 0
     _49=0
     _50=0
     _49,_50 = fragments._c_closure_474(_49,_50,_19,_21,_17,_18,_6,_16,_23,_45,_48,_46,_47,_43,_41,_44,_25,_26,_14,_13) # src/fusion/ExprMulVar.monty:620:12-639:13
     _49 = numpy.int32(_49) # postprocess
     _50 = numpy.int32(_50) # postprocess
     if (not _40): # src/fusion/ExprMulVar.monty:641:16-26
      _0._popi64_I(_28)
    else:
     fragments._c_closure_475(_15,_25,_14) # src/fusion/ExprMulVar.monty:645:14-55
     fragments._c_closure_476(_11,_5,_15,_7,_25,_26,_14,_10,_8,_9) # src/fusion/ExprMulVar.monty:647:12-659:13
     _28,_27 = fragments._c_closure_477(self.__mdimj,_24,_17,_28,_27,_23,_15,_25,_14,_9) # src/fusion/ExprMulVar.monty:663:12-682:15
     _28 = numpy.int32(_28) # postprocess
     _27 = numpy.int32(_27) # postprocess
     _51=(_28 < (_13 * self.__mdimi))
     _0._alloc_1expr_IIIZ(2,_28,_27,_51)
     _52=(_0.ptr_base)
     _53=(_0.shape_base)
     _54=(_0.nidxs_base)
     _55=(_0.sp_base)
     _56=(_0.cof_base)
     (_0.i32)[_53] = _14
     (_0.i32)[(_53 + 1)] = self.__mdimj
     _57=(_0.i32)
     _58=(_0.i64)
     _59=(_0.f64)
     fragments._c_closure_478(_19,self.__mdimj,_24,_17,_6,_23,_15,_56,_59,_57,_58,_54,_52,_55,_25,_26,_14,_9) # src/fusion/ExprMulVar.monty:699:12-729:13
     if (not _51): # src/fusion/ExprMulVar.monty:730:16-26
      _0._popi64_I(_28)
   (_1.pi32) = _3
   (_1.pi64) = _4
  @staticmethod
  def _match_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_1left_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_1left_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.__x._numInst_()
   _4=self.__x._getShape_()
   _5=int((_4).shape[0])
   _6=_2._alloci64_I(_3)
   _7=_2._alloci64_I(_3)
   _8=_2._alloci32_I(_3)
   _9=_2._alloci32_I(_3)
   _10=_2._alloci32_I(_3)
   _11=_2._alloci32_I((self.__mdimi + 1))
   _12=self.__x._getShape_()
   _13=int((_12).shape[0])
   _14=(1 if ((_13==1) ) else _12[1])
   _15=_12[0]
   _16=_2._alloci32_I((_14 + 1))
   _17=(self.__msubi)
   _18=(self.__msubj)
   _19=(self.__mcof)
   _20=(self.__mdimi)
   _21=(self.__mdimj)
   _22=0
   _23=0
   _24=(_2.i32)
   _25=(_2.i64)
   _26=int((_19).shape[0])
   self.__x._inst_I_3JI_3J(_7,_25,_6,_25)
   if (self.__x._numInst_() < self.__x._getSize_()): # src/fusion/ExprMulVar.monty:312:12-37
    _23,_22 = fragments._c_closure_479(_20,_11,_17,_18,_13,_3,_10,_16,_23,_22,_7,_14,_24,_25,_8,_9) # src/fusion/ExprMulVar.monty:312:39-368:9
    _23 = numpy.int32(_23) # postprocess
    _22 = numpy.int32(_22) # postprocess
   else:
    _23,_22 = fragments._c_closure_480(_26,_17,_23,_22,_14) # src/fusion/ExprMulVar.monty:368:15-378:9
    _23 = numpy.int32(_23) # postprocess
    _22 = numpy.int32(_22) # postprocess
   _27=(True if ((_23 < (_14 * _20)) ) else False)
   _28=_13
   _0._alloc_1expr_IIIZ(_28,_23,_22,_27)
   _29=(_0.ptr_base)
   _30=(_0.shape_base)
   _31=(_0.nidxs_base)
   _32=((_0.sp_base) if (_27 ) else _0._alloci64_I(_23))
   _33=(_0.cof_base)
   _34=(_0.i32)
   _35=(_0.i64)
   _36=(_0.f64)
   _34[_30] = _20
   if (_13 > 1): # src/fusion/ExprMulVar.monty:396:12-18
    _34[(_30 + 1)] = _14
   if (self.__x._numInst_() < self.__x._getSize_()): # src/fusion/ExprMulVar.monty:400:12-37
    fragments._c_closure_481(_19,_20,_11,_18,_6,_10,_16,_33,_36,_34,_35,_31,_29,_32,_14,_24,_25,_8) # src/fusion/ExprMulVar.monty:400:39-432:9
   else:
    fragments._c_closure_482(_19,_26,_17,_18,_6,_33,_36,_34,_35,_31,_29,_32,_14,_25) # src/fusion/ExprMulVar.monty:432:15-452:8
   if (not _27): # src/fusion/ExprMulVar.monty:454:12-22
    _0._popi64_I(_23)
   _2._clear_()
  def __validate_alt_II_3I_3I_3D(self,_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = self.__validate_II_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __validate_II_3I_3I_3D(self,_0,_1,_2,_3,_4):
   _5=True
   _5 = fragments._c_closure_483(_0,_1,_2,_3,_5) # src/fusion/ExprMulVar.monty:231:8-240:9
   if (not _5): # src/fusion/ExprMulVar.monty:242:12-18
    raise mosek_fusion_IndexError._ctor_S("Invalid matrix data")
  @staticmethod
  def __resshape_alt_II_3IZ(_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=_t__3
   _1 = mosek_fusion_ExprMulVar.__resshape_II_3IZ(_0,_1,_2,_3)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __resshape_II_3IZ(_0,_1,_2,_3):
   if _3: # src/fusion/ExprMulVar.monty:190:12-16
    return (numpy.array([_0,_2[1]], dtype=numpy.dtype(numpy.int32)))
   else:
    return (numpy.array([_2[0],_1], dtype=numpy.dtype(numpy.int32)))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   if self.__left: # src/fusion/ExprMulVar.monty:183:12-16
    return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulVar(M,")._a_S(self.__x._toString_())._a_S(")")._toString_())
   else:
    return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulVar(")._a_S(self.__x._toString_())._a_S(",M)")._toString_())
 return ExprMulVar
mosek_fusion_ExprMulVar=__mk_mosek_fusion_ExprMulVar()
del __mk_mosek_fusion_ExprMulVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulScalarVar():
 class ExprMulScalarVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulScalarVar__x','_ExprMulScalarVar__mcof','_ExprMulScalarVar__msubj','_ExprMulScalarVar__msubi','_ExprMulScalarVar__mdimj','_ExprMulScalarVar__mdimi']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args): # int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):# int32,int32,[]int32,[]int32,[]double,mosek.fusion.Variable
      self._ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulScalarVar.ctor(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1),mosek.fusion.Variable)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulScalarVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulScalarVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulScalarVar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulScalarVar'
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(mdimi,mdimj,msubi,msubj,mcof,x):
    o = ExprMulScalarVar.__new__(ExprMulScalarVar)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(mdimi,mdimj,msubi,msubj,mcof,x)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 6: return False
    mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 6: return False
    mdimi,mdimj,msubi,msubj,mcof,x, = args
    return (__arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(self,mdimi,mdimj,msubi,msubj,mcof,x):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x)
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2(self,mdimi,mdimj,msubi,msubj,mcof,x):
   mosek_fusion_ExprMulScalarVar._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,mosek.fusion.Utils.Tools._arraycopy__3I(msubi),mosek.fusion.Utils.Tools._arraycopy__3I(msubj),mosek.fusion.Utils.Tools._arraycopy__3D(mcof),x,1)
   if (x._getND_()!=0): # src/fusion/ExprMulVar.monty:105:12-26
    raise mosek_fusion_DimensionError._ctor_S("Invalid Variable size")
   if ((mdimi < 0) or ((mdimj < 0) or ((int((msubi).shape[0])!=int((msubj).shape[0])) or (int((msubi).shape[0])!=int((mcof).shape[0]))))): # src/fusion/ExprMulVar.monty:108:12-89
    raise mosek_fusion_LengthError._ctor_S("Invalid Matrix data")
   _0=False
   _0 = fragments._c_closure_484(_0,mdimi,mdimj,msubi,msubj) # src/fusion/ExprMulVar.monty:112:8-115:28
   if _0: # src/fusion/ExprMulVar.monty:116:12-20
    raise mosek_fusion_IndexError._ctor_S("Invalid Matrix data")
   _1=False
   _1 = fragments._c_closure_485(_1,msubi,msubj) # src/fusion/ExprMulVar.monty:120:8-123:30
   if _1: # src/fusion/ExprMulVar.monty:124:12-22
    raise mosek_fusion_IndexError._ctor_S("Matrix data not correctly sorted")
  @staticmethod
  def _ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    o = ExprMulScalarVar.__new__(ExprMulScalarVar)
    o._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(mdimi,mdimj,msubi,msubj,mcof,x,unchecked_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 7: return False
    mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_match_I__(mdimi) and __arg_match_I__(mdimj) and __arg_match__3I__(msubi) and __arg_match__3I__(msubj) and __arg_match__3D__(mcof) and __arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2I(*args):
    if len(args) != 7: return False
    mdimi,mdimj,msubi,msubj,mcof,x,unchecked_, = args
    return (__arg_alt_match_I__(mdimi) and __arg_alt_match_I__(mdimj) and __arg_alt_match__3I__(msubi) and __arg_alt_match__3I__(msubj) and __arg_alt_match__3D__(mcof) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
    self._ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(numpy.int32(mdimi),numpy.int32(mdimj),numpy.array(msubi,dtype=numpy.dtype(numpy.int32)),numpy.array(msubj,dtype=numpy.dtype(numpy.int32)),numpy.array(mcof,dtype=numpy.dtype(numpy.float64)),x,numpy.int32(unchecked_))
  def _ctor_init_II_3I_3I_3DLmosek_4fusion_4Variable_2I(self,mdimi,mdimj,msubi,msubj,mcof,x,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,numpy.array([mdimi,mdimj], dtype=numpy.dtype(numpy.int32)))
   (self.__mdimi) = mdimi
   (self.__mdimj) = mdimj
   (self.__msubi) = msubi
   (self.__msubj) = msubj
   (self.__mcof) = mcof
   (self.__x) = x
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   if (self.__x._numInst_()==0): # src/fusion/ExprMulVar.monty:129:12-28
    _0._alloc_1expr_IIIZ(2,0,0,False)
    (_0.i32)[(_0.shape_base)] = self.__mdimi
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdimj
   else:
    _3=numpy.zeros((1,), dtype=numpy.dtype(numpy.int64))
    self.__x._inst_I_3J(0,_3)
    _4=_3[0]
    _5=int((self.__msubi).shape[0])
    _6=_5
    _7=(_5 < (self.__mdimi * self.__mdimj))
    _0._alloc_1expr_IIIZ(2,_5,_6,_7)
    _8=(_0.ptr_base)
    (_0.i32)[(_0.shape_base)] = self.__mdimi
    (_0.i32)[((_0.shape_base) + 1)] = self.__mdimj
    _9=(_0.nidxs_base)
    _10=(_0.sp_base)
    _11=(_0.cof_base)
    _12=(_0.i32)
    _13=(_0.i64)
    _14=(_0.f64)
    fragments._c_closure_486(_11,_14,_7,_12,_13,self.__mcof,self.__mdimj,self.__msubi,self.__msubj,_5,_9,_6,_8,_10,_4) # src/fusion/ExprMulVar.monty:157:10-164:11
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprMulScalarVar(M(")._a_I(self.__mdimi)._a_S(",")._a_I(self.__mdimj)._a_S("), ")._a_S(self.__x._toString_())._a_S(")")._toString_())
 return ExprMulScalarVar
mosek_fusion_ExprMulScalarVar=__mk_mosek_fusion_ExprMulScalarVar()
del __mk_mosek_fusion_ExprMulScalarVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprMulVarScalarConst():
 class ExprMulVarScalarConst(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprMulVarScalarConst__c','_ExprMulVarScalarConst__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2D(*args): # mosek.fusion.Variable,double
      self._ctor_init_Lmosek_4fusion_4Variable_2D(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2D(*args):# mosek.fusion.Variable,double
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprMulVarScalarConst.ctor(mosek.fusion.Variable,double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVarScalarConst._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVarScalarConst.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprMulVarScalarConst._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprMulVarScalarConst._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprMulVarScalarConst.toString()')
  def __repr__(self): return 'mosek.fusion.ExprMulVarScalarConst'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2D(x,c):
    o = ExprMulVarScalarConst.__new__(ExprMulVarScalarConst)
    o._ctor_init_Lmosek_4fusion_4Variable_2D(x,c)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    x,c, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x) and __arg_match_D__(c))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2D(*args):
    if len(args) != 2: return False
    x,c, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x) and __arg_alt_match_D__(c))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2D(self,x,c):
    self._ctor_init_Lmosek_4fusion_4Variable_2D(x,numpy.float64(c))
  def _ctor_init_Lmosek_4fusion_4Variable_2D(self,x,c):
   mosek_fusion_BaseExpression._ctor_init__3I(self,x._getShape_())
   (self.__x) = x
   (self.__c) = c
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self.__x._numInst_()
   _4=_3
   _5=self.__x._getShape_()
   _6=int((_5).shape[0])
   _7=(mosek.fusion.Set._size__3I(_5) > _4)
   _0._alloc_1expr_IIIZ(_6,_4,_3,_7)
   _8=(_0.ptr_base)
   _9=(_0.nidxs_base)
   _10=(_0.sp_base)
   _11=(_0.cof_base)
   _12=(_0.shape_base)
   if _7: # src/fusion/ExprMulVar.monty:31:12-17
    self.__x._inst_I_3JI_3J(_10,(_0.i64),_9,(_0.i64))
   else:
    self.__x._inst_I_3J(_9,(_0.i64))
   _13=(_0.i32)
   _14=(_0.i64)
   _15=(_0.f64)
   fragments._c_closure_487(_11,_15,_13,_6,_4,_3,_8,_12,_5) # src/fusion/ExprMulVar.monty:42:8-46:9
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("ExprMulVarScalarConst()")
 return ExprMulVarScalarConst
mosek_fusion_ExprMulVarScalarConst=__mk_mosek_fusion_ExprMulVarScalarConst()
del __mk_mosek_fusion_ExprMulVarScalarConst
#BEFORE CLASS
def __mk_mosek_fusion_ExprAdd():
 class ExprAdd(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprAdd__m2','_ExprAdd__m1','_ExprAdd__e2','_ExprAdd__e1']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double,double
      self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):# mosek.fusion.Expression,mosek.fusion.Expression,double,double
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprAdd.ctor(mosek.fusion.Expression,mosek.fusion.Expression,double,double)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprAdd._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprAdd._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprAdd.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprAdd._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprAdd._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprAdd.toString()')
  def __repr__(self): return 'mosek.fusion.ExprAdd'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,m1,m2):
    o = ExprAdd.__new__(ExprAdd)
    o._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,m1,m2)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    e1,e2,m1,m2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e1) and __arg_match_Lmosek_4fusion_4Expression_2__(e2) and __arg_match_D__(m1) and __arg_match_D__(m2))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    e1,e2,m1,m2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e2) and __arg_alt_match_D__(m1) and __arg_alt_match_D__(m2))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(self,e1,e2,m1,m2):
    self._ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(e1,e2,numpy.float64(m1),numpy.float64(m2))
  def _ctor_init_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(self,e1,e2,m1,m2):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e1._getShape_())
   (self.__e1) = e1
   (self.__e2) = e2
   (self.__m1) = m1
   (self.__m2) = m2
   if (e1._getND_()!=e2._getND_()): # src/fusion/ExprAdd.monty:615:12-36
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   for _0 in range(0,e1._getND_()):
    if (e1._getDim_I(_0)!=e2._getDim_I(_0)): # src/fusion/ExprAdd.monty:618:14-42
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__e1._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   self.__e2._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _1._pop_1expr_()
   _16=(_1.nd)
   _17=(_1.shape_base)
   _18=(_1.nelem)
   _19=(_1.nnz)
   _20=(_1.ncodeatom)
   _21=(_1.hassp)
   _22=(_1.ptr_base)
   _23=(_1.sp_base)
   _24=(_1.nidxs_base)
   _25=(_1.cof_base)
   _26=(_1.code_base)
   _27=(_1.codeptr_base)
   _28=(_1.cconst_base)
   _29=(_1.i32)
   _30=(_1.i64)
   _31=(_1.f64)
   _32=((_20 > 0) or (_7 > 0))
   if (_16!=_3): # src/fusion/ExprAdd.monty:681:12-22
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   for _33 in range(0,_16):
    if (_29[(_17 + _33)]!=_29[(_4 + _33)]): # src/fusion/ExprAdd.monty:684:14-46
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   if ((not _21) and (not _8)): # src/fusion/ExprAdd.monty:687:12-37
    _34=_18
    _35=(_19 + _6)
    _36=0
    if _32: # src/fusion/ExprAdd.monty:691:14-27
     _36 += ((_20 + (_19 * 2)) if ((_20 > 0) ) else _19)
     _36 += ((_7 + (_6 * 2)) if ((_7 > 0) ) else _6)
    _37=_16
    _0._alloc_1expr_IIIZI(_37,_34,_35,False,_36)
    _38=(_0.shape_base)
    _39=(_0.ptr_base)
    _40=(_0.sp_base)
    _41=(_0.nidxs_base)
    _42=(_0.cof_base)
    _43=(_0.code_base)
    _44=(_0.codeptr_base)
    _45=(_0.cconst_base)
    _46=(_0.i32)
    _47=(_0.i64)
    _48=(_0.f64)
    fragments._c_closure_488(_46,_37,_38,_17,_29) # src/fusion/ExprAdd.monty:712:10-713:44
    _49=0
    _50=0
    if (_36 > 0): # src/fusion/ExprAdd.monty:716:14-28
     _46[_44] = 0
    _46[_39] = 0
    _49,_50 = fragments._c_closure_489(_28,_15,_26,_13,_49,_27,_14,_25,_12,_50,self.__m1,self.__m2,_20,_7,_24,_11,_22,_9,_45,_43,_44,_42,_48,_46,_47,_36,_34,_41,_39,_31,_29,_30) # src/fusion/ExprAdd.monty:721:10-788:11
    _49 = numpy.int32(_49) # postprocess
    _50 = numpy.int32(_50) # postprocess
   elif ((not _21) or (not _8)): # src/fusion/ExprAdd.monty:793:16-794:26
    if (not _8): # src/fusion/ExprAdd.monty:795:14-24
     _51=_5
     _52=_6
     _53=_9
     _54=_10
     _55=_11
     _56=_7
     _57=_14
     _58=_13
     _59=_15
     _60=_12
     _5 = _18
     _6 = _19
     _9 = _22
     _10 = _23
     _11 = _24
     _7 = _20
     _14 = _27
     _13 = _26
     _15 = _28
     _12 = _25
     _18 = _51
     _19 = _52
     _22 = _53
     _23 = _54
     _24 = _55
     _20 = _56
     _27 = _57
     _26 = _58
     _28 = _59
     _25 = _60
    _61=((self.__m1) if ((not _21) ) else (self.__m2))
    _62=((self.__m2) if ((not _21) ) else (self.__m1))
    _63=_18
    _64=(_19 + _6)
    _65=_16
    _66=(_20 + _7)
    if _32: # src/fusion/ExprAdd.monty:839:14-27
     _66 += ((2 * _19) if ((_20 > 0) ) else _19)
     _66 += ((2 * _6) if ((_7 > 0) ) else _6)
    _0._alloc_1expr_IIIZI(_65,_63,_64,False,_66)
    _67=(_0.shape_base)
    _68=(_0.ptr_base)
    _69=(_0.sp_base)
    _70=(_0.nidxs_base)
    _71=(_0.cof_base)
    _72=(_0.code_base)
    _73=(_0.codeptr_base)
    _74=(_0.cconst_base)
    _75=(_0.i32)
    _76=(_0.i64)
    _77=(_0.f64)
    _78=0
    _79=0
    _80=0
    fragments._c_closure_490(_75,_65,_67,_17,_29) # src/fusion/ExprAdd.monty:868:12-65
    _75[_68] = 0
    if (_66 > 0): # src/fusion/ExprAdd.monty:871:16-30
     _75[_73] = 0
    _81=0
    _82=0
    _78,_79,_82,_81,_80 = fragments._c_closure_491(_28,_15,_26,_13,_78,_27,_14,_25,_12,_79,_82,_81,_61,_62,_20,_7,_18,_5,_24,_11,_80,_22,_9,_74,_72,_73,_71,_77,_75,_76,_66,_70,_68,_10,_31,_29,_30) # src/fusion/ExprAdd.monty:873:12-1005:13
    _78 = numpy.int32(_78) # postprocess
    _79 = numpy.int32(_79) # postprocess
    _82 = numpy.int32(_82) # postprocess
    _81 = numpy.int32(_81) # postprocess
    _80 = numpy.int32(_80) # postprocess
    if (_80!=_64): # src/fusion/ExprAdd.monty:1008:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid nnz")
    if (_78!=_66): # src/fusion/ExprAdd.monty:1009:16-35
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: invalid codei")
   else:
    _83=(_19 + _6)
    _84=0
    _85=_16
    _86=(_20 + _7)
    if _32: # src/fusion/ExprAdd.monty:1017:14-27
     _86 += ((2 * _19) if ((_20 > 0) ) else _19)
     _86 += ((2 * _6) if ((_7 > 0) ) else _6)
    _87=1
    _87 = fragments._c_closure_492(_85,_17,_87,_29) # src/fusion/ExprAdd.monty:1021:25-69
    _87 = numpy.int64(_87) # postprocess
    _84 = fragments._c_closure_493(_18,_5,_84,_23,_10,_30) # src/fusion/ExprAdd.monty:1023:10-1031:11
    _84 = numpy.int32(_84) # postprocess
    _88=(_84 < _87)
    _0._alloc_1expr_IIIZI(_85,_84,_83,_88,_86)
    _89=(_0.shape_base)
    _90=(_0.ptr_base)
    _91=((_0.sp_base) if (_88 ) else _0._alloci64_I(_84))
    _92=(_0.nidxs_base)
    _93=(_0.cof_base)
    _94=(_0.code_base)
    _95=(_0.codeptr_base)
    _96=(_0.cconst_base)
    _97=(_0.i32)
    _98=(_0.i64)
    _99=(_0.f64)
    fragments._c_closure_494(_97,_85,_89,_17,_29) # src/fusion/ExprAdd.monty:1049:10-1050:44
    fragments._c_closure_495(_28,_15,_26,_13,_27,_14,_25,_12,self.__m1,self.__m2,_20,_7,_18,_5,_24,_11,_22,_9,_96,_94,_95,_93,_99,_97,_98,_86,_92,_90,_91,_23,_10,_31,_29,_30) # src/fusion/ExprAdd.monty:1053:10-1258:11
    if (not _88): # src/fusion/ExprAdd.monty:1260:14-24
     _0._popi64_I(_84)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprAdd(")._a_S(self.__e1._toString_())._a_S(",")._a_S(self.__e2._toString_())._a_S("; ")._a_D(self.__m1)._a_S(",")._a_D(self.__m2)._a_S(")")._toString_())
 return ExprAdd
mosek_fusion_ExprAdd=__mk_mosek_fusion_ExprAdd()
del __mk_mosek_fusion_ExprAdd
#BEFORE CLASS
def __mk_mosek_fusion_ExprWSum():
 class ExprWSum(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprWSum__w','_ExprWSum__es']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3Lmosek_4fusion_4Expression_2_3D(*args): # []mosek.fusion.Expression,[]double
      self._ctor_init__3Lmosek_4fusion_4Expression_2_3D(*args)
    elif self.__match_alt_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):# []mosek.fusion.Expression,[]double
      self._ctor_alt_init__3Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprWSum.ctor(array(mosek.fusion.Expression,ndim=1),array(double,ndim=1))')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprWSum._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprWSum._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprWSum.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprWSum._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprWSum._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprWSum.toString()')
  def __repr__(self): return 'mosek.fusion.ExprWSum'
  @staticmethod
  def _ctor__3Lmosek_4fusion_4Expression_2_3D(es,w):
    o = ExprWSum.__new__(ExprWSum)
    o._ctor_init__3Lmosek_4fusion_4Expression_2_3D(es,w)
    return o
  @staticmethod
  def __match_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    es,w, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(es) and __arg_match__3D__(w))
  @staticmethod
  def __match_alt_ctor__3Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    es,w, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(es) and __arg_alt_match__3D__(w))
  def _ctor_alt_init__3Lmosek_4fusion_4Expression_2_3D(self,es,w):
    self._ctor_init__3Lmosek_4fusion_4Expression_2_3D(numpy.array(es,dtype=numpy.dtype(object)),numpy.array(w,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3Lmosek_4fusion_4Expression_2_3D(self,es,w):
   mosek_fusion_BaseExpression._ctor_init__3I(self,es[0]._getShape_())
   if (int((w).shape[0])!=int((es).shape[0])): # src/fusion/ExprAdd.monty:257:12-29
    raise mosek_fusion_LengthError._ctor_S("Mismatching weights and expressions array lengths")
   (self.__w) = mosek.fusion.Utils.Tools._arraycopy__3D(w)
   _0=es[0]._getShape_()
   _1=int((_0).shape[0])
   for _2 in range(1,int((es).shape[0])):
    _3=es[_2]._getShape_()
    if (_1!=int((_3).shape[0])): # src/fusion/ExprAdd.monty:266:14-31
     raise mosek_fusion_DimensionError._ctor_S("Mismatching expression shapes")
    else:
     for _4 in range(0,_1):
      if (_0[_4]!=_3[_4]): # src/fusion/ExprAdd.monty:270:18-39
       raise mosek_fusion_DimensionError._ctor_S("Mismatching expression shapes")
   (self.__es) = numpy.array([es[_5] for _5 in range(0,int((es).shape[0]))], dtype=numpy.dtype(object))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=int((self.__es).shape[0])
   for _4 in range(0,_3):
    self.__es[_4]._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _9=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _14=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _15=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _16=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _17=numpy.zeros((_3,), dtype=numpy.dtype(bool))
   for _18 in range(0,_3):
    _1._pop_1expr_()
    _5[((_3 - 1) - _18)] = (_1.nd)
    _6[((_3 - 1) - _18)] = (_1.nelem)
    _7[((_3 - 1) - _18)] = (_1.nnz)
    _8[((_3 - 1) - _18)] = (_1.ncodeatom)
    _9[((_3 - 1) - _18)] = (_1.ptr_base)
    _11[((_3 - 1) - _18)] = (_1.sp_base)
    _10[((_3 - 1) - _18)] = (_1.nidxs_base)
    _12[((_3 - 1) - _18)] = (_1.cof_base)
    _13[((_3 - 1) - _18)] = (_1.shape_base)
    _14[((_3 - 1) - _18)] = (_1.code_base)
    _15[((_3 - 1) - _18)] = (_1.codeptr_base)
    _16[((_3 - 1) - _18)] = (_1.cconst_base)
    _17[((_3 - 1) - _18)] = (_1.hassp)
   _19=(_1.i32)
   _20=(_1.i64)
   _21=(_1.f64)
   _22=True
   _22 = fragments._c_closure_496(_3,_5,_22,_13,_19) # src/fusion/ExprAdd.monty:326:10-330:11
   if (not _22): # src/fusion/ExprAdd.monty:331:14-20
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   _23=numpy.array([_19[(_13[0] + _24)] for _24 in range(0,_5[0])], dtype=numpy.dtype(numpy.int32))
   _25=False
   for _26 in range(0,_3):
    if (not _17[_26]): # src/fusion/ExprAdd.monty:337:53-65
     _25 = True
   _27=False
   _27 = fragments._c_closure_497(_27,_3,_8) # src/fusion/ExprAdd.monty:338:33-93
   _28=0
   _29=0
   _30=0
   if _25: # src/fusion/ExprAdd.monty:342:12-20
    _29 = numpy.int32(mosek.fusion.Set._size__3I(_23))
    _28,_30 = fragments._c_closure_498(_27,_3,_8,_7,_28,_30) # src/fusion/ExprAdd.monty:344:10-348:11
    _28 = numpy.int32(_28) # postprocess
    _30 = numpy.int32(_30) # postprocess
   else:
    _28,_29,_30 = fragments._c_closure_499(_27,_3,_8,_6,_7,_28,_29,_30,_11,_20) # src/fusion/ExprAdd.monty:350:13-373:9
    _28 = numpy.int32(_28) # postprocess
    _29 = numpy.int32(_29) # postprocess
    _30 = numpy.int32(_30) # postprocess
   _0._alloc_1expr_IIIZI(_5[0],_29,_30,(not _25),_28)
   _31=(_0.ptr_base)
   _32=(_0.nidxs_base)
   _33=(_0.sp_base)
   _34=(_0.shape_base)
   _35=(_0.cof_base)
   _36=(_0.code_base)
   _37=(_0.codeptr_base)
   _38=(_0.cconst_base)
   _39=(_0.i32)
   _40=(_0.i64)
   _41=(_0.f64)
   fragments._c_closure_500(_5,_39,_34,_13,_19) # src/fusion/ExprAdd.monty:394:8-70
   if (_28 > 0): # src/fusion/ExprAdd.monty:396:12-26
    _39[_37] = 0
   fragments._c_closure_501(_39,_29,_31) # src/fusion/ExprAdd.monty:398:8-399:32
   if _25: # src/fusion/ExprAdd.monty:402:12-20
    _42=(- 9999)
    if (_28 > 0): # src/fusion/ExprAdd.monty:404:14-28
     _42 = _2._alloci32_I((_29 + 1))
    _43=(_2.i32)
    fragments._c_closure_502(_28,_29,_42,_43) # src/fusion/ExprAdd.monty:407:10-408:59
    for _44 in range(0,_3):
     if _17[_44]: # src/fusion/ExprAdd.monty:411:16-24
      fragments._c_closure_503(_27,_15,_44,_8,_6,_9,_39,_31,_11,_19,_20,_42,_43) # src/fusion/ExprAdd.monty:411:26-420:13
     else:
      fragments._c_closure_504(_27,_15,_44,_8,_6,_9,_39,_31,_19,_42,_43) # src/fusion/ExprAdd.monty:421:17-430:13
    fragments._c_closure_505(_39,_29,_31) # src/fusion/ExprAdd.monty:433:10-434:53
    fragments._c_closure_506(_28,_29,_42,_43) # src/fusion/ExprAdd.monty:435:10-440:11
    for _45 in range(0,_3):
     if _17[_45]: # src/fusion/ExprAdd.monty:443:16-24
      fragments._c_closure_507(_27,_16,_14,_15,_12,_45,_8,_6,_10,_9,_38,_36,_37,_35,_41,_39,_40,_32,_31,_11,self.__w,_21,_19,_20,_42,_43) # src/fusion/ExprAdd.monty:443:26-483:13
     else:
      fragments._c_closure_508(_27,_16,_14,_15,_12,_45,_8,_6,_10,_9,_38,_36,_37,_35,_41,_39,_40,_32,_31,self.__w,_21,_19,_20,_42,_43) # src/fusion/ExprAdd.monty:484:17-524:13
    fragments._c_closure_509(_39,_29,_31) # src/fusion/ExprAdd.monty:527:10-528:66
    _39[_31] = 0
   else:
    fragments._c_closure_510(_27,_16,_14,_15,_12,_3,_8,_6,_10,_9,_38,_36,_37,_35,_41,_39,_40,_32,_31,_33,_11,self.__w,_21,_19,_20) # src/fusion/ExprAdd.monty:531:13-580:9
   _2._clear_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprWSum([")
   _0._a_S(self.__es[0]._toString_())
   for _1 in range(1,int((self.__es).shape[0])):
    _0._a_S(",")._a_S(self.__es[_1]._toString_())
   _0._a_S("])")
   return (_0._toString_())
 return ExprWSum
mosek_fusion_ExprWSum=__mk_mosek_fusion_ExprWSum()
del __mk_mosek_fusion_ExprWSum
#BEFORE CLASS
def __mk_mosek_fusion_ExprSumReduce():
 class ExprSumReduce(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSumReduce__dim','_ExprSumReduce__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_ILmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression
      self._ctor_init_ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):# int32,mosek.fusion.Expression
      self._ctor_alt_init_ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSumReduce.ctor(int32,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSumReduce._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduce.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprSumReduce._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprSumReduce._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSumReduce.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSumReduce'
  @staticmethod
  def _ctor_ILmosek_4fusion_4Expression_2(dim,expr):
    o = ExprSumReduce.__new__(ExprSumReduce)
    o._ctor_init_ILmosek_4fusion_4Expression_2(dim,expr)
    return o
  @staticmethod
  def __match_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    dim,expr, = args
    return (__arg_match_I__(dim) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    dim,expr, = args
    return (__arg_alt_match_I__(dim) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_ILmosek_4fusion_4Expression_2(self,dim,expr):
    self._ctor_init_ILmosek_4fusion_4Expression_2(numpy.int32(dim),expr)
  def _ctor_init_ILmosek_4fusion_4Expression_2(self,dim,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.ExprSumReduce.__computeShape_I_3I(dim,expr._getShape_()))
   (self.__expr) = expr
   (self.__dim) = dim
   _0=expr._getShape_()
   if (int((_0).shape[0]) <= dim): # src/fusion/ExprAdd.monty:23:12-29
    raise mosek_fusion_DimensionError._ctor_S("Invalid summing dimension")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.shape_base)
   _5=(_1.nelem)
   _6=(_1.nnz)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.ptr_base)
   _10=(_1.sp_base)
   _11=(_1.nidxs_base)
   _12=(_1.cof_base)
   _13=(_1.code_base)
   _14=(_1.codeptr_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=99999
   _20=99999
   _21=99999
   if _8: # src/fusion/ExprAdd.monty:53:12-17
    _22=0
    _22 = fragments._c_closure_511(_22,_3,_4,_16) # src/fusion/ExprAdd.monty:55:10-91
    _22 = numpy.int32(_22) # postprocess
    _19 = _2._alloci32_I((_22 + 1))
    _20 = _2._alloci32_I(_5)
    _21 = _2._alloci32_I(_5)
   _23=(_2.i32)
   if _8: # src/fusion/ExprAdd.monty:64:12-17
    _24=_20
    _25=_21
    fragments._c_closure_512(_24,_5,_23) # src/fusion/ExprAdd.monty:69:10-53
    _24,_25 = fragments._c_closure_513(_24,self.__dim,_3,_5,_19,_4,_10,_25,_16,_17,_23) # src/fusion/ExprAdd.monty:70:10-90:11
    _24 = numpy.int32(_24) # postprocess
    _25 = numpy.int32(_25) # postprocess
    _26=1
    _26 = fragments._c_closure_514(_26,self.__dim,_4,_16) # src/fusion/ExprAdd.monty:92:22-68
    _26 = numpy.int32(_26) # postprocess
    _27=_16[(_4 + self.__dim)]
    _28=1
    _28 = fragments._c_closure_515(_28,self.__dim,_3,_4,_16) # src/fusion/ExprAdd.monty:94:22-71
    _28 = numpy.int32(_28) # postprocess
    _29=(_28 * _27)
    _30=_28
    _31=1
    _32=0
    _33=(- 1)
    _34=(- 1)
    _34,_33,_32 = fragments._c_closure_516(_24,_26,_28,_5,_34,_33,_32,_29,_10,_17,_23) # src/fusion/ExprAdd.monty:99:10-107:11
    _34 = numpy.int64(_34) # postprocess
    _33 = numpy.int64(_33) # postprocess
    _32 = numpy.int32(_32) # postprocess
    _35=(_3 - 1)
    _36=(_32 < (_26 * _28))
    _37=_6
    _38=_7
    _0._alloc_1expr_IIIZI(_35,_32,_37,_36,_38)
    _39=(_0.ptr_base)
    _40=(_0.nidxs_base)
    _41=((_0.sp_base) if (_36 ) else _0._alloci64_I(_32))
    _42=(_0.cof_base)
    _43=(_0.shape_base)
    _44=(_0.code_base)
    _45=(_0.codeptr_base)
    _46=(_0.cconst_base)
    _47=(_0.i32)
    _48=(_0.i64)
    _49=(_0.f64)
    fragments._c_closure_517(self.__dim,_47,_43,_4,_16) # src/fusion/ExprAdd.monty:130:10-72
    fragments._c_closure_518(self.__dim,_3,_47,_43,_4,_16) # src/fusion/ExprAdd.monty:131:10-77
    _47[_39] = 0
    if (_38 > 0): # src/fusion/ExprAdd.monty:133:14-28
     _47[_45] = 0
    _50=0
    _51=0
    _52=0
    _53=0
    _50,_53,_51,_52 = fragments._c_closure_519(_15,_13,_50,_14,_12,_24,_26,_28,_53,_51,_52,_5,_11,_9,_46,_44,_45,_42,_49,_47,_48,_38,_40,_39,_41,_29,_10,_18,_16,_17,_23) # src/fusion/ExprAdd.monty:137:22-168:11
    _50 = numpy.int32(_50) # postprocess
    _53 = numpy.int32(_53) # postprocess
    _51 = numpy.int32(_51) # postprocess
    _52 = numpy.int32(_52) # postprocess
    if (not _36): # src/fusion/ExprAdd.monty:170:14-24
     _0._popi64_I(_32)
   else:
    _54=1
    _54 = fragments._c_closure_520(_54,self.__dim,_4,_16) # src/fusion/ExprAdd.monty:175:22-68
    _54 = numpy.int32(_54) # postprocess
    _55=_16[(_4 + self.__dim)]
    _56=1
    _56 = fragments._c_closure_521(_56,self.__dim,_3,_4,_16) # src/fusion/ExprAdd.monty:177:22-71
    _56 = numpy.int32(_56) # postprocess
    _57=(_56 * _55)
    _58=_56
    _59=1
    _60=(_54 * _56)
    _61=_6
    _62=_7
    _0._alloc_1expr_IIIZI((_3 - 1),_60,_61,False,_62)
    _63=(_0.ptr_base)
    _64=(_0.nidxs_base)
    _65=(_0.cof_base)
    _66=(_0.shape_base)
    _67=(_0.code_base)
    _68=(_0.codeptr_base)
    _69=(_0.cconst_base)
    _70=(_0.i32)
    _71=(_0.i64)
    _72=(_0.f64)
    fragments._c_closure_522(self.__dim,_70,_66,_4,_16) # src/fusion/ExprAdd.monty:196:10-67
    fragments._c_closure_523(self.__dim,_3,_70,_66,_4,_16) # src/fusion/ExprAdd.monty:197:10-72
    _73=0
    _74=0
    _70[_63] = 0
    if (_62 > 0): # src/fusion/ExprAdd.monty:201:14-28
     _70[_68] = 0
    _75=0
    _75,_73,_74 = fragments._c_closure_524(_15,_13,_75,_14,_12,_54,_55,_56,_73,_74,_11,_9,_69,_67,_68,_65,_72,_70,_71,_62,_64,_63,_57,_58,_18,_16,_17) # src/fusion/ExprAdd.monty:204:10-227:13
    _75 = numpy.int32(_75) # postprocess
    _73 = numpy.int32(_73) # postprocess
    _74 = numpy.int32(_74) # postprocess
   _2._clear_()
  @staticmethod
  def __computeShape_alt_I_3I(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_ExprSumReduce.__computeShape_I_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __computeShape_I_3I(_0,_1):
   _2=numpy.zeros(((int((_1).shape[0]) - 1),), dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_525(_0,_2,_1) # src/fusion/ExprAdd.monty:12:8-45
   fragments._c_closure_526(_0,_2,_1) # src/fusion/ExprAdd.monty:13:8-58
   return (_2)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprSumReduce(")._a_I(self.__dim)._a_S(",")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprSumReduce
mosek_fusion_ExprSumReduce=__mk_mosek_fusion_ExprSumReduce()
del __mk_mosek_fusion_ExprSumReduce
#BEFORE CLASS
def __mk_mosek_fusion_ExprScaleVecPSD():
 class ExprScaleVecPSD(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprScaleVecPSD__dim1','_ExprScaleVecPSD__dim0','_ExprScaleVecPSD__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4BaseExpression_2(*args): # int32,int32,mosek.fusion.BaseExpression
      self._ctor_init_IILmosek_4fusion_4BaseExpression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4BaseExpression_2(*args):# int32,int32,mosek.fusion.BaseExpression
      self._ctor_alt_init_IILmosek_4fusion_4BaseExpression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprScaleVecPSD.ctor(int32,int32,mosek.fusion.BaseExpression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprScaleVecPSD._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprScaleVecPSD._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprScaleVecPSD.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def __repr__(self): return 'mosek.fusion.ExprScaleVecPSD'
  @staticmethod
  def _ctor_IILmosek_4fusion_4BaseExpression_2(dim0,dim1,expr):
    o = ExprScaleVecPSD.__new__(ExprScaleVecPSD)
    o._ctor_init_IILmosek_4fusion_4BaseExpression_2(dim0,dim1,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4BaseExpression_2(*args):
    if len(args) != 3: return False
    dim0,dim1,expr, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4BaseExpression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4BaseExpression_2(*args):
    if len(args) != 3: return False
    dim0,dim1,expr, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4BaseExpression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4BaseExpression_2(self,dim0,dim1,expr):
    self._ctor_init_IILmosek_4fusion_4BaseExpression_2(numpy.int32(dim0),numpy.int32(dim1),expr)
  def _ctor_init_IILmosek_4fusion_4BaseExpression_2(self,dim0,dim1,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
   (self.__dim0) = dim0
   (self.__dim1) = dim1
   if ((dim0 < 0) or ((dim1 < 0) or (dim0==dim1))): # src/fusion/ExprShape.monty:1052:12-48
    raise mosek_fusion_DimensionError._ctor_S("Invalid symmetry dimensions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.code_base)
   _11=(_1.codeptr_base)
   _12=(_1.cconst_base)
   _13=(_1.nidxs_base)
   _14=(_1.sp_base)
   _15=(_1.cof_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   if ((self.__dim0 >= _3) or (self.__dim1 >= _3)): # src/fusion/ExprShape.monty:1077:12-36
    raise mosek_fusion_DimensionError._ctor_S("Invalid symmetry dimensions")
   elif (_16[(_8 + self.__dim0)]!=_16[(_8 + self.__dim1)]): # src/fusion/ExprShape.monty:1079:16-52
    raise mosek_fusion_DimensionError._ctor_S("Not symmetric in given dimensions")
   _19=1
   _20=1
   _21=1
   _22=1
   _23=1
   _24=(self.__dim0 if ((self.__dim0 < self.__dim1) ) else self.__dim1)
   _25=(self.__dim1 if ((self.__dim0 < self.__dim1) ) else self.__dim0)
   _23 = fragments._c_closure_527(_23,_8,_16,_24) # src/fusion/ExprShape.monty:1091:8-57
   _23 = numpy.int64(_23) # postprocess
   _21 = fragments._c_closure_528(_21,_8,_16,_24,_25) # src/fusion/ExprShape.monty:1092:8-57
   _21 = numpy.int64(_21) # postprocess
   _19 = fragments._c_closure_529(_19,_3,_8,_16,_25) # src/fusion/ExprShape.monty:1093:8-57
   _19 = numpy.int64(_19) # postprocess
   _22 = _16[(_8 + self.__dim0)]
   _20 = _22
   if (_6==0): # src/fusion/ExprShape.monty:1096:12-26
    _0._alloc_1expr_IIIZI(_3,_5,_4,_7,0)
   else:
    _0._alloc_1expr_IIIZI(_3,_5,_4,_7,(_6 + (_4 * 2)))
   _26=(_0.ptr_base)
   _27=(_0.shape_base)
   _28=(_0.nidxs_base)
   _29=(_0.sp_base)
   _30=(_0.cof_base)
   _31=(_0.code_base)
   _32=(_0.codeptr_base)
   _33=(_0.cconst_base)
   _34=(_0.i32)
   _35=(_0.i64)
   _36=(_0.f64)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_16,_9,_34,_26,(_5 + 1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(_16,_8,_34,_27,_3)
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_17,_13,_35,_28,_4)
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(_18,_15,_36,_30,_4)
   if _7: # src/fusion/ExprShape.monty:1120:14-19
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(_17,_14,_35,_29,_5)
   _37=mosek.fusion.Utils.Tools._sqrt_D(2)
   fragments._c_closure_530(_23,_22,_21,_20,_19,_7,_5,_30,_36,_34,_26,_37,_14,_17) # src/fusion/ExprShape.monty:1125:8-1158:9
   fragments._c_closure_531(_12,_10,_11,_23,_22,_21,_20,_19,_7,_6,_5,_9,_33,_31,_32,_36,_34,_37,_14,_18,_16,_17) # src/fusion/ExprShape.monty:1160:8-1220:9
 return ExprScaleVecPSD
mosek_fusion_ExprScaleVecPSD=__mk_mosek_fusion_ExprScaleVecPSD()
del __mk_mosek_fusion_ExprScaleVecPSD
#BEFORE CLASS
def __mk_mosek_fusion_ExprDenseTril():
 class ExprDenseTril(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDenseTril__dim1','_ExprDenseTril__dim0','_ExprDenseTril__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args): # int32,int32,mosek.fusion.Expression
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):# int32,int32,mosek.fusion.Expression
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDenseTril.ctor(int32,int32,mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprDenseTril._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDenseTril._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDenseTril.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprDenseTril._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprDenseTril._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDenseTril.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDenseTril'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_):
    o = ExprDenseTril.__new__(ExprDenseTril)
    o._ctor_init_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
    self._ctor_init_IILmosek_4fusion_4Expression_2I(numpy.int32(dim0),numpy.int32(dim1),expr,numpy.int32(unchecked_))
  def _ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
   (self.__dim0) = dim0
   (self.__dim1) = dim1
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr):
    o = ExprDenseTril.__new__(ExprDenseTril)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_match_I__(dim0_) and __arg_match_I__(dim1_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_alt_match_I__(dim0_) and __arg_alt_match_I__(dim1_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0_),numpy.int32(dim1_),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
   mosek_fusion_ExprDenseTril._ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0_,dim1_,expr,1)
   _0=expr._getShape_()
   if ((self.__dim0==self.__dim1) or ((self.__dim0 < 0) or ((self.__dim0 >= int((_0).shape[0])) or ((self.__dim1 < 0) or ((self.__dim1 >= int((_0).shape[0])) or (_0[self.__dim0]!=_0[self.__dim1])))))): # src/fusion/ExprShape.monty:789:12-794:38
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension definitions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.code_base)
   _11=(_1.codeptr_base)
   _12=(_1.cconst_base)
   _13=(_1.nidxs_base)
   _14=(_1.sp_base)
   _15=(_1.cof_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=(self.__dim0 if ((self.__dim0 < self.__dim1) ) else self.__dim1)
   _20=(self.__dim0 if ((self.__dim0 > self.__dim1) ) else self.__dim1)
   _21=(self.__dim0 < self.__dim1)
   if ((self.__dim0==self.__dim1) or ((self.__dim0 < 0) or ((self.__dim0 >= _3) or ((self.__dim1 < 0) or (self.__dim1 >= _3))))): # src/fusion/ExprShape.monty:833:12-835:34
    raise mosek_fusion_DimensionError._ctor_S("Invalid symmetry dimensions")
   elif (_16[(_8 + self.__dim0)]!=_16[(_8 + self.__dim1)]): # src/fusion/ExprShape.monty:837:16-52
    raise mosek_fusion_DimensionError._ctor_S("Not symmetric in given dimensions")
   _22=numpy.array([1 for _23 in range(0,5)], dtype=numpy.dtype(numpy.int32))
   fragments._c_closure_532(_22,_8,_16,_19) # src/fusion/ExprShape.monty:841:8-55
   _22[1] = _16[(_8 + self.__dim0)]
   fragments._c_closure_533(_22,_8,_16,_19,_20) # src/fusion/ExprShape.monty:843:8-61
   _22[3] = _16[(_8 + self.__dim1)]
   fragments._c_closure_534(_22,_3,_8,_16,_20) # src/fusion/ExprShape.monty:845:8-58
   _24=numpy.zeros((5,), dtype=numpy.dtype(numpy.int32))
   _24[4] = 1
   fragments._c_closure_535(_22,_24) # src/fusion/ExprShape.monty:852:8-66
   _25=0
   _26=(((_22[0] * _22[2]) * _22[4]) * ((_22[1] * (_22[1] + 1)) // 2))
   _27=0
   _27,_25 = fragments._c_closure_536(_11,_22,_7,_6,_5,_9,_27,_25,_14,_24,_21,_16,_17) # src/fusion/ExprShape.monty:859:8-912:9
   _27 = numpy.int32(_27) # postprocess
   _25 = numpy.int32(_25) # postprocess
   _28=(((((_22[0] * _22[2]) * _22[4]) * _22[1]) * (_22[1] + 1)) // 2)
   _0._alloc_1expr_IIIZI(_3,_26,_25,True,_27)
   _29=(_0.ptr_base)
   _30=(_0.shape_base)
   _31=(_0.nidxs_base)
   _32=(_0.sp_base)
   _33=(_0.cof_base)
   _34=(_0.code_base)
   _35=(_0.codeptr_base)
   _36=(_0.cconst_base)
   _37=(_0.i32)
   _38=(_0.i64)
   _39=(_0.f64)
   _37[_29] = 0
   if (_27 > 0): # src/fusion/ExprShape.monty:939:12-26
    _37[_35] = 0
   fragments._c_closure_537(_3,_37,_30,_8,_16) # src/fusion/ExprShape.monty:941:8-59
   if _21: # src/fusion/ExprShape.monty:943:12-16
    _40=0
    _40 = fragments._c_closure_538(_22,_40,_38,_32,_24) # src/fusion/ExprShape.monty:945:10-952:19
    _40 = numpy.int32(_40) # postprocess
    if (_40!=_26): # src/fusion/ExprShape.monty:953:14-25
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   else:
    _41=0
    _41 = fragments._c_closure_539(_22,_41,_38,_32,_24) # src/fusion/ExprShape.monty:957:10-964:19
    _41 = numpy.int32(_41) # postprocess
    if (_41!=_26): # src/fusion/ExprShape.monty:965:14-25
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   _42=0
   _43=0
   _43,_42 = fragments._c_closure_540(_12,_10,_43,_11,_15,_28,_7,_5,_13,_42,_9,_36,_34,_35,_33,_39,_37,_38,_27,_31,_29,_32,_14,_18,_16,_17) # src/fusion/ExprShape.monty:972:10-1027:11
   _43 = numpy.int32(_43) # postprocess
   _42 = numpy.int32(_42) # postprocess
   if (_42!=_25): # src/fusion/ExprShape.monty:1030:14-25
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDenseTril(symdim=(")._a_I(self.__dim0)._a_S(",")._a_I(self.__dim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprDenseTril
mosek_fusion_ExprDenseTril=__mk_mosek_fusion_ExprDenseTril()
del __mk_mosek_fusion_ExprDenseTril
#BEFORE CLASS
def __mk_mosek_fusion_ExprDense():
 class ExprDense(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprDense__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprDense.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprDense._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprDense._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprDense._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprDense._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprDense.toString()')
  def __repr__(self): return 'mosek.fusion.ExprDense'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprDense.__new__(ExprDense)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=(_1.nd)
   _4=(_1.nnz)
   _5=(_1.nelem)
   _6=(_1.ncodeatom)
   _7=(_1.hassp)
   _8=(_1.shape_base)
   _9=(_1.ptr_base)
   _10=(_1.nidxs_base)
   _11=(_1.cof_base)
   _12=(_1.sp_base)
   _13=(_1.codeptr_base)
   _14=(_1.code_base)
   _15=(_1.cconst_base)
   _16=(_1.i32)
   _17=(_1.i64)
   _18=(_1.f64)
   _19=1
   if _7: # src/fusion/ExprShape.monty:725:12-17
    _20=True
    _20,_19 = fragments._c_closure_541(_3,_20,_19,_8,_16) # src/fusion/ExprShape.monty:727:10-731:11
    _19 = numpy.int32(_19) # postprocess
    if (not _20): # src/fusion/ExprShape.monty:732:14-20
     raise mosek_fusion_LengthError._ctor_S("The domain is too large")
   else:
    _19 = _5
   _0._alloc_1expr_IIIZI(_3,_19,_4,False,_6)
   _21=(_0.shape_base)
   _22=(_0.ptr_base)
   _23=(_0.nidxs_base)
   _24=(_0.cof_base)
   _25=(_0.codeptr_base)
   _26=(_0.code_base)
   _27=(_0.cconst_base)
   _28=(_0.i32)
   _29=(_0.i64)
   _30=(_0.f64)
   fragments._c_closure_542(_15,_14,_13,_11,_7,_6,_3,_5,_10,_4,_9,_27,_26,_25,_24,_30,_28,_29,_19,_23,_22,_21,_8,_12,_18,_16,_17) # src/fusion/ExprShape.monty:751:8-767:9
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprDense(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprDense
mosek_fusion_ExprDense=__mk_mosek_fusion_ExprDense()
del __mk_mosek_fusion_ExprDense
#BEFORE CLASS
def __mk_mosek_fusion_ExprSymmetrize():
 class ExprSymmetrize(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprSymmetrize__dim1','_ExprSymmetrize__dim0','_ExprSymmetrize__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2(*args): # int32,int32,mosek.fusion.Expression
      self._ctor_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):# int32,int32,mosek.fusion.Expression
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2(*args)
    elif self.__match_ctor_IILmosek_4fusion_4Expression_2I(*args): # int32,int32,mosek.fusion.Expression,int32
      self._ctor_init_IILmosek_4fusion_4Expression_2I(*args)
    elif self.__match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):# int32,int32,mosek.fusion.Expression,int32
      self._ctor_alt_init_IILmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprSymmetrize.ctor(int32,int32,mosek.fusion.Expression)\n\tmosek.fusion.ExprSymmetrize.ctor(int32,int32,mosek.fusion.Expression,int32)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprSymmetrize._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprSymmetrize._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSymmetrize.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprSymmetrize._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprSymmetrize._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprSymmetrize.toString()')
  def __repr__(self): return 'mosek.fusion.ExprSymmetrize'
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_):
    o = ExprSymmetrize.__new__(ExprSymmetrize)
    o._ctor_init_IILmosek_4fusion_4Expression_2I(dim0,dim1,expr,unchecked_)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2I(*args):
    if len(args) != 4: return False
    dim0,dim1,expr,unchecked_, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
    self._ctor_init_IILmosek_4fusion_4Expression_2I(numpy.int32(dim0),numpy.int32(dim1),expr,numpy.int32(unchecked_))
  def _ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0,dim1,expr,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
   if (dim0 < dim1): # src/fusion/ExprShape.monty:170:12-23
    (self.__dim0) = dim0
    (self.__dim1) = dim1
   else:
    (self.__dim0) = dim1
    (self.__dim1) = dim0
  @staticmethod
  def _ctor_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr):
    o = ExprSymmetrize.__new__(ExprSymmetrize)
    o._ctor_init_IILmosek_4fusion_4Expression_2(dim0_,dim1_,expr)
    return o
  @staticmethod
  def __match_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_match_I__(dim0_) and __arg_match_I__(dim1_) and __arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_IILmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    dim0_,dim1_,expr, = args
    return (__arg_alt_match_I__(dim0_) and __arg_alt_match_I__(dim1_) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
    self._ctor_init_IILmosek_4fusion_4Expression_2(numpy.int32(dim0_),numpy.int32(dim1_),expr)
  def _ctor_init_IILmosek_4fusion_4Expression_2(self,dim0_,dim1_,expr):
   mosek_fusion_ExprSymmetrize._ctor_init_IILmosek_4fusion_4Expression_2I(self,dim0_,dim1_,expr,1)
   _0=expr._getShape_()
   if ((self.__dim0 < 0) or ((self.__dim0==self.__dim1) or ((self.__dim1 >= int((_0).shape[0])) or (_0[self.__dim0]!=_0[self.__dim1])))): # src/fusion/ExprShape.monty:161:12-88
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimension definitions")
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_1,_0,_2)
   _1._pop_1expr_()
   _3=0
   _4=(_1.nd)
   _5=(_1.nnz)
   _6=(_1.nelem)
   _7=(_1.ncodeatom)
   _8=(_1.hassp)
   _9=(_1.shape_base)
   _10=(_1.ptr_base)
   _11=(_1.code_base)
   _12=(_1.codeptr_base)
   _13=(_1.cconst_base)
   _14=(_1.nidxs_base)
   _15=(_1.sp_base)
   _16=(_1.cof_base)
   _17=(_1.i32)
   _18=(_1.i64)
   _19=(_1.f64)
   _3 = fragments._c_closure_543(_3,_4,_9,_17) # src/fusion/ExprShape.monty:209:8-212:9
   _3 = numpy.int32(_3) # postprocess
   _20=_2._alloci32_I(_6)
   _21=_2._alloci32_I(_6)
   _22=_2._alloci32_I((_3 + 1))
   _23=_2._alloci64_I(_6)
   _24=(_2.i32)
   _25=(_2.i64)
   _26=0
   _27=0
   _28=0
   _29=numpy.array([1 for _30 in range(0,5)], dtype=numpy.dtype(numpy.int32))
   _31=numpy.zeros((5,), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_544(_29,self.__dim0,_9,_17) # src/fusion/ExprShape.monty:232:8-54
   _29[1] = _17[(_9 + self.__dim0)]
   fragments._c_closure_545(_29,self.__dim0,self.__dim1,_9,_17) # src/fusion/ExprShape.monty:234:8-59
   _29[3] = _17[(_9 + self.__dim1)]
   fragments._c_closure_546(_29,self.__dim1,_4,_9,_17) # src/fusion/ExprShape.monty:236:8-57
   _31[4] = 1
   fragments._c_closure_547(_29,_31) # src/fusion/ExprShape.monty:237:23-81
   if _8: # src/fusion/ExprShape.monty:242:12-17
    _32=_20
    fragments._c_closure_548(_32,_6,_24) # src/fusion/ExprShape.monty:244:32-75
    _33=_21
    _34=numpy.array([1,2,3,0], dtype=numpy.dtype(numpy.int32))
    _32,_33 = fragments._c_closure_549(_32,_29,_6,_34,_15,_31,_33,_18,_24,_22) # src/fusion/ExprShape.monty:252:10-270:11
    _32 = numpy.int32(_32) # postprocess
    _33 = numpy.int32(_33) # postprocess
    fragments._c_closure_550(_29,_6,_15,_31,_18,_25,_23) # src/fusion/ExprShape.monty:278:10-283:74
    _28,_26,_27 = fragments._c_closure_551(_12,_32,_7,_6,_10,_28,_26,_27,_15,_17,_18,_24,_25,_23) # src/fusion/ExprShape.monty:287:10-329:11
    _28 = numpy.int32(_28) # postprocess
    _26 = numpy.int32(_26) # postprocess
    _27 = numpy.int32(_27) # postprocess
    _0._alloc_1expr_IIIZI(_4,_26,_27,True,_28)
    _35=_4
    _36=(_0.ptr_base)
    _37=(_0.nidxs_base)
    _38=(_0.shape_base)
    _39=(_0.sp_base)
    _40=(_0.cof_base)
    _41=(_0.code_base)
    _42=(_0.codeptr_base)
    _43=(_0.cconst_base)
    _44=(_0.i32)
    _45=(_0.i64)
    _46=(_0.f64)
    fragments._c_closure_552(_4,_44,_38,_9,_17) # src/fusion/ExprShape.monty:349:10-61
    _44[_36] = 0
    if (_28 > 0): # src/fusion/ExprShape.monty:352:14-28
     _44[_42] = 0
    _47=0
    _48=0
    _49=0
    _50=0
    _51=0
    _44[_36] = 0
    _48,_49,_51,_50,_47 = fragments._c_closure_553(_13,_11,_48,_12,_16,_32,_49,_51,_50,_6,_14,_47,_10,_43,_41,_42,_40,_46,_44,_45,_28,_37,_36,_39,_15,_19,_17,_18,_24,_25,_23) # src/fusion/ExprShape.monty:357:12-530:13
    _48 = numpy.int32(_48) # postprocess
    _49 = numpy.int32(_49) # postprocess
    _51 = numpy.int32(_51) # postprocess
    _50 = numpy.int32(_50) # postprocess
    _47 = numpy.int32(_47) # postprocess
    if (_47!=_27): # src/fusion/ExprShape.monty:533:16-27
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nzi")
   else:
    _26 = _6
    _27 = (_5 * 2)
    _28 = (((2 * _7) + ((2 * 2) * _5)) if ((_7 > 0) ) else 0)
    _28,_27 = fragments._c_closure_554(_12,_29,_7,_10,_28,_27,_31,_17) # src/fusion/ExprShape.monty:543:10-551:17
    _28 = numpy.int32(_28) # postprocess
    _27 = numpy.int32(_27) # postprocess
    _0._alloc_1expr_IIIZI(_4,_26,_27,False,_28)
    _52=(_0.ptr_base)
    _53=(_0.shape_base)
    _54=(_0.code_base)
    _55=(_0.codeptr_base)
    _56=(_0.nidxs_base)
    _57=(_0.sp_base)
    _58=(_0.cof_base)
    _59=(_0.cconst_base)
    _60=(_0.i32)
    _61=(_0.i64)
    _62=(_0.f64)
    _63=0
    _64=0
    _65=0
    fragments._c_closure_555(_4,_60,_53,_9,_17) # src/fusion/ExprShape.monty:575:10-61
    _60[_52] = 0
    if (_28 > 0): # src/fusion/ExprShape.monty:578:14-28
     _60[_55] = 0
    _66=0
    _65,_66,_63,_64 = fragments._c_closure_556(_13,_11,_65,_12,_16,_29,_66,_14,_63,_10,_59,_54,_55,_58,_64,_62,_60,_61,_28,_56,_52,_31,_19,_17,_18) # src/fusion/ExprShape.monty:581:10-672:19
    _65 = numpy.int32(_65) # postprocess
    _66 = numpy.int32(_66) # postprocess
    _63 = numpy.int32(_63) # postprocess
    _64 = numpy.int32(_64) # postprocess
    if (_63!=_27): # src/fusion/ExprShape.monty:673:14-25
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nnz")
    if (_64!=_26): # src/fusion/ExprShape.monty:674:14-29
     raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid nelem")
   _2._clear_()
   _0._peek_1expr_()
   if ((_0.nnz)!=(_0.i32)[((_0.ptr_base) + (_0.nelem))]): # src/fusion/ExprShape.monty:680:12-50
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
   if ((_0.i32)[(_0.ptr_base)]!=0): # src/fusion/ExprShape.monty:681:12-36
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: Invalid ptr")
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprSymmetrize(symdim=(")._a_I(self.__dim0)._a_S(",")._a_I(self.__dim1)._a_S("),")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprSymmetrize
mosek_fusion_ExprSymmetrize=__mk_mosek_fusion_ExprSymmetrize()
del __mk_mosek_fusion_ExprSymmetrize
#BEFORE CLASS
def __mk_mosek_fusion_ExprCondense():
 class ExprCondense(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprCondense__expr']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      self._ctor_init_Lmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):# mosek.fusion.Expression
      self._ctor_alt_init_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprCondense.ctor(mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprCondense._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprCondense._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCondense.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprCondense._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprCondense._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprCondense.toString()')
  def __repr__(self): return 'mosek.fusion.ExprCondense'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(expr):
    o = ExprCondense.__new__(ExprCondense)
    o._ctor_init_Lmosek_4fusion_4Expression_2(expr)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(expr))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    expr, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(expr))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,expr):
    self._ctor_init_Lmosek_4fusion_4Expression_2(expr)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,expr):
   mosek_fusion_BaseExpression._ctor_init__3I(self,expr._getShape_())
   (self.__expr) = expr
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   self.__expr._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
   _0._peek_1expr_()
   if (_0.hassp): # src/fusion/ExprShape.monty:117:12-20
    _3=_0._popi32_()
    _0._popi32_I(_3)
    _4=_0._popi32_()
    _5=_0._popi32_()
    _0._popi32_()
    _0._popi64_I(_4)
    _0._pushi32_I(0)
    _0._pushi32_I(_5)
    _0._pushi32_I(_4)
    _0._pushi32_I(_4)
    _0._pushi32_I(1)
    _0._peek_1expr_()
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("ExprCondense(")._a_S(self.__expr._toString_())._a_S(")")._toString_())
 return ExprCondense
mosek_fusion_ExprCondense=__mk_mosek_fusion_ExprCondense()
del __mk_mosek_fusion_ExprCondense
#BEFORE CLASS
def __mk_mosek_fusion_ExprFromVar():
 class ExprFromVar(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprFromVar__x']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Variable
      self._ctor_init_Lmosek_4fusion_4Variable_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4Variable_2(*args):# mosek.fusion.Variable
      self._ctor_alt_init_Lmosek_4fusion_4Variable_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprFromVar.ctor(mosek.fusion.Variable)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprFromVar._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprFromVar._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprFromVar.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprFromVar._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprFromVar._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprFromVar.toString()')
  def __repr__(self): return 'mosek.fusion.ExprFromVar'
  @staticmethod
  def _ctor_Lmosek_4fusion_4Variable_2(x):
    o = ExprFromVar.__new__(ExprFromVar)
    o._ctor_init_Lmosek_4fusion_4Variable_2(x)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    x, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(x))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    x, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(x))
  def _ctor_alt_init_Lmosek_4fusion_4Variable_2(self,x):
    self._ctor_init_Lmosek_4fusion_4Variable_2(x)
  def _ctor_init_Lmosek_4fusion_4Variable_2(self,x):
   mosek_fusion_BaseExpression._ctor_init__3I(self,x._getShape_())
   (self.__x) = x
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self._getShape_()
   _4=mosek.fusion.Set._size__3I(_3)
   _5=self.__x._numInst_()
   _6=_5
   _7=(_4 > _5)
   _0._alloc_1expr_IIIZ(int((_3).shape[0]),_5,_6,_7)
   _8=(_0.ptr_base)
   _9=(_0.nidxs_base)
   _10=(_0.sp_base)
   _11=(_0.cof_base)
   _12=(_0.shape_base)
   _13=(_0.i32)
   _14=(_0.i64)
   _15=(_0.f64)
   fragments._c_closure_557(_13,_3,_12) # src/fusion/ExprShape.monty:80:8-66
   fragments._c_closure_558(_11,_5,_6,_8,_15,_13) # src/fusion/ExprShape.monty:82:8-85:9
   if _7: # src/fusion/ExprShape.monty:86:12-17
    self.__x._inst_I_3JI_3J(_10,_14,_9,_14)
   else:
    self.__x._inst_I_3J(_9,_14)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return (mosek.fusion.Utils.StringBuffer()._a_S("Expr(")._a_S(self.__x._toString_())._a_S(")")._toString_())
 return ExprFromVar
mosek_fusion_ExprFromVar=__mk_mosek_fusion_ExprFromVar()
del __mk_mosek_fusion_ExprFromVar
#BEFORE CLASS
def __mk_mosek_fusion_ExprReshape():
 class ExprReshape(mosek_fusion_BaseExpression):
  __slots__ = ['_ExprReshape__e']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3ILmosek_4fusion_4Expression_2(*args): # []int32,mosek.fusion.Expression
      self._ctor_init__3ILmosek_4fusion_4Expression_2(*args)
    elif self.__match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):# []int32,mosek.fusion.Expression
      self._ctor_alt_init__3ILmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.ExprReshape.ctor(array(int32,ndim=1),mosek.fusion.Expression)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_ExprReshape._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_ExprReshape._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprReshape.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_ExprReshape._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_ExprReshape._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.ExprReshape.toString()')
  def __repr__(self): return 'mosek.fusion.ExprReshape'
  @staticmethod
  def _ctor__3ILmosek_4fusion_4Expression_2(shape,e):
    o = ExprReshape.__new__(ExprReshape)
    o._ctor_init__3ILmosek_4fusion_4Expression_2(shape,e)
    return o
  @staticmethod
  def __match_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    shape,e, = args
    return (__arg_match__3I__(shape) and __arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor__3ILmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    shape,e, = args
    return (__arg_alt_match__3I__(shape) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init__3ILmosek_4fusion_4Expression_2(self,shape,e):
    self._ctor_init__3ILmosek_4fusion_4Expression_2(numpy.array(shape,dtype=numpy.dtype(numpy.int32)),e)
  def _ctor_init__3ILmosek_4fusion_4Expression_2(self,shape,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,mosek.fusion.Utils.Tools._arraycopy__3I(shape))
   _0=e._getSize_()
   if (mosek.fusion.Set._size__3I(shape)!=e._getSize_()): # src/fusion/ExprShape.monty:10:12-42
    raise mosek_fusion_LengthError._ctor_S("Cannot reshape to mismatching shape")
   (self.__e) = e
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=self._getShape_()
   self.__e._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
   _0._peek_1expr_()
   _4=_0._popi32_()
   _5=1
   for _6 in range(0,_4):
    _5 *= _0._popi32_()
   if (_5!=self._getSize_()): # src/fusion/ExprShape.monty:36:12-27
    raise mosek_fusion_DimensionError._ctor_S("The two shapes have different sizes")
   for _7 in range(0,int((_3).shape[0])):
    _0._pushi32_I(_3[_7])
   _0._pushi32_I(int((_3).shape[0]))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()._a_S("ExprReshape((")
   if (self._getND_() > 0): # src/fusion/ExprShape.monty:18:12-23
    _0._a_I(self._getDim_I(0))
    for _1 in range(1,self._getND_()):
     _0._a_S(",")._a_I(self._getDim_I(_1))
   _0._a_S("),")._a_S(self.__e._toString_())._a_S(")")
   return (_0._toString_())
 return ExprReshape
mosek_fusion_ExprReshape=__mk_mosek_fusion_ExprReshape()
del __mk_mosek_fusion_ExprReshape
#BEFORE CLASS
def __mk_mosek_fusion_Expr():
 class Expr(mosek_fusion_BaseExpression):
  __slots__ = ['_Expr__inst','_Expr__cof_v','_Expr__subj','_Expr__ptrb','_Expr__bfix','_Expr__shape']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor__3J_3J_3D_3D_3I_3J(*args): # []int64,[]int64,[]double,[]double,[]int32,[]int64
      self._ctor_init__3J_3J_3D_3D_3I_3J(*args)
    elif self.__match_alt_ctor__3J_3J_3D_3D_3I_3J(*args):# []int64,[]int64,[]double,[]double,[]int32,[]int64
      self._ctor_alt_init__3J_3J_3D_3D_3I_3J(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.Expr.ctor(array(int64,ndim=1),array(int64,ndim=1),array(double,ndim=1),array(double,ndim=1),array(int32,ndim=1),array(int64,ndim=1))')
  @staticmethod
  def outer(*args):
    if False: pass
    elif mosek_fusion_Expr._match_outer__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._outer_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_outer_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._outer_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    else:
      raise ValueError('Invalid argument list outer('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.outer(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.outer(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.outer(mosek.fusion.Expression,array(double,ndim=1))')
  @staticmethod
  def constTerm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm__3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3D(*args): # []double
      return mosek_fusion_Expr._constTerm_alt__3D(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_D(*args): # double
      return mosek_fusion_Expr._constTerm_alt_D(*args)
    elif mosek_fusion_Expr._match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm__3_5D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3_5D(*args): # [,]double
      return mosek_fusion_Expr._constTerm_alt__3_5D(*args)
    elif mosek_fusion_Expr._match_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm_ID(*args): # int32,double
      return mosek_fusion_Expr._constTerm_alt_ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3ID(*args): # []int32,double
      return mosek_fusion_Expr._constTerm__3ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3ID(*args): # []int32,double
      return mosek_fusion_Expr._constTerm_alt__3ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3I_3_5ID(*args): # []int32,[,]int32,double
      return mosek_fusion_Expr._constTerm__3I_3_5ID(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3I_3_5ID(*args): # []int32,[,]int32,double
      return mosek_fusion_Expr._constTerm_alt__3I_3_5ID(*args)
    elif mosek_fusion_Expr._match_constTerm__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_Expr._constTerm__3I_3_5I_3D(*args)
    elif mosek_fusion_Expr._match_alt_constTerm__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_Expr._constTerm_alt__3I_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list constTerm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.constTerm(array(double,ndim=1))\n\tmosek.fusion.Expr.constTerm(mosek.fusion.Matrix)\n\tmosek.fusion.Expr.constTerm(double)\n\tmosek.fusion.Expr.constTerm(mosek.fusion.NDSparseArray)\n\tmosek.fusion.Expr.constTerm(array(double,ndim=2))\n\tmosek.fusion.Expr.constTerm(int32,double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),double)\n\tmosek.fusion.Expr.constTerm(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))')
  @staticmethod
  def mulElm(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulElm_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    else:
      raise ValueError('Invalid argument list mulElm('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mulElm(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulElm(mosek.fusion.Expression,mosek.fusion.NDSparseArray)')
  @staticmethod
  def mul(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mul__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mul_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_mul_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._mul_alt_Lmosek_4fusion_4Expression_2D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mul(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mul(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mul(mosek.fusion.Expression,double)')
  @staticmethod
  def hstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list hstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.hstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.hstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.hstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)')
  @staticmethod
  def flatten(*args):
    if False: pass
    elif mosek_fusion_Expr._match_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_flatten_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._flatten_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list flatten('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.flatten(mosek.fusion.Expression)')
  @staticmethod
  def stack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args): # [][]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt__3_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args): # int32,[]mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_I_3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # int32,double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args): # int32,mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # int32,mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args): # int32,double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._stack_alt_IDLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args): # int32,double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_IDDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # int32,mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list stack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.stack(array(array(mosek.fusion.Expression,ndim=1),ndim=1))\n\tmosek.fusion.Expr.stack(int32,array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.stack(int32,double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.stack(int32,mosek.fusion.Expression,double,mosek.fusion.Expression)')
  @staticmethod
  def dot(*args):
    if False: pass
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._dot_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    else:
      raise ValueError('Invalid argument list dot('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.dot(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.dot(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.dot(mosek.fusion.Expression,mosek.fusion.NDSparseArray)')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Expr._match_ones_(*args): # 
      return mosek_fusion_Expr._ones_(*args)
    elif mosek_fusion_Expr._match_alt_ones_(*args): # 
      return mosek_fusion_Expr._ones_alt_(*args)
    elif mosek_fusion_Expr._match_ones__3I(*args): # []int32
      return mosek_fusion_Expr._ones__3I(*args)
    elif mosek_fusion_Expr._match_alt_ones__3I(*args): # []int32
      return mosek_fusion_Expr._ones_alt__3I(*args)
    elif mosek_fusion_Expr._match_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_I(*args)
    elif mosek_fusion_Expr._match_alt_ones_I(*args): # int32
      return mosek_fusion_Expr._ones_alt_I(*args)
    elif mosek_fusion_Expr._match_ones__3I_3_5I(*args): # []int32,[,]int32
      return mosek_fusion_Expr._ones__3I_3_5I(*args)
    elif mosek_fusion_Expr._match_alt_ones__3I_3_5I(*args): # []int32,[,]int32
      return mosek_fusion_Expr._ones_alt__3I_3_5I(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.ones()\n\tmosek.fusion.Expr.ones(array(int32,ndim=1))\n\tmosek.fusion.Expr.ones(int32)\n\tmosek.fusion.Expr.ones(array(int32,ndim=1),array(int32,ndim=2))')
  @staticmethod
  def sum(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_sum_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._sum_alt_Lmosek_4fusion_4Expression_2I(*args)
    else:
      raise ValueError('Invalid argument list sum('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression)\n\tmosek.fusion.Expr.sum(mosek.fusion.Expression,int32)')
  @staticmethod
  def repeat(*args):
    if False: pass
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args): # mosek.fusion.Variable,int32,int32
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Variable_2II(*args)
    elif mosek_fusion_Expr._match_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._repeat_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list repeat('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.repeat(mosek.fusion.Variable,int32,int32)\n\tmosek.fusion.Expr.repeat(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def neg(*args):
    if False: pass
    elif mosek_fusion_Expr._match_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_neg_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._neg_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list neg('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.neg(mosek.fusion.Expression)')
  @staticmethod
  def zeros(*args):
    if False: pass
    elif mosek_fusion_Expr._match_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_I(*args)
    elif mosek_fusion_Expr._match_alt_zeros_I(*args): # int32
      return mosek_fusion_Expr._zeros_alt_I(*args)
    elif mosek_fusion_Expr._match_zeros__3I(*args): # []int32
      return mosek_fusion_Expr._zeros__3I(*args)
    elif mosek_fusion_Expr._match_alt_zeros__3I(*args): # []int32
      return mosek_fusion_Expr._zeros_alt__3I(*args)
    else:
      raise ValueError('Invalid argument list zeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.zeros(int32)\n\tmosek.fusion.Expr.zeros(array(int32,ndim=1))')
  @staticmethod
  def vstack(*args):
    if False: pass
    elif mosek_fusion_Expr._match_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args): # double,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_DLmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,mosek.fusion.Expression,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args): # mosek.fusion.Expression,double,double
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2DD(*args)
    elif mosek_fusion_Expr._match_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args): # double,double,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_DDLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_DDD(*args)
    elif mosek_fusion_Expr._match_alt_vstack_DDD(*args): # double,double,double
      return mosek_fusion_Expr._vstack_alt_DDD(*args)
    elif mosek_fusion_Expr._match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list vstack('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.vstack(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,double,double)\n\tmosek.fusion.Expr.vstack(double,double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.vstack(double,double,double)\n\tmosek.fusion.Expr.vstack(mosek.fusion.Expression,mosek.fusion.Expression,mosek.fusion.Expression)')
  @staticmethod
  def add(*args):
    if False: pass
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Expression_2(*args): # []mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3Lmosek_4fusion_4Variable_2(*args): # []mosek.fusion.Variable
      return mosek_fusion_Expr._add_alt__3Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.add(array(mosek.fusion.Expression,ndim=1))\n\tmosek.fusion.Expr.add(array(mosek.fusion.Variable,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.add(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.add(mosek.fusion.Expression,mosek.fusion.NDSparseArray)')
  @staticmethod
  def reshape(*args):
    if False: pass
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2_3I(*args): # mosek.fusion.Expression,[]int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2_3I(*args): # mosek.fusion.Expression,[]int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2_3I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args): # mosek.fusion.Expression,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2I(*args)
    elif mosek_fusion_Expr._match_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(*args)
    elif mosek_fusion_Expr._match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args): # mosek.fusion.Expression,int32,int32
      return mosek_fusion_Expr._reshape_alt_Lmosek_4fusion_4Expression_2II(*args)
    else:
      raise ValueError('Invalid argument list reshape('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,array(int32,ndim=1))\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32)\n\tmosek.fusion.Expr.reshape(mosek.fusion.Expression,int32,int32)')
  @staticmethod
  def sub(*args):
    if False: pass
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args): # mosek.fusion.Expression,[]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3D(*args)
    elif mosek_fusion_Expr._match_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3DLmosek_4fusion_4Expression_2(*args): # []double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.NDSparseArray,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_DLmosek_4fusion_4Expression_2(*args): # double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._sub_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2D(*args): # mosek.fusion.Expression,double
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2D(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    elif mosek_fusion_Expr._match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args): # mosek.fusion.Expression,mosek.fusion.NDSparseArray
      return mosek_fusion_Expr._sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=1))\n\tmosek.fusion.Expr.sub(array(double,ndim=1),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.NDSparseArray,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(double,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,double)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.sub(mosek.fusion.Expression,mosek.fusion.NDSparseArray)')
  def eval(self,*args):
    if False: pass
    elif mosek_fusion_Expr._match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_Expr._match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack
      return self._eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list eval('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.eval(mosek.fusion.WorkStack,mosek.fusion.WorkStack,mosek.fusion.WorkStack)')
  @staticmethod
  def mulDiag(*args):
    if False: pass
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args): # mosek.fusion.Variable,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Parameter,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Parameter,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args): # mosek.fusion.Matrix,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args): # mosek.fusion.Expression,[,]double
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Matrix,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Parameter,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args): # [,]double,mosek.fusion.Variable
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(*args)
    elif mosek_fusion_Expr._match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args): # [,]double,mosek.fusion.Expression
      return mosek_fusion_Expr._mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Variable,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Variable,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Variable,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args): # mosek.fusion.Expression,mosek.fusion.Parameter
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args)
    elif mosek_fusion_Expr._match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Expr._match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Expression,mosek.fusion.Matrix
      return mosek_fusion_Expr._mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args)
    else:
      raise ValueError('Invalid argument list mulDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Parameter,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,array(double,ndim=2))\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Matrix,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Parameter,mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Variable)\n\tmosek.fusion.Expr.mulDiag(array(double,ndim=2),mosek.fusion.Expression)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Matrix)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Variable,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Parameter)\n\tmosek.fusion.Expr.mulDiag(mosek.fusion.Expression,mosek.fusion.Matrix)')
  @staticmethod
  def transpose(*args):
    if False: pass
    elif mosek_fusion_Expr._match_transpose_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._transpose_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_transpose_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._transpose_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.transpose(mosek.fusion.Expression)')
  @staticmethod
  def condense(*args):
    if False: pass
    elif mosek_fusion_Expr._match_condense_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._condense_Lmosek_4fusion_4Expression_2(*args)
    elif mosek_fusion_Expr._match_alt_condense_Lmosek_4fusion_4Expression_2(*args): # mosek.fusion.Expression
      return mosek_fusion_Expr._condense_alt_Lmosek_4fusion_4Expression_2(*args)
    else:
      raise ValueError('Invalid argument list condense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Expr.condense(mosek.fusion.Expression)')
  def __repr__(self): return 'mosek.fusion.Expr'
  @staticmethod
  def _ctor__3J_3J_3D_3D_3I_3J(ptrb,subj,cof,bfix,shape,inst):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3J_3D_3D_3I_3J(ptrb,subj,cof,bfix,shape,inst)
    return o
  @staticmethod
  def __match_ctor__3J_3J_3D_3D_3I_3J(*args):
    if len(args) != 6: return False
    ptrb,subj,cof,bfix,shape,inst, = args
    return (__arg_match__3J__(ptrb) and __arg_match__3J__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(shape) and __arg_match__3J__(inst))
  @staticmethod
  def __match_alt_ctor__3J_3J_3D_3D_3I_3J(*args):
    if len(args) != 6: return False
    ptrb,subj,cof,bfix,shape,inst, = args
    return (__arg_alt_match__3J__(ptrb) and __arg_alt_match__3J__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(shape) and __arg_alt_match__3J__(inst))
  def _ctor_alt_init__3J_3J_3D_3D_3I_3J(self,ptrb,subj,cof,bfix,shape,inst):
    self._ctor_init__3J_3J_3D_3D_3I_3J(numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int64)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(shape,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)))
  def _ctor_init__3J_3J_3D_3D_3I_3J(self,ptrb,subj,cof,bfix,shape,inst):
   mosek_fusion_Expr._ctor_init__3J_3J_3D_3D_3I_3JI(self,mosek.fusion.Utils.Tools._arraycopy__3J(ptrb),mosek.fusion.Utils.Tools._arraycopy__3J(subj),mosek.fusion.Utils.Tools._arraycopy__3D(cof),mosek.fusion.Utils.Tools._arraycopy__3D(bfix),(mosek.fusion.Utils.Tools._arraycopy__3I(shape) if ((shape is not None) ) else numpy.array([(int((ptrb).shape[0]) - 1)], dtype=numpy.dtype(numpy.int32))),(mosek.fusion.Utils.Tools._arraycopy__3J(inst) if ((inst is not None) ) else None),1)
   _0=(int((ptrb).shape[0]) - 1)
   if (_0 < 0): # src/fusion/Expr.mbi:584:12-21
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb")
   _1=ptrb[_0]
   if ((_1 < 0) or ((_1!=int((cof).shape[0])) or (_1!=int((subj).shape[0])))): # src/fusion/Expr.mbi:587:12-58
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb construction")
   _2=True
   _3=True
   _4=True
   _5=(self.__shape)
   _6=mosek.fusion.Set._size__3I(_5)
   _4,_2,_3 = fragments._c_closure_559(inst,_4,_0,ptrb,_2,_3,_6,_5) # src/fusion/Expr.mbi:595:8-602:9
   if (not _3): # src/fusion/Expr.mbi:603:12-24
    raise mosek_fusion_ExpressionError._ctor_S("Invalid shape")
   if (not _2): # src/fusion/Expr.mbi:605:12-23
    raise mosek_fusion_ExpressionError._ctor_S("Invalid ptrb")
   if (not _4): # src/fusion/Expr.mbi:607:12-23
    raise mosek_fusion_ExpressionError._ctor_S("Invalid sparsity pattern")
  @staticmethod
  def _ctor__3J_3J_3D_3D_3I_3JI(ptrb,subj,cof,bfix,shp,inst,unchecked_):
    o = Expr.__new__(Expr)
    o._ctor_init__3J_3J_3D_3D_3I_3JI(ptrb,subj,cof,bfix,shp,inst,unchecked_)
    return o
  @staticmethod
  def __match_ctor__3J_3J_3D_3D_3I_3JI(*args):
    if len(args) != 7: return False
    ptrb,subj,cof,bfix,shp,inst,unchecked_, = args
    return (__arg_match__3J__(ptrb) and __arg_match__3J__(subj) and __arg_match__3D__(cof) and __arg_match__3D__(bfix) and __arg_match__3I__(shp) and __arg_match__3J__(inst) and __arg_match_I__(unchecked_))
  @staticmethod
  def __match_alt_ctor__3J_3J_3D_3D_3I_3JI(*args):
    if len(args) != 7: return False
    ptrb,subj,cof,bfix,shp,inst,unchecked_, = args
    return (__arg_alt_match__3J__(ptrb) and __arg_alt_match__3J__(subj) and __arg_alt_match__3D__(cof) and __arg_alt_match__3D__(bfix) and __arg_alt_match__3I__(shp) and __arg_alt_match__3J__(inst) and __arg_alt_match_I__(unchecked_))
  def _ctor_alt_init__3J_3J_3D_3D_3I_3JI(self,ptrb,subj,cof,bfix,shp,inst,unchecked_):
    self._ctor_init__3J_3J_3D_3D_3I_3JI(numpy.array(ptrb,dtype=numpy.dtype(numpy.int64)),numpy.array(subj,dtype=numpy.dtype(numpy.int64)),numpy.array(cof,dtype=numpy.dtype(numpy.float64)),numpy.array(bfix,dtype=numpy.dtype(numpy.float64)),numpy.array(shp,dtype=numpy.dtype(numpy.int32)),numpy.array(inst,dtype=numpy.dtype(numpy.int64)),numpy.int32(unchecked_))
  def _ctor_init__3J_3J_3D_3D_3I_3JI(self,ptrb,subj,cof,bfix,shp,inst,unchecked_):
   mosek_fusion_BaseExpression._ctor_init__3I(self,shp)
   (self.__shape) = shp
   (self.__ptrb) = ptrb
   (self.__subj) = subj
   (self.__cof_v) = cof
   (self.__bfix) = bfix
   (self.__inst) = inst
   if ((self.__shape) is None): # src/fusion/Expr.mbi:522:12-30
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: NULL shape")
  @staticmethod
  def _ctor_Lmosek_4fusion_4Expression_2(e):
    o = Expr.__new__(Expr)
    o._ctor_init_Lmosek_4fusion_4Expression_2(e)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(e))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    e, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(e))
  def _ctor_alt_init_Lmosek_4fusion_4Expression_2(self,e):
    self._ctor_init_Lmosek_4fusion_4Expression_2(e)
  def _ctor_init_Lmosek_4fusion_4Expression_2(self,e):
   mosek_fusion_BaseExpression._ctor_init__3I(self,e._getShape_())
   _1=e
   if   isinstance(_1,mosek_fusion_Expr):
    ee=_1
    self.__shape = (ee.__shape)
    self.__ptrb = (ee.__ptrb)
    self.__subj = (ee.__subj)
    self.__cof_v = (ee.__cof_v)
    self.__bfix = (ee.__bfix)
    self.__inst = (ee.__inst)
   else:
    ee=_1
    _1=mosek_fusion_WorkStack._ctor_()
    _2=mosek_fusion_WorkStack._ctor_()
    _3=mosek_fusion_WorkStack._ctor_()
    ee._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_3,_2,_1)
    _4=_3._popi32_()
    _5=_3._popi32_I(_4)
    _6=_3._popi32_()
    _7=_3._popi32_()
    _8=(_3._popi32_()!=0)
    _9=_3._popi32_I((_6 + 1))
    _10=(_3._popi64_I(_6) if (_8 ) else 0)
    _11=_3._popi64_I(_7)
    _12=_3._popf64_I(_6)
    _13=_3._popf64_I(_7)
    _14=(_3.i32)
    _15=(_3.i64)
    _16=(_3.f64)
    self.__shape = numpy.array([_14[(_5 + _17)] for _17 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
    self.__ptrb = numpy.array([_14[(_9 + _18)] for _18 in range(0,(_6 + 1))], dtype=numpy.dtype(numpy.int64))
    self.__subj = numpy.array([_15[(_11 + _19)] for _19 in range(0,_7)], dtype=numpy.dtype(numpy.int64))
    self.__cof_v = numpy.array([_16[(_13 + _20)] for _20 in range(0,_7)], dtype=numpy.dtype(numpy.float64))
    self.__bfix = numpy.array([_16[(_12 + _21)] for _21 in range(0,_7)], dtype=numpy.dtype(numpy.float64))
    self.__inst = (numpy.array([_15[(_10 + _22)] for _22 in range(0,_7)], dtype=numpy.dtype(numpy.int64)) if (_8 ) else None)
   if (self.__shape is None): # src/fusion/Expr.mbi:424:12-25
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: NULL shape")
  def __prod_alt__3I(self,_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = self.__prod__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def __prod__3I(self,_0):
   _1=1
   _1 = fragments._c_closure_560(_1,_0) # src/fusion/Expr.mbi:1707:58-98
   _1 = numpy.int32(_1) # postprocess
   return numpy.int32(_1)
  @staticmethod
  def __varstack_alt__3_3Lmosek_4fusion_4Variable_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3_3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3_3Lmosek_4fusion_4Variable_2(_0):
   return (numpy.array([_0[_1][_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0[_1]).shape[0]))], dtype=numpy.dtype(object)))
  @staticmethod
  def __varstack_alt__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __varstack__3Lmosek_4fusion_4Variable_2_3Lmosek_4fusion_4Variable_2(_0,_1):
   if (_0 is None): # src/fusion/Expr.mbi:1691:12-22
    return (_1)
   elif (_1 is None): # src/fusion/Expr.mbi:1692:16-26
    return (_0)
   else:
    _2=numpy.ndarray(((int((_0).shape[0]) + int((_1).shape[0])),), dtype=numpy.dtype(object))
    for _3 in range(0,int((_0).shape[0])):
     _2[_3] = _0[_3]
    for _4 in range(0,int((_1).shape[0])):
     _2[(_4 + int((_0).shape[0]))] = _1[_4]
    return (_2)
  @staticmethod
  def _match_condense_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_condense_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _condense_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._condense_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _condense_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprCondense._ctor_Lmosek_4fusion_4Expression_2(_0))
  @staticmethod
  def _match_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_flatten_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _flatten_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._flatten_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _flatten_Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None): # src/fusion/Expr.mbi:1675:12-21
    raise ValueError("Arguments for flatten may not be null")
   _1=_0._getSize_()
   if (not (_1 <= 2147483647)): # src/fusion/Expr.mbi:1677:12-34
    raise mosek_fusion_LengthError._ctor_S("Maximum dimension size exceeded")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_0 is None): # src/fusion/Expr.mbi:1666:12-21
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,mosek.fusion.Set._make_II(_1,_2)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2I(_0,_1):
   if (_0 is None): # src/fusion/Expr.mbi:1656:12-21
    raise ValueError("Arguments for reshape may not be null")
   return (mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,mosek.fusion.Set._make_I(_1)))
  @staticmethod
  def _match_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3I__(_1))
  @staticmethod
  def _match_alt_reshape_Lmosek_4fusion_4Expression_2_3I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3I__(_1))
  @staticmethod
  def _reshape_alt_Lmosek_4fusion_4Expression_2_3I(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _reshape_Lmosek_4fusion_4Expression_2_3I(_0,_1):
   return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_zeros__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_zeros__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _zeros_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._zeros__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _zeros__3I(_0):
   return (mosek.fusion.Expr._constTerm__3ID(_0,0))
  @staticmethod
  def _match_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_zeros_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _zeros_alt_I(_t__0):
    return mosek_fusion_Expr._zeros_I(numpy.int32(__0))
  @staticmethod
  def _zeros_I(_0):
   return (mosek.fusion.Expr._constTerm_ID(_0,0))
  @staticmethod
  def _match_ones_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_ones_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _ones_alt_():
    return mosek_fusion_Expr._ones_()
  @staticmethod
  def _ones_():
   return (mosek.fusion.Expr._constTerm_D(1))
  @staticmethod
  def _match_ones__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1))
  @staticmethod
  def _match_alt_ones__3I_3_5I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1))
  @staticmethod
  def _ones_alt__3I_3_5I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._ones__3I_3_5I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ones__3I_3_5I(_0,_1):
   return (mosek.fusion.Expr._constTerm__3I_3_5ID(_0,_1,1))
  @staticmethod
  def _match_ones__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3I__(_0))
  @staticmethod
  def _match_alt_ones__3I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3I__(_0))
  @staticmethod
  def _ones_alt__3I(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1 = mosek_fusion_Expr._ones__3I(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _ones__3I(_0):
   return (mosek.fusion.Expr._constTerm__3ID(_0,1))
  @staticmethod
  def _match_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ones_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _ones_alt_I(_t__0):
    return mosek_fusion_Expr._ones_I(numpy.int32(__0))
  @staticmethod
  def _ones_I(_0):
   return (mosek.fusion.Expr._constTerm_ID(_0,1))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4NDSparseArray_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4NDSparseArray_2(_0):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D((_0._dims),(_0._inst),(_0._cof)))
  @staticmethod
  def _match_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_constTerm_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _constTerm_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _constTerm_Lmosek_4fusion_4Matrix_2(_0):
   _1=_0._numRows_()
   _2=_0._numColumns_()
   _3=mosek.fusion.Set._make_II(_1,_2)
   if _0._isSparse_(): # src/fusion/Expr.mbi:1613:12-24
    _4=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
    _5=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
    _0._getDataAsTriplets__3I_3I_3D(_6,_5,_4)
    _7=numpy.array([((_6[_8] * _2) + _5[_8]) for _8 in range(0,int((_5).shape[0]))], dtype=numpy.dtype(numpy.int64))
    return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_3,_7,_4))
   else:
    return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_3,None,_0._getDataAsArray_()))
  @staticmethod
  def _match_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_constTerm_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  @staticmethod
  def _constTerm_alt_D(_t__0):
    return mosek_fusion_Expr._constTerm_D(numpy.float64(__0))
  @staticmethod
  def _constTerm_D(_0):
   return (mosek_fusion_ExprConst._ctor__3I_3JD(numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),None,_0))
  @staticmethod
  def _match_constTerm__3I_3_5ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_constTerm__3I_3_5ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _constTerm_alt__3I_3_5ID(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.float64(_t__2)
   _1 = mosek_fusion_Expr._constTerm__3I_3_5ID(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3I_3_5ID(_0,_1,_2):
   _3=int((_1).shape[0])
   _4=int((_0).shape[0])
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _6[(_4 - 1)] = 1
   fragments._c_closure_561(_4,_6,_0) # src/fusion/Expr.mbi:1594:43-93
   fragments._c_closure_562(_3,_4,_6,_5,_1) # src/fusion/Expr.mbi:1595:8-1597:42
   return (mosek_fusion_ExprConst._ctor__3I_3JD(_0,_5,_2))
  @staticmethod
  def _match_constTerm__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_constTerm__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _constTerm_alt__3I_3_5I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3I_3_5I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3I_3_5I_3D(_0,_1,_2):
   _3=int((_1).shape[0])
   _4=int((_0).shape[0])
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
   _6=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
   _6[(_4 - 1)] = 1
   fragments._c_closure_563(_4,_6,_0) # src/fusion/Expr.mbi:1583:43-93
   fragments._c_closure_564(_3,_4,_6,_5,_1) # src/fusion/Expr.mbi:1584:8-1586:42
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(_0,_5,_2))
  @staticmethod
  def _match_constTerm__3ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm__3ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt__3ID(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.float64(_t__1)
   _1 = mosek_fusion_Expr._constTerm__3ID(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3ID(_0,_1):
   return (mosek_fusion_ExprConst._ctor__3I_3JD(_0,None,_1))
  @staticmethod
  def _match_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_constTerm_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _constTerm_alt_ID(_t__0,_t__1):
    return mosek_fusion_Expr._constTerm_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _constTerm_ID(_0,_1):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([_0], dtype=numpy.dtype(numpy.int32)),None,numpy.array([_1 for _2 in range(0,_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_constTerm__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _constTerm_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3_5D(_0)
   return _1
  @staticmethod
  def _constTerm__3_5D(_0):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([int((_0).shape[0]),int((_0).shape[1])], dtype=numpy.dtype(numpy.int32)),None,numpy.array([_0[_1,_2] for _1 in range(0,int((_0).shape[0])) for _2 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_constTerm__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _constTerm_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._constTerm__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _constTerm__3D(_0):
   return (mosek_fusion_ExprConst._ctor__3I_3J_3D(numpy.array([int((_0).shape[0])], dtype=numpy.dtype(numpy.int32)),None,_0))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2I(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2I(_0,numpy.int32(__1))
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2I(_0,_1):
   return (mosek_fusion_ExprSumReduce._ctor_ILmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_sum_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _sum_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._sum_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _sum_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprSumReduce._ctor_ILmosek_4fusion_4Expression_2(0,mosek.fusion.Expr._flatten_Lmosek_4fusion_4Expression_2(_0)))
  @staticmethod
  def _match_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_neg_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _neg_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._neg_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _neg_Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2((- 1),_0))
  @staticmethod
  def __mulDiag_alt_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def __mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   _3=_1._numNonzeros_()
   _4=_1._numRows_()
   _5=_1._numColumns_()
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _1._getDataAsTriplets__3I_3I_3D(_8,_7,_6)
   if _0: # src/fusion/Expr.mbi:1533:12-16
    return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_4,_5,_8,_7,_6,_2))
   else:
    return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_4,_5,_8,_7,_6,_2))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek_fusion_ExprMulParamDiagRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0._asExpr_(),_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek_fusion_ExprMulParamDiagLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek_fusion_ExprMulParamDiagRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprMulParamDiagLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulDiag_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Variable_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Variable_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Variable_2_3_5D(_0,_1):
   return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_1).shape[0]),int((_1).shape[1]),numpy.array([_2 for _2 in range(0,int((_1).shape[0])) for _3 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_1).shape[0])) for _5 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_1[_6,_7] for _6 in range(0,int((_1).shape[0])) for _7 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),_0._asExpr_()))
  @staticmethod
  def _match_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulDiag_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulDiag_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulDiag_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek_fusion_ExprMulDiagRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_1).shape[0]),int((_1).shape[1]),numpy.array([_2 for _2 in range(0,int((_1).shape[0])) for _3 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_1).shape[0])) for _5 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_1[_6,_7] for _6 in range(0,int((_1).shape[0])) for _7 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64)),_0))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Variable_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Variable_2(_0,_1):
   return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_0).shape[0]),int((_0).shape[1]),numpy.array([_2 for _2 in range(0,int((_0).shape[0])) for _3 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_0).shape[0])) for _5 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_6,_7] for _6 in range(0,int((_0).shape[0])) for _7 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),_1._asExpr_()))
  @staticmethod
  def _match_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulDiag__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulDiag_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulDiag__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprMulDiagLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(int((_0).shape[0]),int((_0).shape[1]),numpy.array([_2 for _2 in range(0,int((_0).shape[0])) for _3 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_5 for _4 in range(0,int((_0).shape[0])) for _5 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_6,_7] for _6 in range(0,int((_0).shape[0])) for _7 in range(0,int((_0).shape[1]))], dtype=numpy.dtype(numpy.float64)),_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   _2=_1._getShape_()
   _3=_1
   if (int((_2).shape[0])==1): # src/fusion/Expr.mbi:1489:12-28
    _2 = numpy.array([_2[0],1], dtype=numpy.dtype(numpy.int32))
    _3 = mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_2,_1)
   if ((int((_2).shape[0])!=2) or ((_0._numRows_()!=_2[0]) or (_0._numColumns_()!=_2[1]))): # src/fusion/Expr.mbi:1493:12-1495:39
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   _4=_0._numColumns_()
   _5=_0._numNonzeros_()
   _6=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_6,_7,_8)
   return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2I(_8,numpy.array([((_6[_9] * _4) + _7[_9]) for _9 in range(0,_5)], dtype=numpy.dtype(numpy.int64)),_3,1))
  @staticmethod
  def __mulElm_1_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)): # src/fusion/Expr.mbi:1474:12-37
    raise ValueError("Arguments for mulElm may not be null")
   if ((_1._getND_()==0) and (int((_0).shape[0])==1)): # src/fusion/Expr.mbi:1476:12-45
    return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_0[0],_1))
   elif ((_1._getND_()!=1) or (_1._getDim_I(0)!=int((_0).shape[0]))): # src/fusion/Expr.mbi:1478:16-1479:40
    raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   else:
    return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2(_0,numpy.array([_2 for _2 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.int64)),_1))
  @staticmethod
  def __mulElm_1_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def __mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0 is None) or (_1 is None)): # src/fusion/Expr.mbi:1461:12-39
    raise ValueError("Arguments for mulElm may not be null")
   _2=_1._getShape_()
   if (int((_2).shape[0])!=int(((_0._dims)).shape[0])): # src/fusion/Expr.mbi:1463:12-40
    raise mosek_fusion_LengthError._ctor_S("Dimension mismatch")
   for _3 in range(0,int(((_0._dims)).shape[0])):
    if ((_0._dims)[_3]!=_2[_3]): # src/fusion/Expr.mbi:1466:14-38
     raise mosek_fusion_DimensionError._ctor_S("Dimensions of operands do not match")
   return (mosek_fusion_ExprMulElement._ctor__3D_3JLmosek_4fusion_4Expression_2((_0._cof),(_0._inst),_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _mul_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprMulScalarConst._ctor_DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   return (mosek.fusion.Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mul__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mul__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mul__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(False,_1,_0))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(True,_0,_1))
  @staticmethod
  def __mul_alt_Z_3DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = mosek_fusion_Expr.__mul_Z_3DLmosek_4fusion_4Expression_2(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_Z_3DLmosek_4fusion_4Expression_2(_0,_1,_2):
   _3=int((_1).shape[0])
   _4=_3
   _5=mosek.fusion.Utils.Tools._arraycopy__3D(_1)
   _6=_2._getND_()
   if (_6==0): # src/fusion/Expr.mbi:1435:12-19
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_3], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,1,numpy.array([_7 for _7 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _8 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1)))
   elif (_6!=2): # src/fusion/Expr.mbi:1437:16-23
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions")
   elif (_0 and (_2._getDim_I(0)==int((_1).shape[0]))): # src/fusion/Expr.mbi:1439:21-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_2._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(1,_3,numpy.array([0 for _9 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([_10 for _10 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2)))
   elif (_0 and (_2._getDim_I(0)==1)): # src/fusion/Expr.mbi:1441:17-42
    return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,1,numpy.array([_11 for _11 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _12 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1))
   elif ((not _0) and (_2._getDim_I(1)==_3)): # src/fusion/Expr.mbi:1443:17-50
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_2._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,1,numpy.array([_13 for _13 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([0 for _14 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2)))
   elif ((not _0) and (_2._getDim_I(1)==1)): # src/fusion/Expr.mbi:1445:17-46
    return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(1,_3,numpy.array([0 for _15 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),numpy.array([_16 for _16 in range(0,_3)], dtype=numpy.dtype(numpy.int32)),_5,_2,1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def __mul_alt_Z_3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _2=_t__2
   _1 = mosek_fusion_Expr.__mul_Z_3_5DLmosek_4fusion_4Expression_2(_0,_1,_2)
   return _1
  @staticmethod
  def __mul_Z_3_5DLmosek_4fusion_4Expression_2(_0,_1,_2):
   _3=int((_1).shape[0])
   _4=int((_1).shape[1])
   _5=(_3 * _4)
   _6=numpy.array([_7 for _7 in range(0,_3) for _8 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
   _9=numpy.array([_11 for _10 in range(0,_3) for _11 in range(0,_4)], dtype=numpy.dtype(numpy.int32))
   _12=numpy.array([_1[_13,_14] for _13 in range(0,_3) for _14 in range(0,_4)], dtype=numpy.dtype(numpy.float64))
   _15=_2._getSize_()
   _16=_2._getShape_()
   if (int((_16).shape[0])==0): # src/fusion/Expr.mbi:1409:12-28
    return (mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2I(_3,_4,_6,_9,_12,_2,1))
   elif _0: # src/fusion/Expr.mbi:1411:16-20
    if (int((_16).shape[0])==1): # src/fusion/Expr.mbi:1412:14-30
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([int((_1).shape[0])], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_16[0],1], dtype=numpy.dtype(numpy.int32)),_2))))
    elif (int((_16).shape[0])==2): # src/fusion/Expr.mbi:1414:18-34
     return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,_2))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
   else:
    if (int((_16).shape[0])==1): # src/fusion/Expr.mbi:1420:14-30
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([int((_1).shape[1])], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_16[0]], dtype=numpy.dtype(numpy.int32)),_2))))
    elif (int((_16).shape[0])==2): # src/fusion/Expr.mbi:1422:18-34
     return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_3,_4,_6,_9,_12,_2))
    else:
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
  @staticmethod
  def __mul_alt_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr.__mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def __mul_ZLmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   _3=_1._numNonzeros_()
   _4=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _7=_1._numRows_()
   _8=_1._numColumns_()
   _1._getDataAsTriplets__3I_3I_3D(_4,_5,_6)
   _9=_2._getND_()
   if (_9==0): # src/fusion/Expr.mbi:1379:12-19
    return (mosek_fusion_ExprScalarMul._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
   elif (_9==1): # src/fusion/Expr.mbi:1381:16-23
    _10=_2._getShape_()
    if _0: # src/fusion/Expr.mbi:1383:14-18
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_7], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_10[0],1], dtype=numpy.dtype(numpy.int32)),_2))))
    else:
     return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_8], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_10[0]], dtype=numpy.dtype(numpy.int32)),_2))))
   elif (_9==2): # src/fusion/Expr.mbi:1388:16-23
    if _0: # src/fusion/Expr.mbi:1389:14-18
     return (mosek_fusion_ExprMulLeft._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
    else:
     return (mosek_fusion_ExprMulRight._ctor_II_3I_3I_3DLmosek_4fusion_4Expression_2(_7,_8,_4,_5,_6,_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions for multiplication")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Variable_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_1._numRows_()
   _3=_1._numColumns_()
   _4=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_1._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _1._getDataAsTriplets__3I_3I_3D(_6,_5,_4)
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(False,_2,_3,_6,_5,_4,_0))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Variable_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Variable_2(_0,_1):
   _2=_0._numRows_()
   _3=_0._numColumns_()
   _4=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _5=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _0._getDataAsTriplets__3I_3I_3D(_6,_5,_4)
   return (mosek.fusion.Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(True,_2,_3,_6,_5,_4,_1))
  @staticmethod
  def __mul_alt_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.int32(_t__2)
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.float64))
   _6=_t__6
   _1 = mosek_fusion_Expr.__mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6)
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __mul_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6):
   if (_6._getND_()==0): # src/fusion/Expr.mbi:1334:12-26
    return (mosek_fusion_ExprMulScalarVar._ctor_II_3I_3I_3DLmosek_4fusion_4Variable_2(_1,_2,_3,_4,_5,_6))
   elif (_6._getND_()==1): # src/fusion/Expr.mbi:1336:16-30
    _7=_6._getShape_()
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([(_1 if (_0 ) else _2)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulVar._ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,mosek.fusion.Var._reshape_Lmosek_4fusion_4Variable_2_3I(_6,(numpy.array([_7[0],1], dtype=numpy.dtype(numpy.int32)) if (_0 ) else numpy.array([1,_7[0]], dtype=numpy.dtype(numpy.int32)))))))
   else:
    return (mosek_fusion_ExprMulVar._ctor_ZII_3I_3I_3DLmosek_4fusion_4Variable_2(_0,_1,_2,_3,_4,_5,_6))
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   if ((_1._getND_()==2) and (_0._getND_()==2)): # src/fusion/Expr.mbi:1319:16-52
    return (mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1))
   elif ((_1._getND_()==1) and (_0._getND_()==2)): # src/fusion/Expr.mbi:1321:16-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1._reshape__3I(numpy.array([_1._getDim_I(0),1], dtype=numpy.dtype(numpy.int32))))))
   elif ((_1._getND_()==2) and (_0._getND_()==1)): # src/fusion/Expr.mbi:1323:16-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_1._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamRight._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),_0),_1)))
   elif (_1._getND_()==0): # src/fusion/Expr.mbi:1325:16-30
    return (mosek_fusion_ExprMulParamScalar._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_1,_0))
   elif (_0._getND_()==0): # src/fusion/Expr.mbi:1327:16-33
    return (mosek_fusion_ExprMulParamScalarExpr._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_1,_0))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mul_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   if ((_0._getND_()==2) and (_1._getND_()==2)): # src/fusion/Expr.mbi:1305:16-52
    return (mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
   elif ((_0._getND_()==1) and (_1._getND_()==2)): # src/fusion/Expr.mbi:1307:16-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_1._getDim_I(1)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0._reshape__3I(numpy.array([1,_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32))),_1)))
   elif ((_0._getND_()==2) and (_1._getND_()==1)): # src/fusion/Expr.mbi:1309:16-52
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),mosek_fusion_ExprMulParamLeft._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([_1._getDim_I(0),1], dtype=numpy.dtype(numpy.int32)),_1))))
   elif (_0._getND_()==0): # src/fusion/Expr.mbi:1311:16-30
    return (mosek_fusion_ExprMulParamScalar._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
   elif (_1._getND_()==0): # src/fusion/Expr.mbi:1313:16-33
    return (mosek_fusion_ExprMulParamScalarExpr._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Invalid operand dimensions for multiplication")
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_1._numNonzeros_()
   if (not _1._isSparse_()): # src/fusion/Expr.mbi:1291:12-28
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([_3 for _3 in range(0,_2)], dtype=numpy.dtype(numpy.int64)),_1._getDataAsArray_()))
   else:
    _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _5=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
    _7=_1._numColumns_()
    _1._getDataAsTriplets__3I_3I_3D(_4,_5,_6)
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([((_4[_8] * _7) + _5[_8]) for _8 in range(0,int((_4).shape[0]))], dtype=numpy.dtype(numpy.int64)),_6))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,numpy.array([_2 for _2 in range(0,(int((_1).shape[0]) * int((_1).shape[1])))], dtype=numpy.dtype(numpy.int64)),numpy.array([_1[_3,_4] for _3 in range(0,int((_1).shape[0])) for _4 in range(0,int((_1).shape[1]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3J_3D(_0,(_1._inst),(_1._cof)))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   _2=_0._getShape_()
   if ((_0._getSize_()==int((_1).shape[0])) and (int((_2).shape[0]) > 1)): # src/fusion/Expr.mbi:1273:12-54
    _3=0
    _3 = fragments._c_closure_565(_2,_3) # src/fusion/Expr.mbi:1274:29-89
    _3 = numpy.int32(_3) # postprocess
    if (_3 > 1): # src/fusion/Expr.mbi:1275:14-27
     raise mosek_fusion_DimensionError._ctor_S("Mismatching operand shapes")
    else:
     _4=numpy.array([numpy.int32(_0._getSize_())], dtype=numpy.dtype(numpy.int32))
     return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3D(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_4,_0),_1))
   else:
    return (mosek_fusion_ExprInner._ctor_Lmosek_4fusion_4Expression_2_3D(_0,_1))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_1,_0))
  @staticmethod
  def _match_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _dot__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2_3_5D(_1,_0))
  @staticmethod
  def _match_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._dot__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dot__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr._dot_Lmosek_4fusion_4Expression_2_3D(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek_fusion_ExprDotParam._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _dot_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _dot_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprDotParam._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   _2=_1._getShape_()
   if (not ((int((_2).shape[0])==1) or ((int((_2).shape[0])==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1252:13-1253:59
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   _3=_0._getShape_()
   if (not ((_0._getND_()==1) or ((_0._getND_()==2) and (_3[1]==1)))): # src/fusion/Expr.mbi:1256:13-1257:57
    raise mosek_fusion_DimensionError._ctor_S("Parameter argument must be one-dimensional")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0._reshape__3I(numpy.array([_3[0],1], dtype=numpy.dtype(numpy.int32))),mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_1,1,_2[0])))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   _2=_0._getShape_()
   if (not ((_0._getND_()==1) or ((_0._getND_()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1238:13-1239:56
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   _3=_1._getShape_()
   if (not ((_1._getND_()==1) or ((_1._getND_()==2) and (_3[1]==1)))): # src/fusion/Expr.mbi:1242:13-1243:57
    raise mosek_fusion_DimensionError._ctor_S("Parameter argument must be one-dimensional")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_0,_2[0],1),_1._reshape__3I(numpy.array([1,_3[0]], dtype=numpy.dtype(numpy.int32)))))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   _2=_1._getShape_()
   if (not ((int((_2).shape[0])==1) or ((int((_2).shape[0])==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1226:13-1227:59
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   if ((_0._dimj)!=1): # src/fusion/Expr.mbi:1229:12-23
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_1,1,_2[0])))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   _2=_0._getShape_()
   if (not ((_0._getND_()==1) or ((_0._getND_()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1214:13-1215:56
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   if ((_1._dimj)!=1): # src/fusion/Expr.mbi:1217:12-23
    raise mosek_fusion_DimensionError._ctor_S("Constant matrix must be a column-vector")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_0,_2[0],1),_1._transpose_()))
  @staticmethod
  def _match_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_outer__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _outer_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._outer__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer__3DLmosek_4fusion_4Expression_2(_0,_1):
   _2=_1._getShape_()
   if (not ((_1._getND_()==1) or ((_1._getND_()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1204:13-1205:57
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense_II_3D(int((_0).shape[0]),1,_0),mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_1,1,_2[0])))
  @staticmethod
  def _match_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_outer_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _outer_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._outer_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _outer_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   _2=_0._getShape_()
   if (not ((_0._getND_()==1) or ((_0._getND_()==2) and (_2[1]==1)))): # src/fusion/Expr.mbi:1194:13-1195:56
    raise mosek_fusion_DimensionError._ctor_S("Expression argument must be one-dimensional")
   return (mosek.fusion.Expr._mul_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2II(_0,_2[0],1),mosek.fusion.Matrix._dense_II_3D(1,int((_1).shape[0]),_1)))
  @staticmethod
  def __outer_1_alt_I_3J_3J_3D_3D_3J_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5,_t__6,_t__7,_t__8,_t__9):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _6=numpy.array(_t__6,dtype=numpy.dtype(numpy.float64))
   _7=numpy.array(_t__7,dtype=numpy.dtype(numpy.int32))
   _8=numpy.int32(_t__8)
   _9=_t__9
   _1 = mosek_fusion_Expr.__outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__6[:] = _6
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__7[:] = _7
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_I_3J_3J_3D_3D_3J_3D_3IIZ(_0,_1,_2,_3,_4,_5,_6,_7,_8,_9):
   _10=(mosek.fusion.Set._make_II(_0,_8) if ((not _9) ) else mosek.fusion.Set._make_II(_8,_0))
   _11=(int((_6).shape[0]) * int((_5).shape[0]))
   _12=(int((_6).shape[0]) * int((_2).shape[0]))
   _13=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
   _14=(numpy.zeros((_11,), dtype=numpy.dtype(numpy.float64)) if ((_4 is not None) ) else None)
   _15=numpy.zeros((_12,), dtype=numpy.dtype(numpy.float64))
   _16=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _17=numpy.zeros(((_11 + 1),), dtype=numpy.dtype(numpy.int64))
   _18=numpy.int32(_17[(int((_17).shape[0]) - 1)])
   if (not _9): # src/fusion/Expr.mbi:1119:12-25
    fragments._c_closure_566(_6,_14,_15,_8,_4,_3,_5,_1,_2,_17,_7,_16) # src/fusion/Expr.mbi:1120:8-1152:9
   else:
    _19=0
    _20=0
    for _21 in range(0,int((_6).shape[0])):
     _22=_6[_21]
     mosek.fusion.Utils.Tools._arraycopy__3JJ_3JJJ(_2,0,_16,_20,_18)
     fragments._c_closure_567(_6,_15,_3,_18,_21,_20) # src/fusion/Expr.mbi:1161:12-62
     _19 = fragments._c_closure_568(_8,_5,_1,_21,_19,_17,_7) # src/fusion/Expr.mbi:1163:12-1170:13
     _19 = numpy.int64(_19) # postprocess
     _20 += _18
    fragments._c_closure_569(_6,_14,_4,_5) # src/fusion/Expr.mbi:1174:10-1185:11
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3J(_17,_16,_15,_14,_10,_13))
  @staticmethod
  def __outer_1_alt_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=_t__0
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.int32(_t__4)
   _5=_t__5
   _1 = mosek_fusion_Expr.__outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __outer_1_Lmosek_4fusion_4Variable_2I_3D_3IIZ(_0,_1,_2,_3,_4,_5):
   _6=(mosek.fusion.Set._make_II(_1,_4) if ((not _5) ) else mosek.fusion.Set._make_II(_4,_1))
   _7=(None if ((_4==int((_2).shape[0])) ) else numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64)))
   _8=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.float64))
   _9=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.float64))
   _10=numpy.zeros(((int((_2).shape[0]) * _1),), dtype=numpy.dtype(numpy.int64))
   _11=numpy.zeros((((int((_2).shape[0]) * _1) + 1),), dtype=numpy.dtype(numpy.int64))
   fragments._c_closure_570(_2,_9,_4,_7,_11,_3,_10,_5,_1) # src/fusion/Expr.mbi:1025:8-1078:9
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3J(_11,_10,_9,_8,_6,_7))
  @staticmethod
  def _match_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_stack__3_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _stack_alt__3_3Lmosek_4fusion_4Expression_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack__3_3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack__3_3Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None): # src/fusion/Expr.mbi:997:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    _2=_0[_1]
    if (_2 is None): # src/fusion/Expr.mbi:1001:14-24
     raise ValueError("Arguments for stack may not be null")
    for _3 in range(0,int((_2).shape[0])):
     if (_2[_3] is None): # src/fusion/Expr.mbi:1003:16-29
      raise ValueError("Arguments for stack may not be null")
   _4=numpy.array([mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0[_5],1) for _5 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(object))
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_4,0))
  @staticmethod
  def _match_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DDD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DDD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDD(numpy.float64(__0),numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_DDD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _vstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _vstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _vstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _vstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),0))
  @staticmethod
  def _match_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_vstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _vstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._vstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _vstack__3Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None): # src/fusion/Expr.mbi:962:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None): # src/fusion/Expr.mbi:964:14-30
     raise ValueError("Arguments for vstack may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,0))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   if ((_0 is None) or ((_1 is None) or (_2 is None))): # src/fusion/Expr.mbi:951:99-137
    raise ValueError("Arguments e1, e2 and e3 may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,numpy.float64(__1),_2)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2DD(_0,numpy.float64(__1),numpy.float64(__2))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2DD(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.float64(__0),_1,_2)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2D(numpy.float64(__0),_1,numpy.float64(__2))
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_D__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_hstack_DDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _hstack_alt_DDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._hstack_DDLmosek_4fusion_4Expression_2(numpy.float64(__0),numpy.float64(__1),_2)
  @staticmethod
  def _hstack_DDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _hstack_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_0),_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,mosek.fusion.Expr._constTerm_D(_1)], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _hstack_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _hstack_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_0,_1], dtype=numpy.dtype(object)),1))
  @staticmethod
  def _match_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_hstack__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _hstack_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._hstack__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _hstack__3Lmosek_4fusion_4Expression_2(_0):
   if (_0 is None): # src/fusion/Expr.mbi:903:12-25
    raise ValueError("Argument exprs may not be null")
   for _1 in range(0,int((_0).shape[0])):
    if (_0[_1] is None): # src/fusion/Expr.mbi:905:14-30
     raise ValueError("Arguments for hstack may not be null")
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,1))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2,_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,_2,numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(numpy.int32(__0),_1,numpy.float64(__2),_3)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2DD(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2DD(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2DD(numpy.int32(__0),_1,numpy.float64(__2),numpy.float64(__3))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2DD(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2),mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2,_3)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_match_D__(_3))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2D(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2) and __arg_alt_match_D__(_3))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2D(numpy.int32(__0),numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2,mosek.fusion.Expr._constTerm_D(_3)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_D__(_2) and __arg_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _match_alt_stack_IDDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_D__(_2) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_3))
  @staticmethod
  def _stack_alt_IDDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr._stack_IDDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),numpy.float64(__2),_3)
  @staticmethod
  def _stack_IDDLmosek_4fusion_4Expression_2(_0,_1,_2,_3):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),mosek.fusion.Expr._constTerm_D(_2),_3], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_IDLmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_IDLmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_IDLmosek_4fusion_4Expression_2(numpy.int32(__0),numpy.float64(__1),_2)
  @staticmethod
  def _stack_IDLmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([mosek.fusion.Expr._constTerm_D(_1),_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2D(numpy.int32(__0),_1,numpy.float64(__2))
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2D(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,mosek.fusion.Expr._constTerm_D(_2)], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _match_alt_stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_2))
  @staticmethod
  def _stack_alt_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(numpy.int32(__0),_1,_2)
  @staticmethod
  def _stack_ILmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1,_2):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(numpy.array([_1,_2], dtype=numpy.dtype(object)),_0))
  @staticmethod
  def _match_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_stack_I_3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _stack_alt_I_3Lmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._stack_I_3Lmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _stack_I_3Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_1,_0))
  @staticmethod
  def __stack_1_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Expr.__stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __stack_1__3Lmosek_4fusion_4Expression_2I(_0,_1):
   if (int((_0).shape[0])==1): # src/fusion/Expr.mbi:879:12-27
    return (_0[0])
   else:
    return (mosek_fusion_ExprStack._ctor__3Lmosek_4fusion_4Expression_2I(mosek.fusion.Expr.__promote__3Lmosek_4fusion_4Expression_2I(_0,_1),_1))
  @staticmethod
  def __promote_alt__3Lmosek_4fusion_4Expression_2I(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Expr.__promote__3Lmosek_4fusion_4Expression_2I(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __promote__3Lmosek_4fusion_4Expression_2I(_0,_1):
   _2=int((_0).shape[0])
   _3=numpy.array([_0[_4]._getND_() for _4 in range(0,_2)], dtype=numpy.dtype(numpy.int32))
   _5=_3[0]
   _6=_3[0]
   _5,_6 = fragments._c_closure_571(_5,_6,_2,_3) # src/fusion/Expr.mbi:850:8-853:9
   _5 = numpy.int32(_5) # postprocess
   _6 = numpy.int32(_6) # postprocess
   if (_5 < _1): # src/fusion/Expr.mbi:855:12-23
    _5 = _1
   if (_6 < _5): # src/fusion/Expr.mbi:856:12-25
    _7=numpy.ndarray((_2,), dtype=numpy.dtype(object))
    _8=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
    for _9 in range(0,_2):
     if (_0[_9]._getND_()==_5): # src/fusion/Expr.mbi:861:16-41
      _7[_9] = _0[_9]
     else:
      _10=_0[_9]._getShape_()
      fragments._c_closure_572(_10,_8) # src/fusion/Expr.mbi:865:14-54
      fragments._c_closure_573(_5,_10,_8) # src/fusion/Expr.mbi:866:14-55
      _7[_9] = mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_8,_0[_9])
    return (_7)
   else:
    return (_0)
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Variable_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Variable_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Variable_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Variable_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Variable_2II(_0,_1,_2):
   return (mosek.fusion.Expr._repeat_Lmosek_4fusion_4Expression_2II(_0._asExpr_(),_1,_2))
  @staticmethod
  def _match_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_repeat_Lmosek_4fusion_4Expression_2II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _repeat_alt_Lmosek_4fusion_4Expression_2II(_t__0,_t__1,_t__2):
    return mosek_fusion_Expr._repeat_Lmosek_4fusion_4Expression_2II(_0,numpy.int32(__1),numpy.int32(__2))
  @staticmethod
  def _repeat_Lmosek_4fusion_4Expression_2II(_0,_1,_2):
   if (_1 <= 0): # src/fusion/Expr.mbi:824:12-18
    raise mosek_fusion_DimensionError._ctor_S("Cannot repeat Expression 0 or less times")
   if ((_2 < 0) or (_2 > _0._getND_())): # src/fusion/Expr.mbi:827:12-34
    raise mosek_fusion_DimensionError._ctor_S("Invalid stacking dimension")
   else:
    if (_2==_0._getND_()): # src/fusion/Expr.mbi:829:17-31
     _3=numpy.zeros(((_2 + 1),), dtype=numpy.dtype(numpy.int32))
     for _4 in range(0,_2):
      _3[_4] = _0._getDim_I(_4)
     _3[_2] = 1
     return (mosek_fusion_ExprRepeat._ctor_Lmosek_4fusion_4Expression_2II(mosek.fusion.Expr._reshape_Lmosek_4fusion_4Expression_2_3I(_0,_3),_2,_1))
    else:
     return (mosek_fusion_ExprRepeat._ctor_Lmosek_4fusion_4Expression_2II(_0,_2,_1))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Expression_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Expression_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Expression_2(_0):
   return (mosek_fusion_ExprWSum._ctor__3Lmosek_4fusion_4Expression_2_3D(_0,numpy.array([1.0 for _1 in range(0,int((_0).shape[0]))], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _match_alt_add__3Lmosek_4fusion_4Variable_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Variable_2__(_0))
  @staticmethod
  def _add_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr._add__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3Lmosek_4fusion_4Variable_2(_0):
   if (_0 is None): # src/fusion/Expr.mbi:749:12-22
    raise ValueError("Argument vs may not be null")
   if (int((_0).shape[0])==0): # src/fusion/Expr.mbi:750:12-24
    return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3JI(numpy.array([0], dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),None,mosek.fusion.Set._make_I(0),numpy.zeros((0,), dtype=numpy.dtype(numpy.int64)),1))
   if ((int((_0).shape[0]) > 0) and (_0[0] is None)): # src/fusion/Expr.mbi:753:12-41
    raise ValueError("Argument vs may contain null")
   _1=_0[0]._getND_()
   for _2 in range(1,int((_0).shape[0])):
    if (_1 < _0[_2]._getND_()): # src/fusion/Expr.mbi:754:61-79
     _1 = _0[_2]._getND_()
   _3=numpy.zeros((int((_0).shape[0]),_1,), dtype=numpy.dtype(numpy.int32))
   for _4 in range(0,int((_0).shape[0])):
    _5=_0[_4]._getShape_()
    fragments._c_closure_574(_4,_3,_5) # src/fusion/Expr.mbi:758:10-57
    fragments._c_closure_575(_4,_1,_3,_5) # src/fusion/Expr.mbi:759:10-53
   for _6 in range(1,int((_0).shape[0])):
    for _7 in range(0,_1):
     if (_3[0,_7]!=_3[_6,_7]): # src/fusion/Expr.mbi:764:16-42
      raise mosek_fusion_DimensionError._ctor_S("Mismatching operand dimensions")
   _8=numpy.array([_3[0,_9] for _9 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _10=1
   _10 = fragments._c_closure_576(_1,_8,_10) # src/fusion/Expr.mbi:767:20-55
   _10 = numpy.int32(_10) # postprocess
   _11=0
   _12=0
   for _13 in range(0,int((_0).shape[0])):
    _14=_0[_13]._numInst_()
    _11 += _14
    _12 = (_12 if ((_12 > _14) ) else _14)
   _15=numpy.zeros(((_10 + 1),), dtype=numpy.dtype(numpy.int64))
   _16=numpy.zeros((_11,), dtype=numpy.dtype(numpy.int64))
   _17=numpy.array([1.0 for _18 in range(0,_11)], dtype=numpy.dtype(numpy.float64))
   _19=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   _20=numpy.zeros((_12,), dtype=numpy.dtype(numpy.int64))
   for _21 in range(0,int((_0).shape[0])):
    _22=_0[_21]._inst_I_3JI_3J(0,_19,0,_20)
    fragments._c_closure_577(_19,_22,_15) # src/fusion/Expr.mbi:785:12-786:33
   fragments._c_closure_578(_15,_10) # src/fusion/Expr.mbi:788:10-51
   for _23 in range(0,int((_0).shape[0])):
    _24=_0[_23]._inst_I_3JI_3J(0,_19,0,_20)
    fragments._c_closure_579(_20,_19,_24,_15,_16) # src/fusion/Expr.mbi:791:12-794:13
   fragments._c_closure_580(_15,_10) # src/fusion/Expr.mbi:796:10-56
   _15[0] = 0
   return (mosek_fusion_Expr._ctor__3J_3J_3D_3D_3I_3JI(_15,_16,_17,numpy.array([0.0 for _25 in range(0,_10)], dtype=numpy.dtype(numpy.float64)),_8,None,1))
  @staticmethod
  def __add_1_alt_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_t__0,_t__1,_t__2,_t__3):
    return mosek_fusion_Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,numpy.float64(__1),_2,numpy.float64(__3))
  @staticmethod
  def __add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,_1,_2,_3):
   _4=_0._getND_()
   _5=_2._getND_()
   if (_4==_5): # src/fusion/Expr.mbi:709:12-22
    return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(_0,_2,_1,_3))
   else:
    _6=(_4 if ((_4 > _5) ) else _5)
    _7=numpy.zeros((_6,), dtype=numpy.dtype(numpy.int32))
    if (_4 < _5): # src/fusion/Expr.mbi:714:14-23
     _8=_0._getShape_()
     fragments._c_closure_581(_4,_8,_7) # src/fusion/Expr.mbi:716:12-50
     fragments._c_closure_582(_6,_4,_7) # src/fusion/Expr.mbi:717:12-47
     return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_7,_0),_2,_1,_3))
    else:
     _9=_2._getShape_()
     fragments._c_closure_583(_5,_9,_7) # src/fusion/Expr.mbi:723:12-50
     fragments._c_closure_584(_6,_5,_7) # src/fusion/Expr.mbi:724:12-47
     return (mosek_fusion_ExprAdd._ctor_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2DD(_0,mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(_7,_2),_1,_3))
  @staticmethod
  def _match_transpose_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _match_alt_transpose_Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0))
  @staticmethod
  def _transpose_alt_Lmosek_4fusion_4Expression_2(_t__0):
    return mosek_fusion_Expr._transpose_Lmosek_4fusion_4Expression_2(_0)
  @staticmethod
  def _transpose_Lmosek_4fusion_4Expression_2(_0):
   if (_0._getND_()==0): # src/fusion/Expr.mbi:692:16-30
    return (_0)
   elif (_0._getND_()==1): # src/fusion/Expr.mbi:694:16-30
    return (mosek_fusion_ExprReshape._ctor__3ILmosek_4fusion_4Expression_2(numpy.array([1,_0._getDim_I(0)], dtype=numpy.dtype(numpy.int32)),_0))
   elif (_0._getND_()==2): # src/fusion/Expr.mbi:696:16-30
    return (mosek_fusion_ExprTranspose._ctor_Lmosek_4fusion_4Expression_2(_0))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Incorrect number of dimensions for transpose")
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _mulElm__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_0),_1))
  @staticmethod
  def _match_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._mulElm__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(mosek.fusion.Matrix._dense__3_5D(_1),_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1__3DLmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__mulElm_1_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Parameter_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek_fusion_ExprMulParamElem._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_0,_1))
  @staticmethod
  def _match_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _match_alt_mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Parameter_2__(_1))
  @staticmethod
  def _mulElm_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_t__0,_t__1):
    return mosek_fusion_Expr._mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1)
  @staticmethod
  def _mulElm_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Parameter_2(_0,_1):
   return (mosek_fusion_ExprMulParamElem._ctor_Lmosek_4fusion_4Parameter_2Lmosek_4fusion_4Expression_2(_1,_0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),(- 1.0)))
  @staticmethod
  def _match_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _sub_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3ID(_1._getShape_(),_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3ID(_0._getShape_(),_1),(- 1.0)))
  @staticmethod
  def _match_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _sub__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3_5D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._sub__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(mosek.fusion.Expr._constTerm__3D(_0),1.0,_1,(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),(- 1.0)))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _sub_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _sub_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,(- 1.0)))
  @staticmethod
  def _match_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4NDSparseArray_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4NDSparseArray_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4NDSparseArray_2(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Matrix_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm_Lmosek_4fusion_4Matrix_2(_1),1.0))
  @staticmethod
  def _match_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_DLmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_DLmosek_4fusion_4Expression_2(numpy.float64(__0),_1)
  @staticmethod
  def _add_DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3ID(_1._getShape_(),_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2D(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2D(_0,numpy.float64(__1))
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3ID(_0._getShape_(),_1),1.0))
  @staticmethod
  def _match_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3_5D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3_5DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3_5D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3_5DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3_5DLmosek_4fusion_4Expression_2(_0,_1)
   return _1
  @staticmethod
  def _add__3_5DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3_5D(_0),1.0))
  @staticmethod
  def _match_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add__3DLmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt__3DLmosek_4fusion_4Expression_2(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=_t__1
   _1 = mosek_fusion_Expr._add__3DLmosek_4fusion_4Expression_2(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add__3DLmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_1,1.0,mosek.fusion.Expr._constTerm__3D(_0),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3_5D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3_5D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3_5D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3_5D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1)
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3_5D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3_5D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match__3D__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2_3D(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match__3D__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2_3D(_t__0,_t__1):
   _0=_t__0
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2_3D(_0,_1)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2_3D(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,mosek.fusion.Expr._constTerm__3D(_1),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_Lmosek_4fusion_4Expression_2__(_0) and __arg_alt_match_Lmosek_4fusion_4Expression_2__(_1))
  @staticmethod
  def _add_alt_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_t__0,_t__1):
    return mosek_fusion_Expr._add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1)
  @staticmethod
  def _add_Lmosek_4fusion_4Expression_2Lmosek_4fusion_4Expression_2(_0,_1):
   return (mosek.fusion.Expr.__add_1_Lmosek_4fusion_4Expression_2DLmosek_4fusion_4Expression_2D(_0,1.0,_1,1.0))
  @staticmethod
  def _match_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_match_Lmosek_4fusion_4WorkStack_2__(_2))
  @staticmethod
  def _match_alt_eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_1) and __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_2))
  def _eval_alt_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_t__0,_t__1,_t__2):
    return self._eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(_0,_1,_2)
  def _eval_Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2Lmosek_4fusion_4WorkStack_2(self,_0,_1,_2):
   _3=(int((self.__ptrb).shape[0]) - 1)
   _4=(numpy.int32(self.__ptrb[_3]) + _3)
   _5=int((self.__shape).shape[0])
   _0._alloc_1expr_IIIZ(_5,_3,_4,(self.__inst is not None))
   _6=(_0.ptr_base)
   _7=(_0.nidxs_base)
   _8=(_0.sp_base)
   _9=(_0.cof_base)
   _10=(_0.shape_base)
   _11=(_0.i32)
   _12=(_0.i64)
   _13=(_0.f64)
   fragments._c_closure_585(self.__bfix,_9,self.__cof_v,_13,_11,_12,_5,_3,_7,_6,self.__ptrb,self.__shape,_10,self.__subj) # src/fusion/Expr.mbi:628:8-643:9
  @staticmethod
  def __validateData_alt__3J_3J_3D_3D_3I_3J(_t__0,_t__1,_t__2,_t__3,_t__4,_t__5):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int64))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.float64))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.int32))
   _5=numpy.array(_t__5,dtype=numpy.dtype(numpy.int64))
   _1 = mosek_fusion_Expr.__validateData__3J_3J_3D_3D_3I_3J(_0,_1,_2,_3,_4,_5)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__5[:] = _5
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __validateData__3J_3J_3D_3D_3I_3J(_0,_1,_2,_3,_4,_5):
   if (_4 is None): # src/fusion/Expr.mbi:443:16-29
    raise mosek_fusion_ExpressionError._ctor_S("Array 'shape' in expression is null")
   _6=(int((_0).shape[0]) - 1)
   _7=_0[(int((_0).shape[0]) - 1)]
   _8=int((_4).shape[0])
   _9=1
   _9 = fragments._c_closure_586(_8,_4,_9) # src/fusion/Expr.mbi:448:23-60
   _9 = numpy.int64(_9) # postprocess
   if (int((_0).shape[0]) < 1): # src/fusion/Expr.mbi:449:16-29
    raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong size")
   if (_7!=int((_1).shape[0])): # src/fusion/Expr.mbi:451:17-36
    raise mosek_fusion_ExpressionError._ctor_S("Array 'subj' in expression has wrong size")
   if (_7!=int((_2).shape[0])): # src/fusion/Expr.mbi:453:17-35
    raise mosek_fusion_ExpressionError._ctor_S("Array 'cof' in expression has wrong size")
   if ((_3 is None) or (_6!=int((_3).shape[0]))): # src/fusion/Expr.mbi:455:17-54
    raise mosek_fusion_ExpressionError._ctor_S("Array 'bfix' in expression has wrong length")
   if ((_5 is not None) and (int((_5).shape[0]) < _9)): # src/fusion/Expr.mbi:458:12-45
    if (int((_5).shape[0])!=(int((_0).shape[0]) - 1)): # src/fusion/Expr.mbi:460:14-38
     raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' in expression has wrong length")
    if (int((_5).shape[0]) > 0): # src/fusion/Expr.mbi:463:14-27
     if ((_5[0] < 0) or (_5[0] >= _9)): # src/fusion/Expr.mbi:465:16-46
      raise mosek_fusion_ExpressionError._ctor_S("Array 'inst' contains an invalid index")
     _10=True
     _11=_9
     _10 = fragments._c_closure_587(_5,_10,_11) # src/fusion/Expr.mbi:471:12-477:13
     if (not _10): # src/fusion/Expr.mbi:478:16-35
      raise mosek_fusion_ExpressionError._ctor_S("Invalid array 'inst'")
   else:
    if (_9!=(int((_0).shape[0]) - 1)): # src/fusion/Expr.mbi:483:14-37
     raise mosek_fusion_ExpressionError._ctor_S("Array 'ptrb' in expression has wrong length")
   _12=False
   _13=False
   if (_0[0]!=0): # src/fusion/Expr.mbi:489:12-25
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
   _14=True
   _14 = fragments._c_closure_588(_6,_0,_14) # src/fusion/Expr.mbi:493:8-494:61
   if (not _14): # src/fusion/Expr.mbi:495:12-27
    raise mosek_fusion_ExpressionError._ctor_S("Invalid 'ptrb' argument in expression")
  @staticmethod
  def __extractModel_alt__3Lmosek_4fusion_4Variable_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Expr.__extractModel__3Lmosek_4fusion_4Variable_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def __extractModel__3Lmosek_4fusion_4Variable_2(_0):
   return ((None if (((_0 is None) or (int((_0).shape[0])==0)) ) else _0[0]._getModel_()))
 return Expr
mosek_fusion_Expr=__mk_mosek_fusion_Expr()
del __mk_mosek_fusion_Expr
#BEFORE CLASS
def __mk_mosek_fusion_WorkStack():
 class WorkStack(object):
  __slots__ = ['code_base','cconst_base','codeptr_base','cof_base','nidxs_base','sp_base','shape_base','ptr_base','hassp','ncodeatom','nelem','nnz','nd','pf64','pi64','pi32','f64','i64','i32']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.WorkStack.ctor()')
  def pushi64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushi64_J(*args): # int64
      return self._pushi64_J(*args)
    elif mosek_fusion_WorkStack._match_alt_pushi64_J(*args): # int64
      return self._pushi64_alt_J(*args)
    else:
      raise ValueError('Invalid argument list pushi64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushi64(int64)')
  def pop_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pop_1expr_(*args): # 
      return self._pop_1expr_(*args)
    elif mosek_fusion_WorkStack._match_alt_pop_1expr_(*args): # 
      return self._pop_1expr_alt_(*args)
    else:
      raise ValueError('Invalid argument list pop_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pop_expr()')
  def alloci32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloci32_I(*args): # int32
      return self._alloci32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_alloci32_I(*args): # int32
      return self._alloci32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloci32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloci32(int32)')
  def alloc_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloc_1expr_IIIZ(*args): # int32,int32,int32,bool
      return self._alloc_1expr_IIIZ(*args)
    elif mosek_fusion_WorkStack._match_alt_alloc_1expr_IIIZ(*args): # int32,int32,int32,bool
      return self._alloc_1expr_alt_IIIZ(*args)
    elif mosek_fusion_WorkStack._match_alloc_1expr_IIIZI(*args): # int32,int32,int32,bool,int32
      return self._alloc_1expr_IIIZI(*args)
    elif mosek_fusion_WorkStack._match_alt_alloc_1expr_IIIZI(*args): # int32,int32,int32,bool,int32
      return self._alloc_1expr_alt_IIIZI(*args)
    else:
      raise ValueError('Invalid argument list alloc_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool)\n\tmosek.fusion.WorkStack.alloc_expr(int32,int32,int32,bool,int32)')
  def formatCurrent(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_formatCurrent_(*args): # 
      return self._formatCurrent_(*args)
    elif mosek_fusion_WorkStack._match_alt_formatCurrent_(*args): # 
      return self._formatCurrent_alt_(*args)
    else:
      raise ValueError('Invalid argument list formatCurrent('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.formatCurrent()')
  def peeki64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peeki64_(*args): # 
      return self._peeki64_(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki64_(*args): # 
      return self._peeki64_alt_(*args)
    elif mosek_fusion_WorkStack._match_peeki64_I(*args): # int32
      return self._peeki64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki64_I(*args): # int32
      return self._peeki64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peeki64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peeki64()\n\tmosek.fusion.WorkStack.peeki64(int32)')
  def pushf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushf64_D(*args): # double
      return self._pushf64_D(*args)
    elif mosek_fusion_WorkStack._match_alt_pushf64_D(*args): # double
      return self._pushf64_alt_D(*args)
    else:
      raise ValueError('Invalid argument list pushf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushf64(double)')
  def popi32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popi32_(*args): # 
      return self._popi32_(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_(*args): # 
      return self._popi32_alt_(*args)
    elif mosek_fusion_WorkStack._match_popi32_I(*args): # int32
      return self._popi32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_I(*args): # int32
      return self._popi32_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popi32_I_3II(*args): # int32,[]int32,int32
      return self._popi32_I_3II(*args)
    elif mosek_fusion_WorkStack._match_alt_popi32_I_3II(*args): # int32,[]int32,int32
      return self._popi32_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list popi32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popi32()\n\tmosek.fusion.WorkStack.popi32(int32)\n\tmosek.fusion.WorkStack.popi32(int32,array(int32,ndim=1),int32)')
  def move_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_move_1expr_Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack
      return self._move_1expr_Lmosek_4fusion_4WorkStack_2(*args)
    elif mosek_fusion_WorkStack._match_alt_move_1expr_Lmosek_4fusion_4WorkStack_2(*args): # mosek.fusion.WorkStack
      return self._move_1expr_alt_Lmosek_4fusion_4WorkStack_2(*args)
    else:
      raise ValueError('Invalid argument list move_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.move_expr(mosek.fusion.WorkStack)')
  def alloci64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_alloci64_I(*args): # int32
      return self._alloci64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_alloci64_I(*args): # int32
      return self._alloci64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloci64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.alloci64(int32)')
  def ensuref64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensuref64_I(*args): # int32
      return self._ensuref64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensuref64_I(*args): # int32
      return self._ensuref64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensuref64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensuref64(int32)')
  def peek_nelem(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nelem_(*args): # 
      return self._peek_1nelem_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nelem_(*args): # 
      return self._peek_1nelem_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nelem('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nelem()')
  def ensurei64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensurei64_I(*args): # int32
      return self._ensurei64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensurei64_I(*args): # int32
      return self._ensurei64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensurei64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensurei64(int32)')
  def peek_nd(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nd_(*args): # 
      return self._peek_1nd_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nd_(*args): # 
      return self._peek_1nd_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nd('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nd()')
  def clear(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_clear_(*args): # 
      return self._clear_(*args)
    elif mosek_fusion_WorkStack._match_alt_clear_(*args): # 
      return self._clear_alt_(*args)
    else:
      raise ValueError('Invalid argument list clear('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.clear()')
  def peeki32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peeki32_(*args): # 
      return self._peeki32_(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki32_(*args): # 
      return self._peeki32_alt_(*args)
    elif mosek_fusion_WorkStack._match_peeki32_I(*args): # int32
      return self._peeki32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peeki32_I(*args): # int32
      return self._peeki32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peeki32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peeki32()\n\tmosek.fusion.WorkStack.peeki32(int32)')
  def allocf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_allocf64_I(*args): # int32
      return self._allocf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_allocf64_I(*args): # int32
      return self._allocf64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list allocf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.allocf64(int32)')
  def peek_nnz(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1nnz_(*args): # 
      return self._peek_1nnz_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1nnz_(*args): # 
      return self._peek_1nnz_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_nnz('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_nnz()')
  def ensurei32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensurei32_I(*args): # int32
      return self._ensurei32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_ensurei32_I(*args): # int32
      return self._ensurei32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list ensurei32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensurei32(int32)')
  def peek_hassp(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1hassp_(*args): # 
      return self._peek_1hassp_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1hassp_(*args): # 
      return self._peek_1hassp_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_hassp('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_hassp()')
  def peek_expr(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1expr_(*args): # 
      return self._peek_1expr_(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1expr_(*args): # 
      return self._peek_1expr_alt_(*args)
    else:
      raise ValueError('Invalid argument list peek_expr('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_expr()')
  def ensure_sparsity(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_ensure_1sparsity_(*args): # 
      return self._ensure_1sparsity_(*args)
    elif mosek_fusion_WorkStack._match_alt_ensure_1sparsity_(*args): # 
      return self._ensure_1sparsity_alt_(*args)
    else:
      raise ValueError('Invalid argument list ensure_sparsity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.ensure_sparsity()')
  def pushi32(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_pushi32_I(*args): # int32
      return self._pushi32_I(*args)
    elif mosek_fusion_WorkStack._match_alt_pushi32_I(*args): # int32
      return self._pushi32_alt_I(*args)
    else:
      raise ValueError('Invalid argument list pushi32('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.pushi32(int32)')
  def popf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popf64_(*args): # 
      return self._popf64_(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_(*args): # 
      return self._popf64_alt_(*args)
    elif mosek_fusion_WorkStack._match_popf64_I(*args): # int32
      return self._popf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_I(*args): # int32
      return self._popf64_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popf64_I_3DI(*args): # int32,[]double,int32
      return self._popf64_I_3DI(*args)
    elif mosek_fusion_WorkStack._match_alt_popf64_I_3DI(*args): # int32,[]double,int32
      return self._popf64_alt_I_3DI(*args)
    else:
      raise ValueError('Invalid argument list popf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popf64()\n\tmosek.fusion.WorkStack.popf64(int32)\n\tmosek.fusion.WorkStack.popf64(int32,array(double,ndim=1),int32)')
  def peekf64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peekf64_(*args): # 
      return self._peekf64_(*args)
    elif mosek_fusion_WorkStack._match_alt_peekf64_(*args): # 
      return self._peekf64_alt_(*args)
    elif mosek_fusion_WorkStack._match_peekf64_I(*args): # int32
      return self._peekf64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peekf64_I(*args): # int32
      return self._peekf64_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peekf64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peekf64()\n\tmosek.fusion.WorkStack.peekf64(int32)')
  def peek_dim(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_peek_1dim_I(*args): # int32
      return self._peek_1dim_I(*args)
    elif mosek_fusion_WorkStack._match_alt_peek_1dim_I(*args): # int32
      return self._peek_1dim_alt_I(*args)
    else:
      raise ValueError('Invalid argument list peek_dim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.peek_dim(int32)')
  def popi64(self,*args):
    if False: pass
    elif mosek_fusion_WorkStack._match_popi64_(*args): # 
      return self._popi64_(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_(*args): # 
      return self._popi64_alt_(*args)
    elif mosek_fusion_WorkStack._match_popi64_I(*args): # int32
      return self._popi64_I(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_I(*args): # int32
      return self._popi64_alt_I(*args)
    elif mosek_fusion_WorkStack._match_popi64_I_3JI(*args): # int32,[]int64,int32
      return self._popi64_I_3JI(*args)
    elif mosek_fusion_WorkStack._match_alt_popi64_I_3JI(*args): # int32,[]int64,int32
      return self._popi64_alt_I_3JI(*args)
    else:
      raise ValueError('Invalid argument list popi64('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.WorkStack.popi64()\n\tmosek.fusion.WorkStack.popi64(int32)\n\tmosek.fusion.WorkStack.popi64(int32,array(int64,ndim=1),int32)')
  def __repr__(self): return 'mosek.fusion.WorkStack'
  @staticmethod
  def _ctor_():
    o = WorkStack.__new__(WorkStack)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   self.i32 = numpy.zeros((256,), dtype=numpy.dtype(numpy.int32))
   self.i64 = numpy.zeros((256,), dtype=numpy.dtype(numpy.int64))
   self.f64 = numpy.zeros((256,), dtype=numpy.dtype(numpy.float64))
   self.pi32 = 0
   self.pi64 = 0
   self.pf64 = 0
   self.nd = 0
   self.nnz = 0
   self.nelem = 0
   self.hassp = False
   self.ncodeatom = 0
   self.ptr_base = 0
   self.shape_base = 0
   self.sp_base = 0
   self.nidxs_base = 0
   self.cof_base = 0
   self.cconst_base = 0
   self.code_base = 0
   self.codeptr_base = 0
  @staticmethod
  def _match_formatCurrent_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_formatCurrent_(*args):
    if len(args) != 0: return False
    return True
  def _formatCurrent_alt_(self,):
    return self._formatCurrent_()
  def _formatCurrent_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("  nelem     = ")._a_I(self.nelem)._a_S("\n")._a_S("  nnz       = ")._a_I(self.nnz)._a_S("\n")._a_S("  hassp     = ")._a_Z(self.hassp)._a_S(" / ")._a_Z(self.hassp)._a_S("\n")._a_S("  shape     = ")._a__3I(numpy.array([self.i32[(self.shape_base + _1)] for _1 in range(0,self.nd)], dtype=numpy.dtype(numpy.int32)))._a_S("\n")._a_S("  ptr       = ")._a__3I(numpy.array([self.i32[(self.ptr_base + _2)] for _2 in range(0,(self.nelem + 1))], dtype=numpy.dtype(numpy.int32)))._a_S("\n")
   if (self.ncodeatom > 0): # src/fusion/BaseExpression.monty:374:12-25
    _0._a_S("  codeptr   = ")._a__3I(numpy.array([self.i32[(self.codeptr_base + _3)] for _3 in range(0,(self.nnz + 1))], dtype=numpy.dtype(numpy.int32)))._a_S("\n")
   if self.hassp: # src/fusion/BaseExpression.monty:376:12-17
    _0._a_S("  sp        = ")._a__3J(numpy.array([self.i64[(self.sp_base + _4)] for _4 in range(0,self.nelem)], dtype=numpy.dtype(numpy.int64)))._a_S("\n")
   for _5 in range(0,self.nelem):
    _0._a_S("  row[")._a_I(_5)._a_S("]")._a_S("\n")._a_S("    nidx : ")._a__3J(numpy.array([self.i64[(self.nidxs_base + _6)] for _6 in range(self.i32[(self.ptr_base + _5)],self.i32[((self.ptr_base + _5) + 1)])], dtype=numpy.dtype(numpy.int64)))._a_S("\n")._a_S("    cof  : ")._a__3D(numpy.array([self.f64[(self.cof_base + _7)] for _7 in range(self.i32[(self.ptr_base + _5)],self.i32[((self.ptr_base + _5) + 1)])], dtype=numpy.dtype(numpy.float64)))._a_S("\n")
    if (self.ncodeatom > 0): # src/fusion/BaseExpression.monty:383:14-27
     for _8 in range(self.i32[(self.ptr_base + _5)],self.i32[((self.ptr_base + _5) + 1)]):
      _0._a_S("      code[")._a_J(self.i64[(self.nidxs_base + _8)])._a_S("] ")._a__3I(numpy.array([self.i32[(self.code_base + _9)] for _9 in range(self.i32[(self.codeptr_base + _8)],self.i32[((self.codeptr_base + _8) + 1)])], dtype=numpy.dtype(numpy.int32)))._a__3D(numpy.array([self.f64[(self.cconst_base + _10)] for _10 in range(self.i32[(self.codeptr_base + _8)],self.i32[((self.codeptr_base + _8) + 1)])], dtype=numpy.dtype(numpy.float64)))._a_S("\n")
   return (_0._toString_())
  @staticmethod
  def _match_peek_1hassp_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1hassp_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1hassp_alt_(self,):
    return self._peek_1hassp_()
  def _peek_1hassp_(self,):
   return ((self._peeki32_I((3 + self._peek_1nd_()))!=0))
  @staticmethod
  def _match_peek_1nnz_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nnz_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nnz_alt_(self,):
    return self._peek_1nnz_()
  def _peek_1nnz_(self,):
   return numpy.int32(self._peeki32_I((2 + self._peek_1nd_())))
  @staticmethod
  def _match_peek_1nelem_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nelem_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nelem_alt_(self,):
    return self._peek_1nelem_()
  def _peek_1nelem_(self,):
   return numpy.int32(self._peeki32_I((1 + self._peek_1nd_())))
  @staticmethod
  def _match_peek_1dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peek_1dim_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peek_1dim_alt_I(self,_t__0):
    return self._peek_1dim_I(numpy.int32(__0))
  def _peek_1dim_I(self,_0):
   return numpy.int32(self._peeki32_I((_0 + 1)))
  @staticmethod
  def _match_peek_1nd_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1nd_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1nd_alt_(self,):
    return self._peek_1nd_()
  def _peek_1nd_(self,):
   return numpy.int32(self._peeki32_())
  @staticmethod
  def _match_alloc_1expr_IIIZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Z__(_3))
  @staticmethod
  def _match_alt_alloc_1expr_IIIZ(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Z__(_3))
  def _alloc_1expr_alt_IIIZ(self,_t__0,_t__1,_t__2,_t__3):
    return self._alloc_1expr_IIIZ(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),_3)
  def _alloc_1expr_IIIZ(self,_0,_1,_2,_3):
   self._alloc_1expr_IIIZI(_0,_1,_2,_3,0)
  @staticmethod
  def _match_alloc_1expr_IIIZI(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_I__(_2) and __arg_match_Z__(_3) and __arg_match_I__(_4))
  @staticmethod
  def _match_alt_alloc_1expr_IIIZI(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_I__(_2) and __arg_alt_match_Z__(_3) and __arg_alt_match_I__(_4))
  def _alloc_1expr_alt_IIIZI(self,_t__0,_t__1,_t__2,_t__3,_t__4):
    return self._alloc_1expr_IIIZI(numpy.int32(__0),numpy.int32(__1),numpy.int32(__2),_3,numpy.int32(__4))
  def _alloc_1expr_IIIZI(self,_0,_1,_2,_3,_4):
   self.cof_base = self._allocf64_I(_2)
   self.cconst_base = self._allocf64_I(_4)
   self.nidxs_base = self._alloci64_I(_2)
   self.sp_base = (self._alloci64_I(_1) if (_3 ) else (- 9999))
   self.code_base = self._alloci32_I(_4)
   self.codeptr_base = (self._alloci32_I((_2 + 1)) if ((_4 > 0) ) else (- 9999))
   self.ptr_base = self._alloci32_I((_1 + 1))
   self._pushi32_I(_4)
   self._pushi32_I((1 if (_3 ) else 0))
   self._pushi32_I(_2)
   self._pushi32_I(_1)
   self.shape_base = self._alloci32_I(_0)
   self._pushi32_I(_0)
   (self.ncodeatom) = _4
   (self.nd) = _0
   (self.nelem) = _1
   (self.nnz) = _2
   (self.hassp) = _3
  @staticmethod
  def _match_pop_1expr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_pop_1expr_(*args):
    if len(args) != 0: return False
    return True
  def _pop_1expr_alt_(self,):
    return self._pop_1expr_()
  def _pop_1expr_(self,):
   self.nd = self._popi32_()
   self.shape_base = self._popi32_I(self.nd)
   self.nelem = self._popi32_()
   self.nnz = self._popi32_()
   self.hassp = (self._popi32_()!=0)
   self.ncodeatom = self._popi32_()
   self.ptr_base = self._popi32_I((self.nelem + 1))
   self.codeptr_base = (self._popi32_I((self.nnz + 1)) if ((self.ncodeatom > 0) ) else (- 9999))
   self.code_base = self._popi32_I(self.ncodeatom)
   self.sp_base = (self._popi64_I(self.nelem) if (self.hassp ) else (- 9999))
   self.nidxs_base = self._popi64_I(self.nnz)
   self.cconst_base = self._popf64_I(self.ncodeatom)
   self.cof_base = self._popf64_I(self.nnz)
  @staticmethod
  def _match_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4WorkStack_2__(_0))
  @staticmethod
  def _match_alt_move_1expr_Lmosek_4fusion_4WorkStack_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4WorkStack_2__(_0))
  def _move_1expr_alt_Lmosek_4fusion_4WorkStack_2(self,_t__0):
    return self._move_1expr_Lmosek_4fusion_4WorkStack_2(_0)
  def _move_1expr_Lmosek_4fusion_4WorkStack_2(self,_0):
   _1=self.pi32
   _2=self.pi64
   _3=self.pf64
   self._pop_1expr_()
   _4=_0._alloci32_I((_1 - self.pi32))
   _5=_0._alloci64_I((_2 - self.pi64))
   _6=_0._allocf64_I((_3 - self.pf64))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,self.pi32,(_0.i32),_4,(_1 - self.pi32))
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,self.pi64,(_0.i64),_5,(_2 - self.pi64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,self.pf64,(_0.f64),_6,(_3 - self.pf64))
  @staticmethod
  def _match_peek_1expr_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peek_1expr_(*args):
    if len(args) != 0: return False
    return True
  def _peek_1expr_alt_(self,):
    return self._peek_1expr_()
  def _peek_1expr_(self,):
   _0=self.pi32
   _1=self.pi64
   _2=self.pf64
   self._pop_1expr_()
   self.pi32 = _0
   self.pi64 = _1
   self.pf64 = _2
  @staticmethod
  def _match_ensure_1sparsity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_ensure_1sparsity_(*args):
    if len(args) != 0: return False
    return True
  def _ensure_1sparsity_alt_(self,):
    return self._ensure_1sparsity_()
  def _ensure_1sparsity_(self,):
   _0=self.i32[(self.pi32 - 1)]
   _1=(self.i32[((self.pi32 - _0) - 3)]!=0)
   _2=self.i32[((self.pi32 - _0) - 1)]
   if (not _1): # src/fusion/BaseExpression.monty:262:12-21
    self.i32[((self.pi32 - _0) - 3)] = 1
    _3=self._alloci64_I(_2)
    fragments._c_closure_589(self.i64,_2,_3) # src/fusion/BaseExpression.monty:265:10-266:24
  @staticmethod
  def _match_clear_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_clear_(*args):
    if len(args) != 0: return False
    return True
  def _clear_alt_(self,):
    return self._clear_()
  def _clear_(self,):
   self.pi32 = 0
   self.pi64 = 0
   self.pf64 = 0
  @staticmethod
  def _match_allocf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_allocf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _allocf64_alt_I(self,_t__0):
    return self._allocf64_I(numpy.int32(__0))
  def _allocf64_I(self,_0):
   self._ensuref64_I(_0)
   _1=self.pf64
   fragments._c_closure_590(self.f64,_0,self.pf64) # src/fusion/BaseExpression.monty:204:8-50
   self.pf64 += _0
   return numpy.int32(_1)
  @staticmethod
  def _match_alloci64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloci64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloci64_alt_I(self,_t__0):
    return self._alloci64_I(numpy.int32(__0))
  def _alloci64_I(self,_0):
   self._ensurei64_I(_0)
   _1=self.pi64
   fragments._c_closure_591(self.i64,_0,self.pi64) # src/fusion/BaseExpression.monty:194:8-50
   self.pi64 += _0
   return numpy.int32(_1)
  @staticmethod
  def _match_alloci32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloci32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloci32_alt_I(self,_t__0):
    return self._alloci32_I(numpy.int32(__0))
  def _alloci32_I(self,_0):
   if (_0 > 0): # src/fusion/BaseExpression.monty:178:12-17
    self._ensurei32_I(_0)
    _1=self.pi32
    fragments._c_closure_592(self.i32,_0,self.pi32) # src/fusion/BaseExpression.monty:181:10-52
    self.pi32 += _0
    return numpy.int32(_1)
   else:
    return numpy.int32(0)
  @staticmethod
  def _match_pushf64_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_pushf64_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _pushf64_alt_D(self,_t__0):
    return self._pushf64_D(numpy.float64(__0))
  def _pushf64_D(self,_0):
   self._ensuref64_I(1)
   self.f64[self.pf64] = _0
   self.pf64 += 1
  @staticmethod
  def _match_pushi64_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_J__(_0))
  @staticmethod
  def _match_alt_pushi64_J(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_J__(_0))
  def _pushi64_alt_J(self,_t__0):
    return self._pushi64_J(numpy.int64(__0))
  def _pushi64_J(self,_0):
   self._ensurei64_I(1)
   self.i64[self.pi64] = _0
   self.pi64 += 1
  @staticmethod
  def _match_pushi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_pushi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _pushi32_alt_I(self,_t__0):
    return self._pushi32_I(numpy.int32(__0))
  def _pushi32_I(self,_0):
   self._ensurei32_I(1)
   self.i32[self.pi32] = _0
   self.pi32 += 1
  @staticmethod
  def _match_ensuref64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensuref64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensuref64_alt_I(self,_t__0):
    return self._ensuref64_I(numpy.int32(__0))
  def _ensuref64_I(self,_0):
   if ((self.pf64 + _0) > int((self.f64).shape[0])): # src/fusion/BaseExpression.monty:142:12-29
    _1=((int((self.f64).shape[0]) * 2) if (((_0 < int((self.f64).shape[0])) and (int((self.f64).shape[0]) < 1073741823)) ) else (int((self.f64).shape[0]) + _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.float64))
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,0,_2,0,self.pf64)
    self.f64 = _2
  @staticmethod
  def _match_ensurei64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensurei64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensurei64_alt_I(self,_t__0):
    return self._ensurei64_I(numpy.int32(__0))
  def _ensurei64_I(self,_0):
   if ((self.pi64 + _0) > int((self.i64).shape[0])): # src/fusion/BaseExpression.monty:132:12-29
    _1=(int((self.i64).shape[0]) + (int((self.i64).shape[0]) if (((_0 < int((self.i64).shape[0])) and (int((self.i64).shape[0]) < 1073741823)) ) else _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int64))
    mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,0,_2,0,self.pi64)
    self.i64 = _2
  @staticmethod
  def _match_ensurei32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_ensurei32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _ensurei32_alt_I(self,_t__0):
    return self._ensurei32_I(numpy.int32(__0))
  def _ensurei32_I(self,_0):
   if ((self.pi32 + _0) > int((self.i32).shape[0])): # src/fusion/BaseExpression.monty:122:12-29
    _1=((int((self.i32).shape[0]) * 2) if (((_0 < int((self.i32).shape[0])) and (int((self.i32).shape[0]) < 1073741823)) ) else (int((self.i32).shape[0]) + _0))
    _2=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,0,_2,0,self.pi32)
    self.i32 = _2
  @staticmethod
  def _match_popf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popf64_alt_I(self,_t__0):
    return self._popf64_I(numpy.int32(__0))
  def _popf64_I(self,_0):
   self.pf64 -= _0
   if (self.pf64 < 0): # src/fusion/BaseExpression.monty:114:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pf64)
  @staticmethod
  def _match_popi64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popi64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popi64_alt_I(self,_t__0):
    return self._popi64_I(numpy.int32(__0))
  def _popi64_I(self,_0):
   self.pi64 -= _0
   if (self.pi64 < 0): # src/fusion/BaseExpression.monty:109:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pi64)
  @staticmethod
  def _match_popi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_popi32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _popi32_alt_I(self,_t__0):
    return self._popi32_I(numpy.int32(__0))
  def _popi32_I(self,_0):
   self.pi32 -= _0
   if (self.pi32 < 0): # src/fusion/BaseExpression.monty:104:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.pi32)
  @staticmethod
  def _match_popf64_I_3DI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popf64_I_3DI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3D__(_1) and __arg_alt_match_I__(_2))
  def _popf64_alt_I_3DI(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.float64))
   _2=numpy.int32(_t__2)
   _1 = self._popf64_I_3DI(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popf64_I_3DI(self,_0,_1,_2):
   self.pf64 -= _0
   if (self.pf64 < 0): # src/fusion/BaseExpression.monty:99:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.f64,self.pf64,_1,_2,_0)
  @staticmethod
  def _match_popi64_I_3JI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3J__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popi64_I_3JI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match_I__(_2))
  def _popi64_alt_I_3JI(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.int32(_t__2)
   _1 = self._popi64_I_3JI(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popi64_I_3JI(self,_0,_1,_2):
   self.pi64 -= _0
   if (self.pi64 < 0): # src/fusion/BaseExpression.monty:94:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3JI_3JII(self.i64,self.pi64,_1,_2,_0)
  @staticmethod
  def _match_popi32_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_popi32_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _popi32_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._popi32_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _popi32_I_3II(self,_0,_1,_2):
   self.pi32 -= _0
   if (self.pi32 < 0): # src/fusion/BaseExpression.monty:89:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.i32,self.pi32,_1,_2,_0)
  @staticmethod
  def _match_popf64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popf64_(*args):
    if len(args) != 0: return False
    return True
  def _popf64_alt_(self,):
    return self._popf64_()
  def _popf64_(self,):
   self.pf64 -= 1
   if (self.pf64 < 0): # src/fusion/BaseExpression.monty:84:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.float64(self.f64[self.pf64])
  @staticmethod
  def _match_popi64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popi64_(*args):
    if len(args) != 0: return False
    return True
  def _popi64_alt_(self,):
    return self._popi64_()
  def _popi64_(self,):
   if (self.pi64 < 0): # src/fusion/BaseExpression.monty:78:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   self.pi64 -= 1
   return numpy.int64(self.i64[self.pi64])
  @staticmethod
  def _match_popi32_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_popi32_(*args):
    if len(args) != 0: return False
    return True
  def _popi32_alt_(self,):
    return self._popi32_()
  def _popi32_(self,):
   self.pi32 -= 1
   if (self.pi32 < 0): # src/fusion/BaseExpression.monty:74:12-20
    raise mosek_fusion_UnexpectedError._ctor_S("Internal: stack underflow")
   return numpy.int32(self.i32[self.pi32])
  @staticmethod
  def _match_peekf64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peekf64_(*args):
    if len(args) != 0: return False
    return True
  def _peekf64_alt_(self,):
    return self._peekf64_()
  def _peekf64_(self,):
   return numpy.float64(self.f64[(self.pf64 - 1)])
  @staticmethod
  def _match_peeki64_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peeki64_(*args):
    if len(args) != 0: return False
    return True
  def _peeki64_alt_(self,):
    return self._peeki64_()
  def _peeki64_(self,):
   return numpy.int64(self.i64[(self.pi64 - 1)])
  @staticmethod
  def _match_peeki32_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_peeki32_(*args):
    if len(args) != 0: return False
    return True
  def _peeki32_alt_(self,):
    return self._peeki32_()
  def _peeki32_(self,):
   return numpy.int32(self.i32[(self.pi32 - 1)])
  @staticmethod
  def _match_peekf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peekf64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peekf64_alt_I(self,_t__0):
    return self._peekf64_I(numpy.int32(__0))
  def _peekf64_I(self,_0):
   return numpy.float64(self.f64[((self.pf64 - _0) - 1)])
  @staticmethod
  def _match_peeki64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peeki64_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peeki64_alt_I(self,_t__0):
    return self._peeki64_I(numpy.int32(__0))
  def _peeki64_I(self,_0):
   return numpy.int64(self.i64[((self.pi64 - _0) - 1)])
  @staticmethod
  def _match_peeki32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_peeki32_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _peeki32_alt_I(self,_t__0):
    return self._peeki32_I(numpy.int32(__0))
  def _peeki32_I(self,_0):
   return numpy.int32(self.i32[((self.pi32 - _0) - 1)])
 return WorkStack
mosek_fusion_WorkStack=__mk_mosek_fusion_WorkStack()
del __mk_mosek_fusion_WorkStack
#BEFORE CLASS
def __mk_mosek_fusion_SymmetricMatrix():
 class SymmetricMatrix(object):
  __slots__ = ['_SymmetricMatrix__nnz','_SymmetricMatrix__scale','_SymmetricMatrix__vval','_SymmetricMatrix__vsubj','_SymmetricMatrix__vsubi','_SymmetricMatrix__uval','_SymmetricMatrix__usubj','_SymmetricMatrix__usubi','_SymmetricMatrix__d1','_SymmetricMatrix__d0']
  def sub(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list sub('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.sub(mosek.fusion.SymmetricMatrix)')
  def mul(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_mul_D(*args): # double
      return self._mul_D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_mul_D(*args): # double
      return self._mul_alt_D(*args)
    else:
      raise ValueError('Invalid argument list mul('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.mul(double)')
  def getdim(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_getdim_(*args): # 
      return self._getdim_(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_getdim_(*args): # 
      return self._getdim_alt_(*args)
    else:
      raise ValueError('Invalid argument list getdim('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.getdim()')
  def add(self,*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args): # mosek.fusion.SymmetricMatrix
      return self._add_alt_Lmosek_4fusion_4SymmetricMatrix_2(*args)
    else:
      raise ValueError('Invalid argument list add('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.add(mosek.fusion.SymmetricMatrix)')
  @staticmethod
  def rankOne(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._rankOne_alt__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_rankOne_I_3I_3D(*args): # int32,[]int32,[]double
      return mosek_fusion_SymmetricMatrix._rankOne_alt_I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list rankOne('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.rankOne(array(double,ndim=1))\n\tmosek.fusion.SymmetricMatrix.rankOne(int32,array(int32,ndim=1),array(double,ndim=1))')
  @staticmethod
  def antiDiag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_antiDiag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._antiDiag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list antiDiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.antiDiag(array(double,ndim=1))')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_SymmetricMatrix._match_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag__3D(*args)
    elif mosek_fusion_SymmetricMatrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_SymmetricMatrix._diag_alt__3D(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SymmetricMatrix.diag(array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.SymmetricMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    o = SymmetricMatrix.__new__(SymmetricMatrix)
    o._ctor_init_II_3I_3I_3D_3I_3I_3DD(dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_match_I__(dim0) and __arg_match_I__(dim1) and __arg_match__3I__(usubi) and __arg_match__3I__(usubj) and __arg_match__3D__(uval) and __arg_match__3I__(vsubi) and __arg_match__3I__(vsubj) and __arg_match__3D__(vval) and __arg_match_D__(scale))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D_3I_3I_3DD(*args):
    if len(args) != 9: return False
    dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale, = args
    return (__arg_alt_match_I__(dim0) and __arg_alt_match_I__(dim1) and __arg_alt_match__3I__(usubi) and __arg_alt_match__3I__(usubj) and __arg_alt_match__3D__(uval) and __arg_alt_match__3I__(vsubi) and __arg_alt_match__3I__(vsubj) and __arg_alt_match__3D__(vval) and __arg_alt_match_D__(scale))
  def _ctor_alt_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
    self._ctor_init_II_3I_3I_3D_3I_3I_3DD(numpy.int32(dim0),numpy.int32(dim1),numpy.array(usubi,dtype=numpy.dtype(numpy.int32)),numpy.array(usubj,dtype=numpy.dtype(numpy.int32)),numpy.array(uval,dtype=numpy.dtype(numpy.float64)),numpy.array(vsubi,dtype=numpy.dtype(numpy.int32)),numpy.array(vsubj,dtype=numpy.dtype(numpy.int32)),numpy.array(vval,dtype=numpy.dtype(numpy.float64)),numpy.float64(scale))
  def _ctor_init_II_3I_3I_3D_3I_3I_3DD(self,dim0,dim1,usubi,usubj,uval,vsubi,vsubj,vval,scale):
   (self.__d0) = dim0
   (self.__d1) = dim1
   (self.__usubi) = usubi
   (self.__usubj) = usubj
   (self.__uval) = uval
   (self.__vsubi) = vsubi
   (self.__vsubj) = vsubj
   (self.__vval) = vval
   (self.__scale) = scale
   self.__nnz = (- 1)
  @staticmethod
  def _match_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_rankOne_I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _rankOne_alt_I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne_I_3I_3D(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne_I_3I_3D(_0,_1,_2):
   if (int((_1).shape[0])!=int((_2).shape[0])): # src/fusion/SymmetricMatrix.monty:168:12-30
    raise mosek_fusion_LengthError._ctor_S("Mismatching array lengths")
   for _3 in range(0,int((_1).shape[0])):
    if ((_1[_3] < 0) or (_1[_3] >= _0)): # src/fusion/SymmetricMatrix.monty:172:14-39
     raise mosek_fusion_LengthError._ctor_S("Invalid index in argument 'sub'")
   _4=numpy.array([_1[_5] for _5 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([1 for _7 in range(0,int((_1).shape[0]))], dtype=numpy.dtype(numpy.int32))
   _8=numpy.array([_2[_9] for _9 in range(0,int((_2).shape[0]))], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_0,1,_4,_6,_8,_4,_6,_8,1.0))
  @staticmethod
  def _match_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_rankOne__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _rankOne_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._rankOne__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _rankOne__3D(_0):
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _4=numpy.array([1 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   _6=numpy.array([_0[_7] for _7 in range(0,_1)], dtype=numpy.dtype(numpy.float64))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,1,_2,_4,_6,_2,_4,_6,1.0))
  @staticmethod
  def _match_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antiDiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antiDiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._antiDiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antiDiag__3D(_0):
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,numpy.array([(_1 - _4) for _4 in range(0,_1)], dtype=numpy.dtype(numpy.int32)),numpy.array([_0[_5] for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _6 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_SymmetricMatrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   _1=int((_0).shape[0])
   _2=numpy.array([_3 for _3 in range(0,_1)], dtype=numpy.dtype(numpy.int32))
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(_1,_1,_2,_2,numpy.array([_0[_4] for _4 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),_2,_2,numpy.array([1.0 for _5 in range(0,_1)], dtype=numpy.dtype(numpy.float64)),1.0))
  @staticmethod
  def _match_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_add_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _add_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _add_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   _1=self._getdim_()
   if (_0._getdim_()!=_1): # src/fusion/SymmetricMatrix.monty:78:12-27
    raise mosek_fusion_DimensionError._ctor_S("Mismatching dimensions")
   _2=int((self.__usubi).shape[0])
   _3=int(((_0.__usubi)).shape[0])
   _4=(_2 + _3)
   _5=int((self.__vsubi).shape[0])
   _6=int(((_0.__vsubi)).shape[0])
   _7=(_5 + _6)
   _8=numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
   _9=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _10=numpy.zeros((_7,), dtype=numpy.dtype(numpy.int32))
   _11=numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
   _12=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   _13=numpy.zeros((_4,), dtype=numpy.dtype(numpy.int32))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_13,0,_2)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__usubi),0,_13,_2,_3)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubj,0,_12,0,_2)
   for _14 in range(0,_3):
    _12[(_14 + _2)] = ((_0.__usubj)[_14] + self.__d1)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)): # src/fusion/SymmetricMatrix.monty:101:12-38
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__uval,0,_11,0,_2)
   else:
    fragments._c_closure_593(_11,self.__scale,_2,self.__uval) # src/fusion/SymmetricMatrix.monty:104:10-60
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)): # src/fusion/SymmetricMatrix.monty:106:12-42
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__uval),0,_11,_2,_3)
   else:
    for _15 in range(0,_3):
     _11[(_15 + _2)] = ((_0.__scale) * (_0.__uval)[_15])
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__usubi,0,_13,0,_2)
   for _16 in range(0,_6):
    _10[(_16 + _5)] = ((_0.__vsubi)[_16] + (_0.__d1))
   mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__vsubj,0,_9,0,_5)
   mosek.fusion.Utils.Tools._arraycopy__3II_3III((_0.__vsubj),_5,_9,_5,_6)
   if ((self.__scale > 1.0) or (self.__scale < 1.0)): # src/fusion/SymmetricMatrix.monty:119:12-38
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self.__vval,0,_8,0,_5)
   else:
    fragments._c_closure_594(_8,self.__scale,_5,self.__vval) # src/fusion/SymmetricMatrix.monty:122:10-60
   if (((_0.__scale) > 1.0) or ((_0.__scale) < 1.0)): # src/fusion/SymmetricMatrix.monty:124:12-42
    mosek.fusion.Utils.Tools._arraycopy__3DI_3DII((_0.__vval),0,_8,_5,_6)
   else:
    for _17 in range(0,_6):
     _8[(_17 + _5)] = ((_0.__scale) * (_0.__vval)[_17])
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,(self.__d1 + (_0.__d1)),_13,_12,_11,_10,_9,_8,1.0))
  @staticmethod
  def _match_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  @staticmethod
  def _match_alt_sub_Lmosek_4fusion_4SymmetricMatrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(_0))
  def _sub_alt_Lmosek_4fusion_4SymmetricMatrix_2(self,_t__0):
    return self._sub_Lmosek_4fusion_4SymmetricMatrix_2(_0)
  def _sub_Lmosek_4fusion_4SymmetricMatrix_2(self,_0):
   return (self._add_Lmosek_4fusion_4SymmetricMatrix_2(_0._mul_D((- 1.0))))
  @staticmethod
  def _match_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_D__(_0))
  @staticmethod
  def _match_alt_mul_D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_D__(_0))
  def _mul_alt_D(self,_t__0):
    return self._mul_D(numpy.float64(__0))
  def _mul_D(self,_0):
   return (mosek_fusion_SymmetricMatrix._ctor_II_3I_3I_3D_3I_3I_3DD(self.__d0,self.__d1,self.__usubi,self.__usubj,self.__uval,self.__vsubi,self.__vsubj,self.__vval,(self.__scale * _0)))
  @staticmethod
  def _match_getdim_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getdim_(*args):
    if len(args) != 0: return False
    return True
  def _getdim_alt_(self,):
    return self._getdim_()
  def _getdim_(self,):
   return numpy.int32(self.__d0)
 return SymmetricMatrix
mosek_fusion_SymmetricMatrix=__mk_mosek_fusion_SymmetricMatrix()
del __mk_mosek_fusion_SymmetricMatrix
#BEFORE CLASS
def __mk_mosek_fusion_NDSparseArray():
 class NDSparseArray(object):
  __slots__ = ['_cof','_inst','_dims','_size']
  @staticmethod
  def make(*args):
    if False: pass
    elif mosek_fusion_NDSparseArray._match_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_NDSparseArray._make_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3J_3D(*args): # []int32,[]int64,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3J_3D(*args)
    elif mosek_fusion_NDSparseArray._match_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make__3I_3_5I_3D(*args)
    elif mosek_fusion_NDSparseArray._match_alt_make__3I_3_5I_3D(*args): # []int32,[,]int32,[]double
      return mosek_fusion_NDSparseArray._make_alt__3I_3_5I_3D(*args)
    else:
      raise ValueError('Invalid argument list make('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.NDSparseArray.make(mosek.fusion.Matrix)\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int64,ndim=1),array(double,ndim=1))\n\tmosek.fusion.NDSparseArray.make(array(int32,ndim=1),array(int32,ndim=2),array(double,ndim=1))')
  def __repr__(self): return 'mosek.fusion.NDSparseArray'
  @staticmethod
  def _ctor__3I_3_5I_3D(dims_,sub,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3_5I_3D(dims_,sub,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3_5I__(sub) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    dims_,sub,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3_5I__(sub) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3_5I_3D(self,dims_,sub,cof_):
    self._ctor_init__3I_3_5I_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(sub,dtype=numpy.dtype(numpy.int32)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3_5I_3D(self,dims_,sub,cof_):
   _0=numpy.zeros((int((sub).shape[0]),), dtype=numpy.dtype(numpy.int64))
   self._size = 1
   self._size = fragments._c_closure_595(dims_,self._size) # src/fusion/Matrix.mbi:1076:19-70
   self._size = numpy.int64(self._size) # postprocess
   _1=int((dims_).shape[0])
   if (int((sub).shape[0])!=int((cof_).shape[0])): # src/fusion/Matrix.mbi:1078:12-35
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   if (int((sub).shape[1])!=_1): # src/fusion/Matrix.mbi:1080:12-28
    raise mosek_fusion_IndexError._ctor_S("An index key in sub has wrong length")
   _2=False
   _2 = fragments._c_closure_596(dims_,_2,sub) # src/fusion/Matrix.mbi:1084:8-1089:9
   if _2: # src/fusion/Matrix.mbi:1090:12-23
    raise mosek_fusion_IndexError._ctor_S("An index in sub is out of bounds")
   fragments._c_closure_597(dims_,_0,sub) # src/fusion/Matrix.mbi:1093:8-1099:9
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _3=True
   _3 = fragments._c_closure_598(_0,_3) # src/fusion/Matrix.mbi:1103:8-83
   if _3: # src/fusion/Matrix.mbi:1105:12-20
    _4=1
    _4 = fragments._c_closure_599(_0,_4) # src/fusion/Matrix.mbi:1108:10-1110:24
    _4 = numpy.int32(_4) # postprocess
    if (_4==int((_0).shape[0])): # src/fusion/Matrix.mbi:1111:14-35
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(_0)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_4,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = _0[0]
     self._cof = numpy.zeros((_4,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _5=0
     _5 = fragments._c_closure_600(self._cof,cof_,self._inst,_0,_5) # src/fusion/Matrix.mbi:1121:12-1127:42
     _5 = numpy.int32(_5) # postprocess
   else:
    _6=mosek.fusion.Utils.Tools._range_J(int((_0).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_6,_0,None,0,int((_0).shape[0]))
    _7=1
    _7 = fragments._c_closure_601(_0,_7,_6) # src/fusion/Matrix.mbi:1135:10-1137:24
    _7 = numpy.int32(_7) # postprocess
    self._inst = numpy.zeros((_7,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = _0[_6[0]]
    self._cof = numpy.zeros((_7,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_6[0]]
    _8=0
    _8 = fragments._c_closure_602(self._cof,cof_,self._inst,_0,_8,_6) # src/fusion/Matrix.mbi:1142:10-1148:46
    _8 = numpy.int32(_8) # postprocess
  @staticmethod
  def _ctor__3I_3J_3D(dims_,inst_,cof_):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init__3I_3J_3D(dims_,inst_,cof_)
    return o
  @staticmethod
  def __match_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_match__3I__(dims_) and __arg_match__3J__(inst_) and __arg_match__3D__(cof_))
  @staticmethod
  def __match_alt_ctor__3I_3J_3D(*args):
    if len(args) != 3: return False
    dims_,inst_,cof_, = args
    return (__arg_alt_match__3I__(dims_) and __arg_alt_match__3J__(inst_) and __arg_alt_match__3D__(cof_))
  def _ctor_alt_init__3I_3J_3D(self,dims_,inst_,cof_):
    self._ctor_init__3I_3J_3D(numpy.array(dims_,dtype=numpy.dtype(numpy.int32)),numpy.array(inst_,dtype=numpy.dtype(numpy.int64)),numpy.array(cof_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3I_3J_3D(self,dims_,inst_,cof_):
   self._size = 1
   self._size = fragments._c_closure_603(dims_,self._size) # src/fusion/Matrix.mbi:1006:19-70
   self._size = numpy.int64(self._size) # postprocess
   _0=int((inst_).shape[0])
   if (_0!=int((cof_).shape[0])): # src/fusion/Matrix.mbi:1008:12-26
    raise mosek_fusion_LengthError._ctor_S("Mismatching data array length")
   _1=False
   _1 = fragments._c_closure_604(_1,inst_,_0,self._size) # src/fusion/Matrix.mbi:1012:10-1016:11
   if _1: # src/fusion/Matrix.mbi:1017:14-17
    raise mosek_fusion_IndexError._ctor_S("An index in inst is out of bounds")
   self._dims = mosek.fusion.Utils.Tools._arraycopy__3I(dims_)
   _2=True
   _2 = fragments._c_closure_605(inst_,_2) # src/fusion/Matrix.mbi:1023:8-83
   if _2: # src/fusion/Matrix.mbi:1025:12-20
    _3=1
    _3 = fragments._c_closure_606(inst_,_3) # src/fusion/Matrix.mbi:1028:10-1030:24
    _3 = numpy.int32(_3) # postprocess
    if (_3==int((inst_).shape[0])): # src/fusion/Matrix.mbi:1031:14-35
     self._inst = mosek.fusion.Utils.Tools._arraycopy__3J(inst_)
     self._cof = mosek.fusion.Utils.Tools._arraycopy__3D(cof_)
    else:
     self._inst = numpy.zeros((_3,), dtype=numpy.dtype(numpy.int64))
     self._inst[0] = inst_[0]
     self._cof = numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
     self._cof[0] = cof_[0]
     _4=0
     _4 = fragments._c_closure_607(self._cof,cof_,self._inst,inst_,_4) # src/fusion/Matrix.mbi:1041:12-1047:42
     _4 = numpy.int32(_4) # postprocess
   else:
    _5=mosek.fusion.Utils.Tools._range_J(int((inst_).shape[0]))
    mosek.fusion.CommonTools._argQsort__3J_3J_3JJJ(_5,inst_,None,0,int((inst_).shape[0]))
    _6=1
    _6 = fragments._c_closure_608(inst_,_6,_5) # src/fusion/Matrix.mbi:1055:10-1057:24
    _6 = numpy.int32(_6) # postprocess
    self._inst = numpy.zeros((_6,), dtype=numpy.dtype(numpy.int64))
    self._inst[0] = inst_[_5[0]]
    self._cof = numpy.zeros((_6,), dtype=numpy.dtype(numpy.float64))
    self._cof[0] = cof_[_5[0]]
    _7=0
    _7 = fragments._c_closure_609(self._cof,cof_,self._inst,inst_,_7,_5) # src/fusion/Matrix.mbi:1062:10-1068:46
    _7 = numpy.int32(_7) # postprocess
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m):
    o = NDSparseArray.__new__(NDSparseArray)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m):
   _0=m._numNonzeros_()
   _1=m._numColumns_()
   _2=m._numRows_()
   _3=numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
   _4=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   _5=numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   m._getDataAsTriplets__3I_3I_3D(_5,_4,_3)
   self._size = (numpy.int64(m._numRows_()) * numpy.int64(m._numColumns_()))
   self._dims = numpy.array([_2,_1], dtype=numpy.dtype(numpy.int32))
   self._inst = numpy.array([((numpy.int64(_5[_6]) * _1) + numpy.int64(_4[_6])) for _6 in range(0,_0)], dtype=numpy.dtype(numpy.int64))
   self._cof = _3
  @staticmethod
  def _match_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_make_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _make_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_NDSparseArray._make_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _make_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_NDSparseArray._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3J__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3J_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3J__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3J_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int64))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3J_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3J_3D(_0,_1,_2):
   return (mosek_fusion_NDSparseArray._ctor__3I_3J_3D(_0,_1,_2))
  @staticmethod
  def _match_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3_5I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_make__3I_3_5I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3_5I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _make_alt__3I_3_5I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,ndmin=_monty.checkShape(_t__1,2),dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_NDSparseArray._make__3I_3_5I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _make__3I_3_5I_3D(_0,_1,_2):
   return (mosek_fusion_NDSparseArray._ctor__3I_3_5I_3D(_0,_1,_2))
 return NDSparseArray
mosek_fusion_NDSparseArray=__mk_mosek_fusion_NDSparseArray()
del __mk_mosek_fusion_NDSparseArray
#BEFORE CLASS
def __mk_mosek_fusion_Matrix():
 class Matrix(object):
  __slots__ = ['_dimj','_dimi']
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_Matrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.isSparse()')
  @staticmethod
  def antidiag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3D(*args): # []double
      return mosek_fusion_Matrix._antidiag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._antidiag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_ID(*args): # int32,double
      return mosek_fusion_Matrix._antidiag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_antidiag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._antidiag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list antidiag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1))\n\tmosek.fusion.Matrix.antidiag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.antidiag(int32,double)\n\tmosek.fusion.Matrix.antidiag(int32,double,int32)')
  def numColumns(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numColumns_(*args): # 
      return self._numColumns_(*args)
    elif mosek_fusion_Matrix._match_alt_numColumns_(*args): # 
      return self._numColumns_alt_(*args)
    else:
      raise ValueError('Invalid argument list numColumns('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numColumns()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_Matrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.transpose()')
  @staticmethod
  def sparse(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._sparse_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args): # [][]mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt__3_3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._sparse_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_II(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II(*args): # int32,int32
      return mosek_fusion_Matrix._sparse_alt_II(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3I_3D(*args): # []int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse__3I_3ID(*args): # []int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt__3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3ID(*args): # int32,int32,[]int32,[]int32,double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3ID(*args)
    elif mosek_fusion_Matrix._match_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_II_3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_sparse_II_3I_3I_3D(*args): # int32,int32,[]int32,[]int32,[]double
      return mosek_fusion_Matrix._sparse_alt_II_3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list sparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.sparse(array(double,ndim=2))\n\tmosek.fusion.Matrix.sparse(array(array(mosek.fusion.Matrix,ndim=1),ndim=1))\n\tmosek.fusion.Matrix.sparse(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.sparse(int32,int32)\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))\n\tmosek.fusion.Matrix.sparse(array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),double)\n\tmosek.fusion.Matrix.sparse(int32,int32,array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  @staticmethod
  def eye(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_I(*args)
    elif mosek_fusion_Matrix._match_alt_eye_I(*args): # int32
      return mosek_fusion_Matrix._eye_alt_I(*args)
    else:
      raise ValueError('Invalid argument list eye('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.eye(int32)')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_Matrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.toString()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsArray()')
  @staticmethod
  def ones(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_II(*args)
    elif mosek_fusion_Matrix._match_alt_ones_II(*args): # int32,int32
      return mosek_fusion_Matrix._ones_alt_II(*args)
    else:
      raise ValueError('Invalid argument list ones('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.ones(int32,int32)')
  @staticmethod
  def dense(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense__3_5D(*args)
    elif mosek_fusion_Matrix._match_alt_dense__3_5D(*args): # [,]double
      return mosek_fusion_Matrix._dense_alt__3_5D(*args)
    elif mosek_fusion_Matrix._match_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_dense_Lmosek_4fusion_4Matrix_2(*args): # mosek.fusion.Matrix
      return mosek_fusion_Matrix._dense_alt_Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_IID(*args)
    elif mosek_fusion_Matrix._match_alt_dense_IID(*args): # int32,int32,double
      return mosek_fusion_Matrix._dense_alt_IID(*args)
    elif mosek_fusion_Matrix._match_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_II_3D(*args)
    elif mosek_fusion_Matrix._match_alt_dense_II_3D(*args): # int32,int32,[]double
      return mosek_fusion_Matrix._dense_alt_II_3D(*args)
    else:
      raise ValueError('Invalid argument list dense('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.dense(array(double,ndim=2))\n\tmosek.fusion.Matrix.dense(mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.dense(int32,int32,double)\n\tmosek.fusion.Matrix.dense(int32,int32,array(double,ndim=1))')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_Matrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def numRows(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numRows_(*args): # 
      return self._numRows_(*args)
    elif mosek_fusion_Matrix._match_alt_numRows_(*args): # 
      return self._numRows_alt_(*args)
    else:
      raise ValueError('Invalid argument list numRows('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numRows()')
  @staticmethod
  def diag(*args):
    if False: pass
    elif mosek_fusion_Matrix._match_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag__3D(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3D(*args): # []double
      return mosek_fusion_Matrix._diag_alt__3D(*args)
    elif mosek_fusion_Matrix._match_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args): # []mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt__3Lmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag__3DI(*args)
    elif mosek_fusion_Matrix._match_alt_diag__3DI(*args): # []double,int32
      return mosek_fusion_Matrix._diag_alt__3DI(*args)
    elif mosek_fusion_Matrix._match_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ILmosek_4fusion_4Matrix_2(*args): # int32,mosek.fusion.Matrix
      return mosek_fusion_Matrix._diag_alt_ILmosek_4fusion_4Matrix_2(*args)
    elif mosek_fusion_Matrix._match_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_ID(*args)
    elif mosek_fusion_Matrix._match_alt_diag_ID(*args): # int32,double
      return mosek_fusion_Matrix._diag_alt_ID(*args)
    elif mosek_fusion_Matrix._match_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_IDI(*args)
    elif mosek_fusion_Matrix._match_alt_diag_IDI(*args): # int32,double,int32
      return mosek_fusion_Matrix._diag_alt_IDI(*args)
    else:
      raise ValueError('Invalid argument list diag('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.diag(array(double,ndim=1))\n\tmosek.fusion.Matrix.diag(array(mosek.fusion.Matrix,ndim=1))\n\tmosek.fusion.Matrix.diag(array(double,ndim=1),int32)\n\tmosek.fusion.Matrix.diag(int32,mosek.fusion.Matrix)\n\tmosek.fusion.Matrix.diag(int32,double)\n\tmosek.fusion.Matrix.diag(int32,double,int32)')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_Matrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.get(int32,int32)')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_Matrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_Matrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Matrix.numNonzeros()')
  def __repr__(self): return 'mosek.fusion.Matrix'
  @staticmethod
  def _ctor_II(di,dj):
    o = Matrix.__new__(Matrix)
    o._ctor_init_II(di,dj)
    return o
  @staticmethod
  def __match_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_match_I__(di) and __arg_match_I__(dj))
  @staticmethod
  def __match_alt_ctor_II(*args):
    if len(args) != 2: return False
    di,dj, = args
    return (__arg_alt_match_I__(di) and __arg_alt_match_I__(dj))
  def _ctor_alt_init_II(self,di,dj):
    self._ctor_init_II(numpy.int32(di),numpy.int32(dj))
  def _ctor_init_II(self,di,dj):
   if ((di < 0) or (dj < 0)): # src/fusion/Matrix.mbi:67:12-28
    raise mosek_fusion_DimensionError._ctor_S("Invalid dimensions")
   self._dimi = di
   self._dimj = dj
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   return ("")
  def _switchDims_alt_(self,):
    return self._switchDims_()
  def _switchDims_(self,):
   _0=self._dimi
   self._dimi = self._dimj
   self._dimj = _0
  @staticmethod
  def _match_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _match_alt_diag_ILmosek_4fusion_4Matrix_2(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_Lmosek_4fusion_4Matrix_2__(_1))
  @staticmethod
  def _diag_alt_ILmosek_4fusion_4Matrix_2(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ILmosek_4fusion_4Matrix_2(numpy.int32(__0),_1)
  @staticmethod
  def _diag_ILmosek_4fusion_4Matrix_2(_0,_1):
   return (mosek.fusion.Matrix._diag__3Lmosek_4fusion_4Matrix_2(numpy.array([_1 for _2 in range(0,_0)], dtype=numpy.dtype(object))))
  @staticmethod
  def _match_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_diag__3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _diag_alt__3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(object))
   _1 = mosek_fusion_Matrix._diag__3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3Lmosek_4fusion_4Matrix_2(_0):
   _1=_0
   _2=0
   _3=0
   _4=0
   for _5 in range(0,int((_0).shape[0])):
    _4 = (_4 + (_0[_5]._dimi))
    _3 = (_3 + (_0[_5]._dimj))
    _2 = (_2 + _0[_5]._numNonzeros_())
   _6=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _8=numpy.zeros((_2,), dtype=numpy.dtype(numpy.float64))
   _9=0
   _10=0
   _11=0
   for _12 in range(0,int((_0).shape[0])):
    _13=_0[_12]._numNonzeros_()
    _14=numpy.zeros((_13,), dtype=numpy.dtype(numpy.float64))
    _15=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _16=numpy.zeros((_13,), dtype=numpy.dtype(numpy.int32))
    _0[_12]._getDataAsTriplets__3I_3I_3D(_16,_15,_14)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(_14,0,_8,_11,_13)
    fragments._c_closure_610(_13,_11,_16,_10,_9,_6,_7) # src/fusion/Matrix.mbi:535:12-539:13
    _11 = (_11 + _13)
    _10 = (_10 + (_0[_12]._dimi))
    _9 = (_9 + (_0[_12]._dimj))
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_4,_3,_6,_7,_8))
  @staticmethod
  def _match_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_antidiag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _antidiag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._antidiag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _antidiag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)): # src/fusion/Matrix.mbi:487:16-32
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)): # src/fusion/Matrix.mbi:489:16-32
    return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_antidiag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _antidiag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._antidiag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _antidiag_ID(_0,_1):
   return (mosek.fusion.Matrix._antidiag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_diag_IDI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _diag_alt_IDI(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._diag_IDI(numpy.int32(__0),numpy.float64(__1),numpy.int32(__2))
  @staticmethod
  def _diag_IDI(_0,_1,_2):
   if ((_2 < _0) and (_2 >= 0)): # src/fusion/Matrix.mbi:471:16-32
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 - _2)),_2))
   elif ((_2 > (- _0)) and (_2 < 0)): # src/fusion/Matrix.mbi:473:16-32
    return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,(_0 + _2)),_2))
   else:
    raise mosek_fusion_DimensionError._ctor_S("Diagonal index out of bounds")
  @staticmethod
  def _match_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_D__(_1))
  @staticmethod
  def _match_alt_diag_ID(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_D__(_1))
  @staticmethod
  def _diag_alt_ID(_t__0,_t__1):
    return mosek_fusion_Matrix._diag_ID(numpy.int32(__0),numpy.float64(__1))
  @staticmethod
  def _diag_ID(_0,_1):
   return (mosek.fusion.Matrix._diag__3DI(mosek.fusion.Utils.Tools._makevector_DI(_1,_0),0))
  @staticmethod
  def _match_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_antidiag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _antidiag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._antidiag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3DI(_0,_1):
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0): # src/fusion/Matrix.mbi:447:12-18
    _5=mosek.fusion.Utils.Tools._range_II(_1,(_4 + _1))
    _6=numpy.array([((_4 + _1) - _7) for _7 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    _9=numpy.array([(_4 - _10) for _10 in range(1,(_4 + 1))], dtype=numpy.dtype(numpy.int32))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_8,_9,_0))
  @staticmethod
  def _match_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_antidiag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _antidiag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._antidiag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _antidiag__3D(_0):
   return (mosek.fusion.Matrix._antidiag__3DI(_0,0))
  @staticmethod
  def _match_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match__3D__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_diag__3DI(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match__3D__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _diag_alt__3DI(_t__0,_t__1):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1=numpy.int32(_t__1)
   _1 = mosek_fusion_Matrix._diag__3DI(_0,_1)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3DI(_0,_1):
   _2=(_1 if ((_1 > 0) ) else (- _1))
   _3=(int((_0).shape[0]) + _2)
   _4=int((_0).shape[0])
   if (_1 >= 0): # src/fusion/Matrix.mbi:421:12-18
    _5=mosek.fusion.Utils.Tools._range_II(0,_4)
    _6=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_5,_6,_0))
   else:
    _7=mosek.fusion.Utils.Tools._range_II(_2,(_4 + _2))
    _8=mosek.fusion.Utils.Tools._range_II(0,_4)
    return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_3,_3,_7,_8,_0))
  @staticmethod
  def _match_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3D__(_0))
  @staticmethod
  def _match_alt_diag__3D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3D__(_0))
  @staticmethod
  def _diag_alt__3D(_t__0):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._diag__3D(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _diag__3D(_0):
   return (mosek.fusion.Matrix._diag__3DI(_0,0))
  @staticmethod
  def _match_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_ones_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _ones_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._ones_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _ones_II(_0,_1):
   return (mosek.fusion.Matrix._dense_IID(_0,_1,1.0))
  @staticmethod
  def _match_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_eye_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  @staticmethod
  def _eye_alt_I(_t__0):
    return mosek_fusion_Matrix._eye_I(numpy.int32(__0))
  @staticmethod
  def _eye_I(_0):
   return (mosek.fusion.Matrix._diag__3D(numpy.array([1.0 for _1 in range(0,_0)], dtype=numpy.dtype(numpy.float64))))
  @staticmethod
  def _match_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_dense_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _dense_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._dense_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _dense_Lmosek_4fusion_4Matrix_2(_0):
   return (mosek_fusion_DenseMatrix._ctor_Lmosek_4fusion_4Matrix_2(_0))
  @staticmethod
  def _match_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_dense_IID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _dense_alt_IID(_t__0,_t__1,_t__2):
    return mosek_fusion_Matrix._dense_IID(numpy.int32(__0),numpy.int32(__1),numpy.float64(__2))
  @staticmethod
  def _dense_IID(_0,_1,_2):
   return (mosek_fusion_DenseMatrix._ctor_IID(_0,_1,_2))
  @staticmethod
  def _match_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_dense_II_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _dense_alt_II_3D(_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense_II_3D(_0,_1,_2)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _dense_II_3D(_0,_1,_2):
   return (mosek_fusion_DenseMatrix._ctor_II_3D(_0,_1,_2))
  @staticmethod
  def _match_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_dense__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _dense_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._dense__3_5D(_0)
   return _1
  @staticmethod
  def _dense__3_5D(_0):
   return (mosek_fusion_DenseMatrix._ctor__3_5D(_0))
  @staticmethod
  def _match_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt_Lmosek_4fusion_4Matrix_2(_t__0):
    return mosek_fusion_Matrix._sparse_Lmosek_4fusion_4Matrix_2(_0)
  @staticmethod
  def _sparse_Lmosek_4fusion_4Matrix_2(_0):
   _1=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _2=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.int32))
   _3=numpy.zeros((_0._numNonzeros_(),), dtype=numpy.dtype(numpy.float64))
   _0._getDataAsTriplets__3I_3I_3D(_1,_2,_3)
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_0._numRows_(),_0._numColumns_(),_1,_2,_3))
  @staticmethod
  def _match_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _match_alt_sparse__3_3Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(_0))
  @staticmethod
  def _sparse_alt__3_3Lmosek_4fusion_4Matrix_2(_t__0):
   _0=_monty.makeJaggedArray(_t__0,(1,1),numpy.dtype(object))
   _1 = mosek_fusion_Matrix._sparse__3_3Lmosek_4fusion_4Matrix_2(_0)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3_3Lmosek_4fusion_4Matrix_2(_0):
   _1=int((_0).shape[0])
   _2=int((_0[0]).shape[0])
   _3=numpy.zeros((_1,), dtype=numpy.dtype(numpy.int32))
   _4=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
   _5=0
   _6=0
   _7=0
   while (_7 < _1):
    _8=0
    while (_8 < _2):
     _9=_0[_7][_8]
     if (_9 is not None): # src/fusion/Matrix.mbi:247:21-30
      if (_4[_8]==0): # src/fusion/Matrix.mbi:249:23-36
       _4[_8] = (_9._dimj)
      elif (_4[_8]!=(_9._dimj)): # src/fusion/Matrix.mbi:253:23-41
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      if (_3[_7]==0): # src/fusion/Matrix.mbi:258:23-36
       _3[_7] = (_9._dimi)
      elif (_3[_7]!=(_9._dimi)): # src/fusion/Matrix.mbi:262:23-41
       raise mosek_fusion_SparseFormatError._ctor_S("Sparse matrix construction blocks are not aligned")
      _5 = (_5 + _9._numNonzeros_())
     _6 += 1
     _8 += 1
    _7 += 1
   _10=numpy.zeros((_5,), dtype=numpy.dtype(numpy.float64))
   _11=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _12=numpy.zeros((_5,), dtype=numpy.dtype(numpy.int32))
   _13=0
   _14=0
   _15=0
   while (_15 < _1):
    _16=numpy.zeros((_2,), dtype=numpy.dtype(numpy.int32))
    _17=0
    while (_17 < _3[_15]):
     _18=0
     _19=0
     while (_19 < _2):
      _20=_0[_15][_19]
      if (_20 is not None): # src/fusion/Matrix.mbi:315:23-33
       _22=_20
       if   isinstance(_22,mosek_fusion_DenseMatrix):
        m=_22
        _22=_16[_19]
        _23=0
        while (_23 < (m._dimj)):
         _10[_13] = (m._data)[_22]
         _11[_13] = (_14 + _17)
         _12[_13] = (_18 + _23)
         _22 += 1
         _13 += 1
         _23 += 1
        _16[_19] = _22
       elif isinstance(_22,mosek_fusion_SparseMatrix):
        _24=_22
        _25 = _16[_19]
        while ((_25 < (_24._nnz)) and ((_24._subi)[_25]==_17)):
         _10[_13] = (_24._val)[_25]
         _12[_13] = ((_24._subj)[_25] + _18)
         _11[_13] = (_14 + _17)
         _13 += 1
         _25 += 1
        _16[_19] = _25
       else:
        m=_22
        raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
      _18 = (_18 + _4[_19])
      _19 += 1
     _17 += 1
    _14 = (_14 + _3[_15])
    _15 += 1
   _26=0
   _27=0
   _26 = fragments._c_closure_611(_26,_3,_1) # src/fusion/Matrix.mbi:361:8-364:9
   _26 = numpy.int32(_26) # postprocess
   _27 = fragments._c_closure_612(_27,_4,_2) # src/fusion/Matrix.mbi:365:8-368:9
   _27 = numpy.int32(_27) # postprocess
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_26,_27,_11,_12,_10))
  @staticmethod
  def _match_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match__3_5D__(_0))
  @staticmethod
  def _match_alt_sparse__3_5D(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match__3_5D__(_0))
  @staticmethod
  def _sparse_alt__3_5D(_t__0):
   _0=numpy.array(_t__0,ndmin=_monty.checkShape(_t__0,2),dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3_5D(_0)
   return _1
  @staticmethod
  def _sparse__3_5D(_0):
   _1=int((_0).shape[0])
   _2=int((_0).shape[1])
   _3=numpy.int64((_1 * _2))
   _4=0
   _5=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _6=numpy.zeros((_3,), dtype=numpy.dtype(numpy.int32))
   _7=numpy.zeros((_3,), dtype=numpy.dtype(numpy.float64))
   _4 = fragments._c_closure_613(_0,_1,_2,_4,_5,_6,_7) # src/fusion/Matrix.mbi:218:8-225:13
   _4 = numpy.int32(_4) # postprocess
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3D(_1,_2,_5,_6,_7))
  @staticmethod
  def _match_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_sparse_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  @staticmethod
  def _sparse_alt_II(_t__0,_t__1):
    return mosek_fusion_Matrix._sparse_II(numpy.int32(__0),numpy.int32(__1))
  @staticmethod
  def _sparse_II(_0,_1):
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)),numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)),0))
  @staticmethod
  def _match_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match_D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3ID(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match_D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3ID(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.float64(_t__4)
   _1 = mosek_fusion_Matrix._sparse_II_3I_3ID(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3ID(_0,_1,_2,_3,_4):
   _5=0
   if (_2 is not None): # src/fusion/Matrix.mbi:196:16-28
    _5 = int((_2).shape[0])
   elif (_3 is not None): # src/fusion/Matrix.mbi:197:16-28
    _5 = int((_3).shape[0])
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,mosek.fusion.Utils.Tools._makevector_DI(_4,_5)))
  @staticmethod
  def _match_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3ID(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _sparse_alt__3I_3ID(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.float64(_t__2)
   _1 = mosek_fusion_Matrix._sparse__3I_3ID(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3ID(_0,_1,_2):
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])): # src/fusion/Matrix.mbi:177:12-27
    _5 = int((_1).shape[0])
   _4,_3 = fragments._c_closure_614(_4,_3,_5,_0,_1) # src/fusion/Matrix.mbi:179:8-183:9
   _4 = numpy.int32(_4) # postprocess
   _3 = numpy.int32(_3) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3ID((_4 + 1),(_3 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_sparse__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  @staticmethod
  def _sparse_alt__3I_3I_3D(_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse__3I_3I_3D(_0,_1,_2):
   _3=0
   _4=0
   _5=int((_0).shape[0])
   if (_5 > int((_1).shape[0])): # src/fusion/Matrix.mbi:158:12-27
    _5 = int((_1).shape[0])
   if (_5 > int((_2).shape[0])): # src/fusion/Matrix.mbi:159:12-26
    _5 = int((_2).shape[0])
   _4,_3 = fragments._c_closure_615(_4,_3,_5,_0,_1) # src/fusion/Matrix.mbi:161:8-165:9
   _4 = numpy.int32(_4) # postprocess
   _3 = numpy.int32(_3) # postprocess
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D((_4 + 1),(_3 + 1),_0,_1,_2))
  @staticmethod
  def _match_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match__3I__(_3) and __arg_match__3D__(_4))
  @staticmethod
  def _match_alt_sparse_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    _0,_1,_2,_3,_4, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match__3I__(_3) and __arg_alt_match__3D__(_4))
  @staticmethod
  def _sparse_alt_II_3I_3I_3D(_t__0,_t__1,_t__2,_t__3,_t__4):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.array(_t__3,dtype=numpy.dtype(numpy.int32))
   _4=numpy.array(_t__4,dtype=numpy.dtype(numpy.float64))
   _1 = mosek_fusion_Matrix._sparse_II_3I_3I_3D(_0,_1,_2,_3,_4)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__3[:] = _3
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__4[:] = _4
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  @staticmethod
  def _sparse_II_3I_3I_3D(_0,_1,_2,_3,_4):
   _5=(_4 if ((_4 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.float64)))
   _6=(_3 if ((_3 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _7=(_2 if ((_2 is not None) ) else numpy.zeros((0,), dtype=numpy.dtype(numpy.int32)))
   _8=int((_7).shape[0])
   if ((int((_6).shape[0])!=_8) or (int((_5).shape[0])!=_8)): # src/fusion/Matrix.mbi:140:17-141:35
    raise mosek_fusion_SparseFormatError._ctor_S("Arrays defining sparse data have different lengths")
   return (mosek_fusion_SparseMatrix._ctor_II_3I_3I_3DJ(_0,_1,_7,_6,_5,_8))
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   pass
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   pass
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   pass
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   pass
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   pass
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   pass
  @staticmethod
  def _match_numColumns_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numColumns_(*args):
    if len(args) != 0: return False
    return True
  def _numColumns_alt_(self,):
    return self._numColumns_()
  def _numColumns_(self,):
   return numpy.int32(self._dimj)
  @staticmethod
  def _match_numRows_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numRows_(*args):
    if len(args) != 0: return False
    return True
  def _numRows_alt_(self,):
    return self._numRows_()
  def _numRows_(self,):
   return numpy.int32(self._dimi)
 return Matrix
mosek_fusion_Matrix=__mk_mosek_fusion_Matrix()
del __mk_mosek_fusion_Matrix
#BEFORE CLASS
def __mk_mosek_fusion_DenseMatrix():
 class DenseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_data']
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.toString()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.transpose()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.getDataAsArray()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_DenseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.get(int32,int32)')
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.isSparse()')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_DenseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_DenseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.DenseMatrix.numNonzeros()')
  def __repr__(self): return 'mosek.fusion.DenseMatrix'
  @staticmethod
  def _ctor_II_3D(dimi_,dimj_,cof):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_II_3D(dimi_,dimj_,cof)
    return o
  @staticmethod
  def __match_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3D__(cof))
  @staticmethod
  def __match_alt_ctor_II_3D(*args):
    if len(args) != 3: return False
    dimi_,dimj_,cof, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3D__(cof))
  def _ctor_alt_init_II_3D(self,dimi_,dimj_,cof):
    self._ctor_init_II_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(cof,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3D(self,dimi_,dimj_,cof):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._nnz = numpy.int64((dimi_ * dimj_))
   self._data = numpy.zeros(((dimi_ * dimj_),), dtype=numpy.dtype(numpy.float64))
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(cof,0,self._data,0,(dimi_ * dimj_))
  @staticmethod
  def _ctor_Lmosek_4fusion_4Matrix_2(m_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_match_Lmosek_4fusion_4Matrix_2__(m_))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4Matrix_2(*args):
    if len(args) != 1: return False
    m_, = args
    return (__arg_alt_match_Lmosek_4fusion_4Matrix_2__(m_))
  def _ctor_alt_init_Lmosek_4fusion_4Matrix_2(self,m_):
    self._ctor_init_Lmosek_4fusion_4Matrix_2(m_)
  def _ctor_init_Lmosek_4fusion_4Matrix_2(self,m_):
   mosek_fusion_Matrix._ctor_init_II(self,(m_._dimi),(m_._dimj))
   _1=m_
   if   isinstance(_1,mosek_fusion_DenseMatrix):
    m=_1
    self._data = mosek.fusion.Utils.Tools._arraycopy__3D((m._data))
   elif isinstance(_1,mosek_fusion_SparseMatrix):
    _1=_1
    self._data = mosek.fusion.Utils.Tools._zeros_I(((_1._dimi) * (_1._dimj)))
    for _2 in range(0,(_1._nnz)):
     self._data[(((_1._subi)[_2] * self._dimj) + (_1._subj)[_2])] = (_1._val)[_2]
   else:
    m=_1
    raise mosek_fusion_MatrixError._ctor_S("Unknown matrix type.")
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor__3_5D(d):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init__3_5D(d)
    return o
  @staticmethod
  def __match_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_match__3_5D__(d))
  @staticmethod
  def __match_alt_ctor__3_5D(*args):
    if len(args) != 1: return False
    d, = args
    return (__arg_alt_match__3_5D__(d))
  def _ctor_alt_init__3_5D(self,d):
    self._ctor_init__3_5D(numpy.array(d,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init__3_5D(self,d):
   mosek_fusion_Matrix._ctor_init_II(self,int((d).shape[0]),int((d).shape[1]))
   self._data = numpy.array([d[_0,_1] for _0 in range(0,self._dimi) for _1 in range(0,self._dimj)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((self._dimi * self._dimj))
  @staticmethod
  def _ctor_IID(dimi_,dimj_,value_):
    o = DenseMatrix.__new__(DenseMatrix)
    o._ctor_init_IID(dimi_,dimj_,value_)
    return o
  @staticmethod
  def __match_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match_D__(value_))
  @staticmethod
  def __match_alt_ctor_IID(*args):
    if len(args) != 3: return False
    dimi_,dimj_,value_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match_D__(value_))
  def _ctor_alt_init_IID(self,dimi_,dimj_,value_):
    self._ctor_init_IID(numpy.int32(dimi_),numpy.int32(dimj_),numpy.float64(value_))
  def _ctor_init_IID(self,dimi_,dimj_,value_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   self._data = numpy.array([value_ for _0 in range(0,dimi_) for _1 in range(0,dimj_)], dtype=numpy.dtype(numpy.float64))
   self._nnz = numpy.int64((dimi_ * dimj_))
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("DenseMatrix(")
   _0._a_I(self._dimi)
   _0._a_S(",")
   _0._a_I(self._dimj)
   _0._a_S(": ")
   _1=0
   _2=0
   while (_2 < self._dimi):
    if (_2 > 0): # src/fusion/Matrix.mbi:947:19-24
     _0._a_S(",")
    _0._a_S("[ ")
    _0._a_D(self._data[_1])
    _1 += 1
    _3=1
    while (_3 < self._dimj):
     _0._a_S(",")
     _0._a_D(self._data[_1])
     _1 += 1
     _3 += 1
    _0._a_S(" ]")
    _2 += 1
   _0._a_S(")")
   return (_0._toString_())
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   _1=0
   _2=self._dimi
   _1 = fragments._c_closure_616(self._data,self._dimi,self._dimj,_0,_1,_2) # src/fusion/Matrix.mbi:926:8-936:9
   _1 = numpy.int32(_1) # postprocess
   return (mosek_fusion_DenseMatrix._ctor_II_3D(self._dimj,self._dimi,_0))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (False)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   return (mosek.fusion.Utils.Tools._arraycopy__3D(self._data))
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))): # src/fusion/Matrix.mbi:817:12-819:27
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   mosek.fusion.Utils.Tools._arraycopy__3DI_3DII(self._data,0,_2,0,int((self._data).shape[0]))
   _3=0
   _3 = fragments._c_closure_617(self._dimi,self._dimj,_3,_0,_1) # src/fusion/Matrix.mbi:826:8-834:9
   _3 = numpy.int32(_3) # postprocess
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   return numpy.float64(self._data[((_0 * self._dimj) + _1)])
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(numpy.int64((self._dimi * self._dimj)))
 return DenseMatrix
mosek_fusion_DenseMatrix=__mk_mosek_fusion_DenseMatrix()
del __mk_mosek_fusion_DenseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_SparseMatrix():
 class SparseMatrix(mosek_fusion_Matrix):
  __slots__ = ['_nnz','_val','_subj','_subi']
  def isSparse(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_isSparse_(*args): # 
      return self._isSparse_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_isSparse_(*args): # 
      return self._isSparse_alt_(*args)
    else:
      raise ValueError('Invalid argument list isSparse('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.isSparse()')
  def getDataAsTriplets(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets__3I_3I_3D(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsTriplets__3I_3I_3D(*args): # []int32,[]int32,[]double
      return self._getDataAsTriplets_alt__3I_3I_3D(*args)
    else:
      raise ValueError('Invalid argument list getDataAsTriplets('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsTriplets(array(int32,ndim=1),array(int32,ndim=1),array(double,ndim=1))')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_get_II(*args): # int32,int32
      return self._get_II(*args)
    elif mosek_fusion_SparseMatrix._match_alt_get_II(*args): # int32,int32
      return self._get_alt_II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.get(int32,int32)')
  def numNonzeros(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_numNonzeros_(*args): # 
      return self._numNonzeros_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_numNonzeros_(*args): # 
      return self._numNonzeros_alt_(*args)
    else:
      raise ValueError('Invalid argument list numNonzeros('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.numNonzeros()')
  def toString(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_toString_(*args): # 
      return self._toString_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_toString_(*args): # 
      return self._toString_alt_(*args)
    else:
      raise ValueError('Invalid argument list toString('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.toString()')
  def transpose(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_transpose_(*args): # 
      return self._transpose_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_transpose_(*args): # 
      return self._transpose_alt_(*args)
    else:
      raise ValueError('Invalid argument list transpose('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.transpose()')
  def getDataAsArray(self,*args):
    if False: pass
    elif mosek_fusion_SparseMatrix._match_getDataAsArray_(*args): # 
      return self._getDataAsArray_(*args)
    elif mosek_fusion_SparseMatrix._match_alt_getDataAsArray_(*args): # 
      return self._getDataAsArray_alt_(*args)
    else:
      raise ValueError('Invalid argument list getDataAsArray('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.SparseMatrix.getDataAsArray()')
  def __repr__(self): return 'mosek.fusion.SparseMatrix'
  @staticmethod
  def _ctor_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3DJ(dimi_,dimj_,subi_,subj_,val_,nelm)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_) and __arg_match_J__(nelm))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3DJ(*args):
    if len(args) != 6: return False
    dimi_,dimj_,subi_,subj_,val_,nelm, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_) and __arg_alt_match_J__(nelm))
  def _ctor_alt_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
    self._ctor_init_II_3I_3I_3DJ(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)),numpy.int64(nelm))
  def _ctor_init_II_3I_3I_3DJ(self,dimi_,dimj_,subi_,subj_,val_,nelm):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   if (nelm > 0): # src/fusion/Matrix.mbi:680:17-25
    if ((int((subi_).shape[0]) < nelm) or ((int((subj_).shape[0]) < nelm) or (int((val_).shape[0]) < nelm))): # src/fusion/Matrix.mbi:682:19-684:36
     raise mosek_fusion_SparseFormatError._ctor_S("Mismatching arrays in sparse data.")
    _0=False
    _0 = fragments._c_closure_618(self._dimi,self._dimj,nelm,_0,subi_,subj_) # src/fusion/Matrix.mbi:689:10-692:33
    if _0: # src/fusion/Matrix.mbi:694:14-25
     raise mosek_fusion_SparseFormatError._ctor_S("Subscript out of bounds.")
    _1=numpy.ndarray((1,), dtype=numpy.dtype(object))
    _2=numpy.ndarray((1,), dtype=numpy.dtype(object))
    _3=numpy.ndarray((1,), dtype=numpy.dtype(object))
    mosek.fusion.CommonTools._tripletSort__3I_3I_3D_3_3I_3_3I_3_3DJII(subi_,subj_,val_,_1,_2,_3,nelm,self._dimi,self._dimj)
    self._subi = _1[0]
    self._subj = _2[0]
    self._val = _3[0]
    self._nnz = int((self._val).shape[0])
   else:
    self._subi = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = 0
  @staticmethod
  def _ctor_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_):
    o = SparseMatrix.__new__(SparseMatrix)
    o._ctor_init_II_3I_3I_3D(dimi_,dimj_,subi_,subj_,val_)
    return o
  @staticmethod
  def __match_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_match_I__(dimi_) and __arg_match_I__(dimj_) and __arg_match__3I__(subi_) and __arg_match__3I__(subj_) and __arg_match__3D__(val_))
  @staticmethod
  def __match_alt_ctor_II_3I_3I_3D(*args):
    if len(args) != 5: return False
    dimi_,dimj_,subi_,subj_,val_, = args
    return (__arg_alt_match_I__(dimi_) and __arg_alt_match_I__(dimj_) and __arg_alt_match__3I__(subi_) and __arg_alt_match__3I__(subj_) and __arg_alt_match__3D__(val_))
  def _ctor_alt_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
    self._ctor_init_II_3I_3I_3D(numpy.int32(dimi_),numpy.int32(dimj_),numpy.array(subi_,dtype=numpy.dtype(numpy.int32)),numpy.array(subj_,dtype=numpy.dtype(numpy.int32)),numpy.array(val_,dtype=numpy.dtype(numpy.float64)))
  def _ctor_init_II_3I_3I_3D(self,dimi_,dimj_,subi_,subj_,val_):
   mosek_fusion_Matrix._ctor_init_II(self,dimi_,dimj_)
   _0=0
   _0 = fragments._c_closure_619(_0,val_) # src/fusion/Matrix.mbi:625:19-88
   _0 = numpy.int32(_0) # postprocess
   if ((_0 > 0) and (_0 < int((subi_).shape[0]))): # src/fusion/Matrix.mbi:627:12-36
    self._subi = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._subj = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
    self._val = numpy.zeros((_0,), dtype=numpy.dtype(numpy.float64))
    self._nnz = _0
    _1=0
    _1 = fragments._c_closure_620(_1,self._subi,subi_,self._subj,subj_,self._val,val_) # src/fusion/Matrix.mbi:634:10-641:13
    _1 = numpy.int32(_1) # postprocess
   else:
    self._subi = subi_
    self._subj = subj_
    self._val = val_
    if (subi_ is None): # src/fusion/Matrix.mbi:648:19-32
     self._nnz = 0
    else:
     self._nnz = int((self._subi).shape[0])
  def _formPtrb_alt_(self,):
    return self._formPtrb_()
  def _formPtrb_(self,):
   _0=numpy.zeros(((self._dimi + 1),), dtype=numpy.dtype(numpy.int64))
   _1=0
   _1 = fragments._c_closure_621(self._dimi,self._nnz,_1,_0,self._subi) # src/fusion/Matrix.mbi:779:8-785:9
   _1 = numpy.int64(_1) # postprocess
   _0[self._dimi] = _1
   return (_0)
  @staticmethod
  def _match_toString_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_toString_(*args):
    if len(args) != 0: return False
    return True
  def _toString_alt_(self,):
    return self._toString_()
  def _toString_(self,):
   _0=mosek.fusion.Utils.StringBuffer()
   _0._a_S("SparseMatrix(")._a_I(self._dimi)._a_S(",")._a_I(self._dimj)._a_S(", [")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)): # src/fusion/Matrix.mbi:764:12-42
    _0._a_S("(")._a_I(self._subi[0])._a_S(",")._a_I(self._subj[0])._a_S(",")._a_D(self._val[0])._a_S(")")
    for _1 in range(1,int((self._subi).shape[0])):
     _0._a_S(",(")._a_I(self._subi[_1])._a_S(",")._a_I(self._subj[_1])._a_S(",")._a_D(self._val[_1])._a_S(")")
   _0._a_S(" ])")
   return (_0._toString_())
  @staticmethod
  def _match_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numNonzeros_(*args):
    if len(args) != 0: return False
    return True
  def _numNonzeros_alt_(self,):
    return self._numNonzeros_()
  def _numNonzeros_(self,):
   return numpy.int64(self._nnz)
  @staticmethod
  def _match_transpose_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_transpose_(*args):
    if len(args) != 0: return False
    return True
  def _transpose_alt_(self,):
    return self._transpose_()
  def _transpose_(self,):
   return (mosek.fusion.Matrix._sparse_II_3I_3I_3D(self._dimj,self._dimi,self._subj,self._subi,self._val))
  @staticmethod
  def _match_isSparse_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_isSparse_(*args):
    if len(args) != 0: return False
    return True
  def _isSparse_alt_(self,):
    return self._isSparse_()
  def _isSparse_(self,):
   return (True)
  @staticmethod
  def _match_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_getDataAsArray_(*args):
    if len(args) != 0: return False
    return True
  def _getDataAsArray_alt_(self,):
    return self._getDataAsArray_()
  def _getDataAsArray_(self,):
   _0=numpy.zeros(((self._dimi * self._dimj),), dtype=numpy.dtype(numpy.float64))
   fragments._c_closure_622(self._dimj,_0,self._subi,self._subj,self._val) # src/fusion/Matrix.mbi:740:8-741:45
   return (_0)
  @staticmethod
  def _match_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match__3I__(_0) and __arg_match__3I__(_1) and __arg_match__3D__(_2))
  @staticmethod
  def _match_alt_getDataAsTriplets__3I_3I_3D(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match__3I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match__3D__(_2))
  def _getDataAsTriplets_alt__3I_3I_3D(self,_t__0,_t__1,_t__2):
   _0=numpy.array(_t__0,dtype=numpy.dtype(numpy.int32))
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.float64))
   _1 = self._getDataAsTriplets__3I_3I_3D(_0,_1,_2)
   try:
     _t__0[:] = _0
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _getDataAsTriplets__3I_3I_3D(self,_0,_1,_2):
   if ((int((_0).shape[0]) < self._nnz) or ((int((_1).shape[0]) < self._nnz) or (int((_2).shape[0]) < self._nnz))): # src/fusion/Matrix.mbi:722:12-724:32
    raise mosek_fusion_LengthError._ctor_S("Output arrays are not long enough.")
   if ((self._subi is not None) and (int((self._subi).shape[0]) > 0)): # src/fusion/Matrix.mbi:729:12-42
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subi,0,_0,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3IJ_3IJJ(self._subj,0,_1,0,self._nnz)
    mosek.fusion.Utils.Tools._arraycopy__3DJ_3DJJ(self._val,0,_2,0,self._nnz)
  @staticmethod
  def _match_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_get_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _get_alt_II(self,_t__0,_t__1):
    return self._get_II(numpy.int32(__0),numpy.int32(__1))
  def _get_II(self,_0,_1):
   if ((_0 < 0) or ((_0 >= self._dimi) or ((_1 < 0) or (_1 >= self._dimj)))): # src/fusion/Matrix.mbi:590:13-591:31
    raise mosek_fusion_IndexError._ctor_S("Index out if bounds")
   _2=int((self._subi).shape[0])
   _3=0
   while ((_2 - _3) > 1):
    _4=((_3 + _2) // 2)
    if ((self._subi[_4] < _0) or ((self._subi[_4]==_0) and (self._subj[_4] < _1))): # src/fusion/Matrix.mbi:599:18-63
     _3 = _4
    elif ((self._subi[_4] > _0) or ((self._subi[_4]==_0) and (self._subj[_4] > _1))): # src/fusion/Matrix.mbi:600:18-63
     _2 = _4
    else:
     return numpy.float64(self._val[_4])
   if ((self._subi[_3]==_0) and (self._subj[_3]==_1)): # src/fusion/Matrix.mbi:604:12-41
    return numpy.float64(self._val[_3])
   else:
    return numpy.float64(0.0)
 return SparseMatrix
mosek_fusion_SparseMatrix=__mk_mosek_fusion_SparseMatrix()
del __mk_mosek_fusion_SparseMatrix
#BEFORE CLASS
def __mk_mosek_fusion_LinkedBlocks():
 class LinkedBlocks(object):
  __slots__ = ['_LinkedBlocks__bfirst','_LinkedBlocks__bsize','_LinkedBlocks__blocks','_LinkedBlocks__ints']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args): # mosek.fusion.LinkedBlocks
      self._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):# mosek.fusion.LinkedBlocks
      self._ctor_alt_init_Lmosek_4fusion_4LinkedBlocks_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LinkedBlocks.ctor()\n\tmosek.fusion.LinkedBlocks.ctor(int32)\n\tmosek.fusion.LinkedBlocks.ctor(mosek.fusion.LinkedBlocks)')
  def alloc(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_alloc_I(*args): # int32
      return self._alloc_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_alloc_I(*args): # int32
      return self._alloc_alt_I(*args)
    else:
      raise ValueError('Invalid argument list alloc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.alloc(int32)')
  def numblocks(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_numblocks_(*args): # 
      return self._numblocks_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_numblocks_(*args): # 
      return self._numblocks_alt_(*args)
    else:
      raise ValueError('Invalid argument list numblocks('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.numblocks()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_get_I_3II(*args): # int32,[]int32,int32
      return self._get_I_3II(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_get_I_3II(*args): # int32,[]int32,int32
      return self._get_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.get(int32,array(int32,ndim=1),int32)')
  def block_capacity(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_block_1capacity_(*args): # 
      return self._block_1capacity_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_block_1capacity_(*args): # 
      return self._block_1capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list block_capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.block_capacity()')
  def free(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_free_I(*args): # int32
      return self._free_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_free_I(*args): # int32
      return self._free_alt_I(*args)
    else:
      raise ValueError('Invalid argument list free('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.free(int32)')
  def maxidx(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_maxidx_I(*args): # int32
      return self._maxidx_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_maxidx_I(*args): # int32
      return self._maxidx_alt_I(*args)
    else:
      raise ValueError('Invalid argument list maxidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.maxidx(int32)')
  def validate(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_validate_(*args): # 
      return self._validate_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_validate_(*args): # 
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.validate()')
  def numallocated(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_numallocated_(*args): # 
      return self._numallocated_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_numallocated_(*args): # 
      return self._numallocated_alt_(*args)
    else:
      raise ValueError('Invalid argument list numallocated('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.numallocated()')
  def blocksize(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_blocksize_I(*args): # int32
      return self._blocksize_I(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_blocksize_I(*args): # int32
      return self._blocksize_alt_I(*args)
    else:
      raise ValueError('Invalid argument list blocksize('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.blocksize(int32)')
  def capacity(self,*args):
    if False: pass
    elif mosek_fusion_LinkedBlocks._match_capacity_(*args): # 
      return self._capacity_(*args)
    elif mosek_fusion_LinkedBlocks._match_alt_capacity_(*args): # 
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedBlocks.capacity()')
  def __repr__(self): return 'mosek.fusion.LinkedBlocks'
  @staticmethod
  def _ctor_():
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_LinkedBlocks._ctor_init_I(self,0)
  @staticmethod
  def _ctor_I(n):
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_I(n)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    n, = args
    return (__arg_match_I__(n))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    n, = args
    return (__arg_alt_match_I__(n))
  def _ctor_alt_init_I(self,n):
    self._ctor_init_I(numpy.int32(n))
  def _ctor_init_I(self,n):
   self.__ints = mosek_fusion_LinkedInts._ctor_I(n)
   self.__blocks = mosek_fusion_LinkedInts._ctor_I(128)
   self.__bsize = numpy.zeros((128,), dtype=numpy.dtype(numpy.int32))
   self.__bfirst = numpy.zeros((128,), dtype=numpy.dtype(numpy.int32))
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinkedBlocks_2(other):
    o = LinkedBlocks.__new__(LinkedBlocks)
    o._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinkedBlocks_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinkedBlocks_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinkedBlocks_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinkedBlocks_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinkedBlocks_2(other)
  def _ctor_init_Lmosek_4fusion_4LinkedBlocks_2(self,other):
   self.__ints = mosek_fusion_LinkedInts._ctor_Lmosek_4fusion_4LinkedInts_2((other.__ints))
   self.__blocks = mosek_fusion_LinkedInts._ctor_Lmosek_4fusion_4LinkedInts_2((other.__blocks))
   self.__bsize = mosek.fusion.Utils.Tools._arraycopy__3I((other.__bsize))
   self.__bfirst = mosek.fusion.Utils.Tools._arraycopy__3I((other.__bfirst))
  @staticmethod
  def _match_free_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_free_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _free_alt_I(self,_t__0):
    return self._free_I(numpy.int32(__0))
  def _free_I(self,_0):
   _1=self.__bfirst[_0]
   self.__ints._free_II(_1,self.__bsize[_0])
   self.__bsize[_0] = (- 1)
   self.__bfirst[_0] = (- 1)
   self.__blocks._free_II(_0,1)
  @staticmethod
  def _match_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloc_alt_I(self,_t__0):
    return self._alloc_I(numpy.int32(__0))
  def _alloc_I(self,_0):
   _1=(self.__ints._alloc_I(_0) if ((_0 > 0) ) else (- 1))
   _2=self.__blocks._alloc_()
   if (self.__blocks._capacity_() > int((self.__bsize).shape[0])): # src/fusion/LinkedList.monty:247:12-42
    _3=numpy.zeros((self.__blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    _4=numpy.zeros((self.__blocks._capacity_(),), dtype=numpy.dtype(numpy.int32))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__bsize,0,_3,0,int((self.__bsize).shape[0]))
    mosek.fusion.Utils.Tools._arraycopy__3II_3III(self.__bfirst,0,_4,0,int((self.__bfirst).shape[0]))
    self.__bsize = _3
    self.__bfirst = _4
   self.__bfirst[_2] = _1
   self.__bsize[_2] = _0
   return numpy.int32(_2)
  @staticmethod
  def _match_maxidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_maxidx_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _maxidx_alt_I(self,_t__0):
    return self._maxidx_I(numpy.int32(__0))
  def _maxidx_I(self,_0):
   return numpy.int32(self.__ints._maxidx_II(self.__bfirst[_0],self.__bsize[_0]))
  @staticmethod
  def _match_numallocated_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numallocated_(*args):
    if len(args) != 0: return False
    return True
  def _numallocated_alt_(self,):
    return self._numallocated_()
  def _numallocated_(self,):
   return numpy.int32(self.__ints._numallocated_())
  @staticmethod
  def _match_get_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_get_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _get_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._get_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _get_I_3II(self,_0,_1,_2):
   self.__ints._get_II_3II(self.__bfirst[_0],self.__bsize[_0],_1,_2)
  @staticmethod
  def _match_numblocks_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numblocks_(*args):
    if len(args) != 0: return False
    return True
  def _numblocks_alt_(self,):
    return self._numblocks_()
  def _numblocks_(self,):
   return numpy.int32(int((self.__bsize).shape[0]))
  @staticmethod
  def _match_blocksize_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_blocksize_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _blocksize_alt_I(self,_t__0):
    return self._blocksize_I(numpy.int32(__0))
  def _blocksize_I(self,_0):
   return numpy.int32(self.__bsize[_0])
  @staticmethod
  def _match_block_1capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_block_1capacity_(*args):
    if len(args) != 0: return False
    return True
  def _block_1capacity_alt_(self,):
    return self._block_1capacity_()
  def _block_1capacity_(self,):
   return numpy.int32(self.__blocks._capacity_())
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(self.__ints._capacity_())
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   return ((self.__ints._validate_() and self.__blocks._validate_()))
 return LinkedBlocks
mosek_fusion_LinkedBlocks=__mk_mosek_fusion_LinkedBlocks()
del __mk_mosek_fusion_LinkedBlocks
#BEFORE CLASS
def __mk_mosek_fusion_LinkedInts():
 class LinkedInts(object):
  __slots__ = ['_LinkedInts__nfree','_LinkedInts__last_free','_LinkedInts__first_free','_LinkedInts__first_used','_LinkedInts__prev','_LinkedInts__next']
  def __init__(self,*args):
    if False: pass
    elif self.__match_ctor_(*args): # 
      self._ctor_init_(*args)
    elif self.__match_alt_ctor_(*args):# 
      self._ctor_alt_init_(*args)
    elif self.__match_ctor_I(*args): # int32
      self._ctor_init_I(*args)
    elif self.__match_alt_ctor_I(*args):# int32
      self._ctor_alt_init_I(*args)
    elif self.__match_ctor_Lmosek_4fusion_4LinkedInts_2(*args): # mosek.fusion.LinkedInts
      self._ctor_init_Lmosek_4fusion_4LinkedInts_2(*args)
    elif self.__match_alt_ctor_Lmosek_4fusion_4LinkedInts_2(*args):# mosek.fusion.LinkedInts
      self._ctor_alt_init_Lmosek_4fusion_4LinkedInts_2(*args)
    else:
      raise ValueError('Invalid argument list for constructor. Candidates are:\n\tmosek.fusion.LinkedInts.ctor()\n\tmosek.fusion.LinkedInts.ctor(int32)\n\tmosek.fusion.LinkedInts.ctor(mosek.fusion.LinkedInts)')
  def alloc(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_alloc_(*args): # 
      return self._alloc_(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_(*args): # 
      return self._alloc_alt_(*args)
    elif mosek_fusion_LinkedInts._match_alloc_I(*args): # int32
      return self._alloc_I(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_I(*args): # int32
      return self._alloc_alt_I(*args)
    elif mosek_fusion_LinkedInts._match_alloc_I_3II(*args): # int32,[]int32,int32
      return self._alloc_I_3II(*args)
    elif mosek_fusion_LinkedInts._match_alt_alloc_I_3II(*args): # int32,[]int32,int32
      return self._alloc_alt_I_3II(*args)
    else:
      raise ValueError('Invalid argument list alloc('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.alloc()\n\tmosek.fusion.LinkedInts.alloc(int32)\n\tmosek.fusion.LinkedInts.alloc(int32,array(int32,ndim=1),int32)')
  def maxidx(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_maxidx_II(*args): # int32,int32
      return self._maxidx_II(*args)
    elif mosek_fusion_LinkedInts._match_alt_maxidx_II(*args): # int32,int32
      return self._maxidx_alt_II(*args)
    else:
      raise ValueError('Invalid argument list maxidx('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.maxidx(int32,int32)')
  def free(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_free_II(*args): # int32,int32
      return self._free_II(*args)
    elif mosek_fusion_LinkedInts._match_alt_free_II(*args): # int32,int32
      return self._free_alt_II(*args)
    else:
      raise ValueError('Invalid argument list free('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.free(int32,int32)')
  def capacity(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_capacity_(*args): # 
      return self._capacity_(*args)
    elif mosek_fusion_LinkedInts._match_alt_capacity_(*args): # 
      return self._capacity_alt_(*args)
    else:
      raise ValueError('Invalid argument list capacity('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.capacity()')
  def get(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_get_II_3II(*args): # int32,int32,[]int32,int32
      return self._get_II_3II(*args)
    elif mosek_fusion_LinkedInts._match_alt_get_II_3II(*args): # int32,int32,[]int32,int32
      return self._get_alt_II_3II(*args)
    else:
      raise ValueError('Invalid argument list get('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.get(int32,int32,array(int32,ndim=1),int32)')
  def numallocated(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_numallocated_(*args): # 
      return self._numallocated_(*args)
    elif mosek_fusion_LinkedInts._match_alt_numallocated_(*args): # 
      return self._numallocated_alt_(*args)
    else:
      raise ValueError('Invalid argument list numallocated('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.numallocated()')
  def validate(self,*args):
    if False: pass
    elif mosek_fusion_LinkedInts._match_validate_(*args): # 
      return self._validate_(*args)
    elif mosek_fusion_LinkedInts._match_alt_validate_(*args): # 
      return self._validate_alt_(*args)
    else:
      raise ValueError('Invalid argument list validate('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.LinkedInts.validate()')
  def __repr__(self): return 'mosek.fusion.LinkedInts'
  @staticmethod
  def _ctor_I(cap_):
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_I(cap_)
    return o
  @staticmethod
  def __match_ctor_I(*args):
    if len(args) != 1: return False
    cap_, = args
    return (__arg_match_I__(cap_))
  @staticmethod
  def __match_alt_ctor_I(*args):
    if len(args) != 1: return False
    cap_, = args
    return (__arg_alt_match_I__(cap_))
  def _ctor_alt_init_I(self,cap_):
    self._ctor_init_I(numpy.int32(cap_))
  def _ctor_init_I(self,cap_):
   _0=(cap_ if ((cap_ > 0) ) else 128)
   self.__next = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   self.__prev = numpy.zeros((_0,), dtype=numpy.dtype(numpy.int32))
   self.__first_used = (- 1)
   self.__first_free = 0
   self.__last_free = (_0 - 1)
   fragments._c_closure_623(_0,self.__next,self.__prev) # src/fusion/LinkedList.monty:80:8-62
   self.__prev[0] = (- 1)
   self.__next[(_0 - 1)] = (- 1)
   self.__nfree = _0
  @staticmethod
  def _ctor_():
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_()
    return o
  @staticmethod
  def __match_ctor_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def __match_alt_ctor_(*args):
    if len(args) != 0: return False
    return True
  def _ctor_alt_init_(self,):
    self._ctor_init_()
  def _ctor_init_(self,):
   mosek_fusion_LinkedInts._ctor_init_I(self,128)
  @staticmethod
  def _ctor_Lmosek_4fusion_4LinkedInts_2(other):
    o = LinkedInts.__new__(LinkedInts)
    o._ctor_init_Lmosek_4fusion_4LinkedInts_2(other)
    return o
  @staticmethod
  def __match_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_match_Lmosek_4fusion_4LinkedInts_2__(other))
  @staticmethod
  def __match_alt_ctor_Lmosek_4fusion_4LinkedInts_2(*args):
    if len(args) != 1: return False
    other, = args
    return (__arg_alt_match_Lmosek_4fusion_4LinkedInts_2__(other))
  def _ctor_alt_init_Lmosek_4fusion_4LinkedInts_2(self,other):
    self._ctor_init_Lmosek_4fusion_4LinkedInts_2(other)
  def _ctor_init_Lmosek_4fusion_4LinkedInts_2(self,other):
   self.__next = mosek.fusion.Utils.Tools._arraycopy__3I((other.__next))
   self.__prev = mosek.fusion.Utils.Tools._arraycopy__3I((other.__prev))
   self.__first_used = (other.__first_used)
   self.__first_free = (other.__first_free)
   self.__last_free = (other.__last_free)
   self.__nfree = (other.__nfree)
  @staticmethod
  def _match_free_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_free_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _free_alt_II(self,_t__0,_t__1):
    return self._free_II(numpy.int32(__0),numpy.int32(__1))
  def _free_II(self,_0,_1):
   self.__first_free,self.__first_used,self.__nfree = fragments._c_closure_624(self.__first_free,self.__first_used,_0,self.__next,self.__nfree,_1,self.__prev) # src/fusion/LinkedList.monty:180:45-199:7
   self.__first_free = numpy.int32(self.__first_free) # postprocess
   self.__first_used = numpy.int32(self.__first_used) # postprocess
   self.__nfree = numpy.int32(self.__nfree) # postprocess
  @staticmethod
  def _match_alloc_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_alloc_(*args):
    if len(args) != 0: return False
    return True
  def _alloc_alt_(self,):
    return self._alloc_()
  def _alloc_(self,):
   return numpy.int32(self.__allocblock_I(1))
  @staticmethod
  def _match_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_match_I__(_0))
  @staticmethod
  def _match_alt_alloc_I(*args):
    if len(args) != 1: return False
    _0, = args
    return (__arg_alt_match_I__(_0))
  def _alloc_alt_I(self,_t__0):
    return self._alloc_I(numpy.int32(__0))
  def _alloc_I(self,_0):
   return numpy.int32(self.__allocblock_I(_0))
  @staticmethod
  def _match_alloc_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_I__(_0) and __arg_match__3I__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_alloc_I_3II(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match__3I__(_1) and __arg_alt_match_I__(_2))
  def _alloc_alt_I_3II(self,_t__0,_t__1,_t__2):
   _0=numpy.int32(_t__0)
   _1=numpy.array(_t__1,dtype=numpy.dtype(numpy.int32))
   _2=numpy.int32(_t__2)
   _1 = self._alloc_I_3II(_0,_1,_2)
   try:
     _t__1[:] = _1
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _alloc_I_3II(self,_0,_1,_2):
   _3=self.__allocblock_I(_0)
   _3 = fragments._c_closure_625(_3,self.__next,_0,_2,_1) # src/fusion/LinkedList.monty:166:8-169:9
   _3 = numpy.int32(_3) # postprocess
  @staticmethod
  def _match_get_II_3II(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1) and __arg_match__3I__(_2) and __arg_match_I__(_3))
  @staticmethod
  def _match_alt_get_II_3II(*args):
    if len(args) != 4: return False
    _0,_1,_2,_3, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1) and __arg_alt_match__3I__(_2) and __arg_alt_match_I__(_3))
  def _get_alt_II_3II(self,_t__0,_t__1,_t__2,_t__3):
   _0=numpy.int32(_t__0)
   _1=numpy.int32(_t__1)
   _2=numpy.array(_t__2,dtype=numpy.dtype(numpy.int32))
   _3=numpy.int32(_t__3)
   _1 = self._get_II_3II(_0,_1,_2,_3)
   try:
     _t__2[:] = _2
   except TypeError:
     pass # if we cannot copy back - ignore it
   return _1
  def _get_II_3II(self,_0,_1,_2,_3):
   fragments._c_closure_626(_0,self.__next,_1,_3,_2) # src/fusion/LinkedList.monty:156:74-162:7
  @staticmethod
  def _match_numallocated_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_numallocated_(*args):
    if len(args) != 0: return False
    return True
  def _numallocated_alt_(self,):
    return self._numallocated_()
  def _numallocated_(self,):
   return numpy.int32((int((self.__next).shape[0]) - self.__nfree))
  @staticmethod
  def _match_maxidx_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_match_I__(_0) and __arg_match_I__(_1))
  @staticmethod
  def _match_alt_maxidx_II(*args):
    if len(args) != 2: return False
    _0,_1, = args
    return (__arg_alt_match_I__(_0) and __arg_alt_match_I__(_1))
  def _maxidx_alt_II(self,_t__0,_t__1):
    return self._maxidx_II(numpy.int32(__0),numpy.int32(__1))
  def _maxidx_II(self,_0,_1):
   _2=_0
   _3=_0
   _3,_2 = fragments._c_closure_627(_3,_2,self.__next,_1) # src/fusion/LinkedList.monty:146:8-149:9
   _3 = numpy.int32(_3) # postprocess
   _2 = numpy.int32(_2) # postprocess
   return numpy.int32(_2)
  def __allocblock_alt_I(self,_t__0):
    return self.__allocblock_I(numpy.int32(__0))
  def __allocblock_I(self,_0):
   _1=int((self.__next).shape[0])
   if (self.__nfree < _0): # src/fusion/LinkedList.monty:117:12-23
    _2=(_0 - self.__nfree)
    if (_2 < _1): # src/fusion/LinkedList.monty:119:14-26
     _2 = _1
    self.__recap_I((_2 + _1))
   _3=self.__first_free
   _4=_3
   _4 = fragments._c_closure_628(_4,self.__next,_0) # src/fusion/LinkedList.monty:125:8-126:24
   _4 = numpy.int32(_4) # postprocess
   self.__first_free = self.__next[_4]
   if (self.__first_free < 0): # src/fusion/LinkedList.monty:129:12-26
    self.__last_free = (- 1)
   else:
    self.__prev[self.__first_free] = (- 1)
   self.__next[_4] = self.__first_used
   if (self.__first_used >= 0): # src/fusion/LinkedList.monty:134:12-27
    self.__prev[self.__first_used] = _4
   self.__first_used = _3
   self.__nfree -= _0
   return numpy.int32(_3)
  def __recap_alt_I(self,_t__0):
    return self.__recap_I(numpy.int32(__0))
  def __recap_I(self,_0):
   _1=int((self.__next).shape[0])
   if (_0 > _1): # src/fusion/LinkedList.monty:90:12-22
    self.__next = mosek.fusion.CommonTools._resize__3II(self.__next,_0)
    self.__prev = mosek.fusion.CommonTools._resize__3II(self.__prev,_0)
    fragments._c_closure_629(_1,_0,self.__next,self.__prev) # src/fusion/LinkedList.monty:94:10-97:11
    self.__next[(_0 - 1)] = (- 1)
    self.__prev[_1] = self.__last_free
    if (self.__last_free < 0): # src/fusion/LinkedList.monty:102:14-27
     self.__first_free = _1
    else:
     self.__next[self.__last_free] = _1
    self.__last_free = (_0 - 1)
    self.__nfree += (_0 - _1)
  @staticmethod
  def _match_capacity_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_capacity_(*args):
    if len(args) != 0: return False
    return True
  def _capacity_alt_(self,):
    return self._capacity_()
  def _capacity_(self,):
   return numpy.int32(int((self.__next).shape[0]))
  @staticmethod
  def _match_validate_(*args):
    if len(args) != 0: return False
    return True
  @staticmethod
  def _match_alt_validate_(*args):
    if len(args) != 0: return False
    return True
  def _validate_alt_(self,):
    return self._validate_()
  def _validate_(self,):
   _0=numpy.zeros((int((self.__next).shape[0]),), dtype=numpy.dtype(bool))
   _1=self.__first_used
   while (_1 >= 0):
    _0[_1] = True
    _1 = self.__next[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:23:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("used list/next is inconsistent")
   _1 = self.__first_free
   _2=0
   while (_1 >= 0):
    _2 += 1
    _0[_1] = True
    _1 = self.__next[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:33:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("free list/next is inconsistent")
   if (_2!=self.__nfree): # src/fusion/LinkedList.monty:36:12-22
    raise mosek_fusion_UnexpectedError._ctor_S("free next list did not contain nfree elements")
   for _3 in range(0,int((_0).shape[0])):
    if (not _0[_1]): # src/fusion/LinkedList.monty:41:14-26
     raise mosek_fusion_UnexpectedError._ctor_S("elements missing from used+free list")
   for _4 in range(0,int((_0).shape[0])):
    _0[_4] = False
   _1 = self.__last_free
   _5=0
   while (_1 >= 0):
    _5 += 1
    _0[_1] = True
    _1 = self.__prev[_1]
    if ((_1 >= 0) and _0[_1]): # src/fusion/LinkedList.monty:51:14-33
     raise mosek_fusion_UnexpectedError._ctor_S("prev list is inconsistent")
   if (_5!=self.__nfree): # src/fusion/LinkedList.monty:55:12-22
    raise mosek_fusion_UnexpectedError._ctor_S("free prev list did not contain nfree elements")
   return (True)
 return LinkedInts
mosek_fusion_LinkedInts=__mk_mosek_fusion_LinkedInts()
del __mk_mosek_fusion_LinkedInts
#BEFORE CLASS
def __mk_mosek_fusion_Parameters():
 class Parameters(object):
  @staticmethod
  def setParameter(*args):
    if False: pass
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args): # mosek.fusion.Model,string,string
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SS(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args): # mosek.fusion.Model,string,int32
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SI(*args)
    elif mosek_fusion_Parameters._match_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(*args)
    elif mosek_fusion_Parameters._match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args): # mosek.fusion.Model,string,double
      return mosek_fusion_Parameters._setParameter_alt_Lmosek_4fusion_4Model_2SD(*args)
    else:
      raise ValueError('Invalid argument list setParameter('+','.join(map(repr,args))+'). Candidates are\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,string)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,int32)\n\tmosek.fusion.Parameters.setParameter(mosek.fusion.Model,string,double)')
  def __repr__(self): return 'mosek.fusion.Parameters'
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_D__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SD(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_D__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SD(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,numpy.float64(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SD(_0,_1,_2):
   if False: # bld/herlev/final/default/src/fusion/Parameters.mbi:4702:6-11
    pass
   elif (_1=="autoUpdateSolInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4703:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4705:10-41
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4707:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4709:8-35
     _3=_2
     if (0 <= _3): # bld/herlev/final/default/src/fusion/Parameters.mbi:4712:10-16
      _0._task_1put_1param_SD("MSK_IPAR_NUM_THREADS",_3)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_1=="mtSpincount"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4722:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4724:8-35
     _4=_2
     if ((0 <= _4) and (_4 <= 1000000000)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4727:10-36
      _0._task_1put_1param_SD("MSK_IPAR_MT_SPINCOUNT",_4)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4737:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4739:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4741:8-35
     _5=_2
     if (0 <= _5): # bld/herlev/final/default/src/fusion/Parameters.mbi:4744:10-16
      _0._task_1put_1param_SD("MSK_IPAR_BI_MAX_ITERATIONS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4754:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4756:8-35
     _6=_2
     if (0 <= _6): # bld/herlev/final/default/src/fusion/Parameters.mbi:4759:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4769:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4771:8-35
     _7=_2
     if (0 <= _7): # bld/herlev/final/default/src/fusion/Parameters.mbi:4774:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4784:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4786:8-35
     _8=_2
     if (0 <= _8): # bld/herlev/final/default/src/fusion/Parameters.mbi:4789:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_RESPONSE",_8)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   elif (_1=="logLocalInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4799:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
   if (_1=="logBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4801:6-21
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4803:8-35
     _9=_2
     if (0 <= _9): # bld/herlev/final/default/src/fusion/Parameters.mbi:4806:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI",_9)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4816:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4818:8-35
     _10=_2
     if (0 <= _10): # bld/herlev/final/default/src/fusion/Parameters.mbi:4821:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_BI_FREQ",_10)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4831:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4833:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4835:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4837:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4839:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4841:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4843:8-35
     _11=_2
     if (0 <= _11): # bld/herlev/final/default/src/fusion/Parameters.mbi:4846:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INTPNT",_11)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4856:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4858:8-35
     _12=_2
     if (0 <= _12): # bld/herlev/final/default/src/fusion/Parameters.mbi:4861:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_ITERATIONS",_12)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4871:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4873:8-35
     _13=_2
     if (0 <= _13): # bld/herlev/final/default/src/fusion/Parameters.mbi:4876:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_OFF_COL_TRH",_13)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4886:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   if (_1=="intpntOrderGpNumSeeds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4888:6-37
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4890:8-35
     _14=_2
     if (0 <= _14): # bld/herlev/final/default/src/fusion/Parameters.mbi:4893:10-16
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_14)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   elif (_1=="intpntBasis"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4903:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4905:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4907:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4909:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4911:8-35
     _15=_2
     if ((- 1) <= _15): # bld/herlev/final/default/src/fusion/Parameters.mbi:4914:10-17
      _0._task_1put_1param_SD("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4924:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4926:6-29
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4928:8-35
     _16=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4931:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LEVEL",_16)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4941:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4943:8-35
     _17=_2
     if (0 <= _17): # bld/herlev/final/default/src/fusion/Parameters.mbi:4946:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_PRESOLVE",_17)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4956:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveMaxNumPass"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4958:6-34
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4960:8-35
     _18=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4963:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_18)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4973:6-45
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4975:8-35
     _19=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4978:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4988:6-41
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:4990:8-35
     _20=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4993:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_20)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5003:6-30
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5005:8-35
     _21=_2
     if (0 <= _21): # bld/herlev/final/default/src/fusion/Parameters.mbi:5008:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_CRASH",_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5018:6-22
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5020:8-35
     _22=_2
     if (0 <= _22): # bld/herlev/final/default/src/fusion/Parameters.mbi:5023:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM",_22)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5033:6-27
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5035:8-35
     _23=_2
     if (0 <= _23): # bld/herlev/final/default/src/fusion/Parameters.mbi:5038:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_MINOR",_23)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5048:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5050:8-35
     _24=_2
     if (0 <= _24): # bld/herlev/final/default/src/fusion/Parameters.mbi:5053:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_SIM_FREQ",_24)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5063:6-42
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5065:8-35
     _25=_2
     if ((0 <= _25) and (_25 <= 100)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5068:10-29
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_25)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5078:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5080:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5082:8-35
     _26=_2
     if ((0 <= _26) and (_26 <= 100)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5085:10-29
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_26)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5095:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5097:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5099:8-35
     _27=_2
     if (0 <= _27): # bld/herlev/final/default/src/fusion/Parameters.mbi:5102:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_ITERATIONS",_27)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5112:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5114:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5116:8-35
     _28=_2
     if (0 <= _28): # bld/herlev/final/default/src/fusion/Parameters.mbi:5119:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_REFACTOR_FREQ",_28)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5129:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5131:8-35
     _29=_2
     if ((0 <= _29) and (_29 <= 32749)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5134:10-31
      _0._task_1put_1param_SD("MSK_IPAR_SIM_SEED",_29)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   elif (_1=="mioMode"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5144:10-27
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5146:6-22
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5148:8-35
     _30=_2
     if (0 <= _30): # bld/herlev/final/default/src/fusion/Parameters.mbi:5151:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO",_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5161:6-26
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5163:8-35
     _31=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5166:10-14
      _0._task_1put_1param_SD("MSK_IPAR_LOG_MIO_FREQ",_31)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5176:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5178:8-35
     _32=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5181:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_RELAXS",_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5191:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5193:8-35
     _33=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5196:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_33)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5206:6-38
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5208:8-35
     _34=_2
     if (0 <= _34): # bld/herlev/final/default/src/fusion/Parameters.mbi:5211:10-16
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_34)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5221:6-34
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5223:8-35
     _35=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5226:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_35)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5236:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5238:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5240:8-35
     _36=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5243:10-14
      _0._task_1put_1param_SD("MSK_IPAR_MIO_HEURISTIC_LEVEL",_36)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5253:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5255:8-35
     _37=_2
     if (((- 1) <= _37) and (_37 <= 3)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5258:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_PROBING_LEVEL",_37)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioSymmetryLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5268:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5270:8-35
     _38=_2
     if (((- 1) <= _38) and (_38 <= 4)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5273:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_SYMMETRY_LEVEL",_38)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
   elif (_1=="mioPresolveAggregatorUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5283:10-44
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPresolveAggregatorUse)")
   if (_1=="mioNumericalEmphasisLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5285:6-41
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5287:8-35
     _39=_2
     if ((0 <= _39) and (_39 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5290:10-27
      _0._task_1put_1param_SD("MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL",_39)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
   if (_1=="mioMemoryEmphasisLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5300:6-38
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5302:8-35
     _40=_2
     if ((0 <= _40) and (_40 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5305:10-27
      _0._task_1put_1param_SD("MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL",_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5315:6-36
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5317:8-35
     _41=_2
     if (((- 1) <= _41) and (_41 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5320:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_41)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5330:6-35
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5332:8-35
     _42=_2
     if (((- 1) <= _42) and (_42 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5335:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_42)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5345:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5347:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5349:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5351:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="mioPropagateObjectiveConstraint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5353:10-51
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
   if (_1=="mioSeed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5355:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5357:8-35
     _43=_2
     if (0 <= _43): # bld/herlev/final/default/src/fusion/Parameters.mbi:5360:10-16
      _0._task_1put_1param_SD("MSK_IPAR_MIO_SEED",_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   elif (_1=="mioConicOuterApproximation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5370:10-46
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
   elif (_1=="mioQcqoReformulationMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5372:10-46
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioQcqoReformulationMethod)")
   elif (_1=="mioDataPermutationMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5374:10-44
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDataPermutationMethod)")
   if (_1=="writeLpLineWidth"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5376:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5378:8-35
     _44=_2
     if (40 <= _44): # bld/herlev/final/default/src/fusion/Parameters.mbi:5381:10-17
      _0._task_1put_1param_SD("MSK_IPAR_WRITE_LP_LINE_WIDTH",_44)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   elif (_1=="writeLpFullObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5391:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   elif (_1=="writeJsonIndentation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5393:10-40
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeJsonIndentation)")
   elif (_1=="infeasReportAuto"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5395:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasReportAuto)")
   if (_1=="logInfeasAna"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5397:6-28
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5399:8-35
     _45=_2
     if (0 <= _45): # bld/herlev/final/default/src/fusion/Parameters.mbi:5402:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_INFEAS_ANA",_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5412:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5414:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5416:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5418:8-35
     _46=_2
     if ((0 <= _46) and (_46 <= 1000000)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5421:10-33
      _0._task_1put_1param_SD("MSK_IPAR_LICENSE_PAUSE_TIME",_46)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5431:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5433:6-19
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5435:8-35
     _47=_2
     if (0 <= _47): # bld/herlev/final/default/src/fusion/Parameters.mbi:5438:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG",_47)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5448:6-25
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5450:8-35
     _48=_2
     if (0 <= _48): # bld/herlev/final/default/src/fusion/Parameters.mbi:5453:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_EXPAND",_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5463:6-23
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5465:8-35
     _49=_2
     if (0 <= _49): # bld/herlev/final/default/src/fusion/Parameters.mbi:5468:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_FILE",_49)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5478:6-24
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5480:8-35
     _50=_2
     if (0 <= _50): # bld/herlev/final/default/src/fusion/Parameters.mbi:5483:10-16
      _0._task_1put_1param_SD("MSK_IPAR_LOG_ORDER",_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5493:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5495:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5497:6-39
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5499:8-35
     _51=_2
     if ((0 <= _51) and (_51 <= 10)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5502:10-28
      _0._task_1put_1param_SD("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_51)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5512:6-37
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5514:8-35
     _52=_2
     if ((0 <= _52) and (_52 <= 10)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5517:10-28
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5527:6-33
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5529:8-35
     _53=_2
     if (0 <= _53): # bld/herlev/final/default/src/fusion/Parameters.mbi:5532:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_53)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5542:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5544:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5546:10-28
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5548:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5550:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5552:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5554:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5556:6-28
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5558:8-35
     _54=_2
     if (0 <= _54): # bld/herlev/final/default/src/fusion/Parameters.mbi:5561:10-16
      _0._task_1put_1param_SD("MSK_IPAR_SIM_DUAL_CRASH",_54)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5571:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5573:6-42
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5575:8-35
     _55=_2
     if (((- 1) <= _55) and (_55 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5578:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_55)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5588:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5590:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5592:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5594:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5596:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   elif (_1=="mioCutLipro"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5598:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutLipro)")
   elif (_1=="mioConstructSol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5600:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
   if (_1=="presolveLindepRelWorkTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5602:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5604:8-35
     _56=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5607:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_56)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5617:6-40
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5619:8-35
     _57=_2
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5622:10-14
      _0._task_1put_1param_SD("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_57)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5632:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5634:10-43
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5636:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5638:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5640:6-31
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5642:8-35
     _58=_2
     if ((- 1) <= _58): # bld/herlev/final/default/src/fusion/Parameters.mbi:5645:10-17
      _0._task_1put_1param_SD("MSK_IPAR_MIO_RINS_MAX_NODES",_58)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5655:6-32
    if ((_2 - numpy.int32(_2))==0.0): # bld/herlev/final/default/src/fusion/Parameters.mbi:5657:8-35
     _59=_2
     if (((- 1) <= _59) and (_59 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5660:10-28
      _0._task_1put_1param_SD("MSK_IPAR_MIO_FEASPUMP_LEVEL",_59)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   elif (_1=="remoteUseCompression"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5670:10-40
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteUseCompression)")
   if (_1=="optimizerMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5672:6-32
    _60=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5675:8-12
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5682:6-27
    _61=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5685:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5692:6-27
    _62=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5695:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5702:6-36
    _63=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5705:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5712:6-36
    _64=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5715:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5722:6-31
    _65=_2
    if (1.000000e-14 <= _65): # bld/herlev/final/default/src/fusion/Parameters.mbi:5725:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5732:6-33
    _66=_2
    if ((0.000000e+00 <= _66) and (_66 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5735:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5742:6-30
    _67=_2
    if ((1.000000e-06 <= _67) and (_67 <= 9.999990e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5745:8-47
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5752:6-32
    _68=_2
    if ((1.000000e-04 <= _68) and (_68 <= 9.999990e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5755:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5762:6-29
    _69=_2
    if ((0.000000e+00 <= _69) and (_69 <= 9.999000e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5765:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5772:6-30
    _70=_2
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5775:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5782:6-30
    _71=_2
    if ((0.000000e+00 <= _71) and (_71 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5785:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5792:6-30
    _72=_2
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5795:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5802:6-31
    _73=_2
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5805:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5812:6-33
    _74=_2
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5815:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5822:6-32
    _75=_2
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5825:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5832:6-32
    _76=_2
    if ((0.000000e+00 <= _76) and (_76 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5835:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5842:6-32
    _77=_2
    if ((0.000000e+00 <= _77) and (_77 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5845:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5852:6-34
    _78=_2
    if (1.000000e+00 <= _78): # bld/herlev/final/default/src/fusion/Parameters.mbi:5855:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5862:6-33
    _79=_2
    if ((0.000000e+00 <= _79) and (_79 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:5865:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5872:6-30
    _80=_2
    if (1.000000e-04 <= _80): # bld/herlev/final/default/src/fusion/Parameters.mbi:5875:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5882:6-30
    _81=_2
    if (1.000000e-04 <= _81): # bld/herlev/final/default/src/fusion/Parameters.mbi:5885:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5892:6-26
    _82=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:5895:8-12
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5902:6-30
    _83=_2
    if (1.000000e-15 <= _83): # bld/herlev/final/default/src/fusion/Parameters.mbi:5905:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5912:6-28
    _84=_2
    if (0.000000e+00 <= _84): # bld/herlev/final/default/src/fusion/Parameters.mbi:5915:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5922:6-28
    _85=_2
    if (0.000000e+00 <= _85): # bld/herlev/final/default/src/fusion/Parameters.mbi:5925:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5932:6-33
    _86=_2
    if (1.000000e-09 <= _86): # bld/herlev/final/default/src/fusion/Parameters.mbi:5935:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="mioDjcMaxBigm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5942:6-29
    _87=_2
    if (0.000000e+00 <= _87): # bld/herlev/final/default/src/fusion/Parameters.mbi:5945:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_DJC_MAX_BIGM",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDjcMaxBigm)")
   if (_1=="basisTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5952:6-25
    _88=_2
    if (1.000000e-09 <= _88): # bld/herlev/final/default/src/fusion/Parameters.mbi:5955:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5962:6-25
    _89=_2
    if (1.000000e-09 <= _89): # bld/herlev/final/default/src/fusion/Parameters.mbi:5965:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5972:6-28
    _90=_2
    if (0.000000e+00 <= _90): # bld/herlev/final/default/src/fusion/Parameters.mbi:5975:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5982:6-28
    _91=_2
    if (0.000000e+00 <= _91): # bld/herlev/final/default/src/fusion/Parameters.mbi:5985:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolPrimalInfeasPerturbation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:5992:6-51
    _92=_2
    if (0.000000e+00 <= _92): # bld/herlev/final/default/src/fusion/Parameters.mbi:5995:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolPrimalInfeasPerturbation)")
   if (_1=="presolveTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6002:6-28
    _93=_2
    if (0.000000e+00 <= _93): # bld/herlev/final/default/src/fusion/Parameters.mbi:6005:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6012:6-30
    _94=_2
    if (1.000000e-15 <= _94): # bld/herlev/final/default/src/fusion/Parameters.mbi:6015:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6022:6-36
    _95=_2
    if (0.000000e+00 <= _95): # bld/herlev/final/default/src/fusion/Parameters.mbi:6025:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6032:6-36
    _96=_2
    if (0.000000e+00 <= _96): # bld/herlev/final/default/src/fusion/Parameters.mbi:6035:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_96)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6042:6-32
    _97=_2
    if (1.000000e-12 <= _97): # bld/herlev/final/default/src/fusion/Parameters.mbi:6045:8-25
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_97)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6052:6-26
    _98=_2
    if ((1.000000e-09 <= _98) and (_98 <= 1.000000e-03)): # bld/herlev/final/default/src/fusion/Parameters.mbi:6055:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_98)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6062:6-45
    _99=_2
    if ((0.000000e+00 <= _99) and (_99 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:6065:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_99)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   elif (_1=="dataFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6072:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (dataFileName)")
   elif (_1=="basSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6074:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basSolFileName)")
   elif (_1=="itrSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6076:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (itrSolFileName)")
   elif (_1=="intSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6078:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intSolFileName)")
   elif (_1=="writeLpGenVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6080:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpGenVarName)")
   elif (_1=="remoteOptserverHost"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6082:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteOptserverHost)")
   elif (_1=="remoteTlsCertPath"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6084:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteTlsCertPath)")
   elif (_1=="remoteTlsCert"): # bld/herlev/final/default/src/fusion/Parameters.mbi:6086:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteTlsCert)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_I__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SI(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_I__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SI(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,numpy.int32(__2))
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SI(_0,_1,_2):
   if False: # bld/herlev/final/default/src/fusion/Parameters.mbi:3596:6-11
    pass
   elif (_1=="autoUpdateSolInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3597:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
   elif (_1=="removeUnusedSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3599:10-41
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
   if (_1=="numThreads"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3601:6-26
    _3=_2
    if (0 <= _3): # bld/herlev/final/default/src/fusion/Parameters.mbi:3604:8-14
     _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_3)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_1=="mtSpincount"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3611:6-27
    _4=_2
    if ((0 <= _4) and (_4 <= 1000000000)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3614:8-34
     _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_4)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   elif (_1=="optimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3621:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
   if (_1=="biMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3623:6-31
    _5=_2
    if (0 <= _5): # bld/herlev/final/default/src/fusion/Parameters.mbi:3626:8-14
     _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_5)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3633:6-35
    _6=_2
    if (0 <= _6): # bld/herlev/final/default/src/fusion/Parameters.mbi:3636:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_6)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3643:6-31
    _7=_2
    if (0 <= _7): # bld/herlev/final/default/src/fusion/Parameters.mbi:3646:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_7)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3653:6-27
    _8=_2
    if (0 <= _8): # bld/herlev/final/default/src/fusion/Parameters.mbi:3656:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_8)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   elif (_1=="logLocalInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3663:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
   if (_1=="logBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3665:6-21
    _9=_2
    if (0 <= _9): # bld/herlev/final/default/src/fusion/Parameters.mbi:3668:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_9)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3675:6-25
    _10=_2
    if (0 <= _10): # bld/herlev/final/default/src/fusion/Parameters.mbi:3678:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_10)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   elif (_1=="biCleanOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3685:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
   elif (_1=="intpntStartingPoint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3687:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
   elif (_1=="intpntDiffStep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3689:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
   elif (_1=="intpntScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3691:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
   elif (_1=="intpntSolveForm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3693:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
   if (_1=="logIntpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3695:6-25
    _11=_2
    if (0 <= _11): # bld/herlev/final/default/src/fusion/Parameters.mbi:3698:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_11)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3705:6-35
    _12=_2
    if (0 <= _12): # bld/herlev/final/default/src/fusion/Parameters.mbi:3708:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_12)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3715:6-31
    _13=_2
    if (0 <= _13): # bld/herlev/final/default/src/fusion/Parameters.mbi:3718:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_13)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   elif (_1=="intpntOrderMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3725:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
   if (_1=="intpntOrderGpNumSeeds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3727:6-37
    _14=_2
    if (0 <= _14): # bld/herlev/final/default/src/fusion/Parameters.mbi:3730:8-14
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_14)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   elif (_1=="intpntBasis"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3737:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
   elif (_1=="biIgnoreMaxIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3739:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
   elif (_1=="biIgnoreNumError"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3741:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
   if (_1=="intpntMaxNumCor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3743:6-31
    _15=_2
    if ((- 1) <= _15): # bld/herlev/final/default/src/fusion/Parameters.mbi:3746:8-15
     _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_15)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   elif (_1=="presolveUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3753:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
   if (_1=="presolveLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3755:6-29
    _16=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3758:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_16)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3765:6-27
    _17=_2
    if (0 <= _17): # bld/herlev/final/default/src/fusion/Parameters.mbi:3768:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_17)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   elif (_1=="presolveLindepUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3775:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
   if (_1=="presolveMaxNumPass"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3777:6-34
    _18=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3780:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_18)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3787:6-45
    _19=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3790:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_19)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3797:6-41
    _20=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3800:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_20)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3807:6-30
    _21=_2
    if (0 <= _21): # bld/herlev/final/default/src/fusion/Parameters.mbi:3810:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_21)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3817:6-22
    _22=_2
    if (0 <= _22): # bld/herlev/final/default/src/fusion/Parameters.mbi:3820:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_22)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3827:6-27
    _23=_2
    if (0 <= _23): # bld/herlev/final/default/src/fusion/Parameters.mbi:3830:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_23)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3837:6-26
    _24=_2
    if (0 <= _24): # bld/herlev/final/default/src/fusion/Parameters.mbi:3840:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_24)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3847:6-42
    _25=_2
    if ((0 <= _25) and (_25 <= 100)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3850:8-27
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_25)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   elif (_1=="simPrimalSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3857:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
   if (_1=="simDualRestrictSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3859:6-40
    _26=_2
    if ((0 <= _26) and (_26 <= 100)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3862:8-27
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_26)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   elif (_1=="simDualSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3869:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
   if (_1=="simMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3871:6-32
    _27=_2
    if (0 <= _27): # bld/herlev/final/default/src/fusion/Parameters.mbi:3874:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_27)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   elif (_1=="simHotstartLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3881:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
   if (_1=="simRefactorFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3883:6-31
    _28=_2
    if (0 <= _28): # bld/herlev/final/default/src/fusion/Parameters.mbi:3886:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_28)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3893:6-23
    _29=_2
    if ((0 <= _29) and (_29 <= 32749)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3896:8-29
     _0._task_1put_1param_SI("MSK_IPAR_SIM_SEED",_29)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   elif (_1=="mioMode"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3903:10-27
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
   if (_1=="logMio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3905:6-22
    _30=_2
    if (0 <= _30): # bld/herlev/final/default/src/fusion/Parameters.mbi:3908:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_30)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3915:6-26
    _31=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3918:8-12
     _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_31)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3925:6-31
    _32=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3928:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_32)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3935:6-33
    _33=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3938:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_33)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3945:6-38
    _34=_2
    if (0 <= _34): # bld/herlev/final/default/src/fusion/Parameters.mbi:3948:8-14
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_34)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3955:6-34
    _35=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3958:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_35)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   elif (_1=="mioNodeSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3965:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
   if (_1=="mioHeuristicLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3967:6-33
    _36=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3970:8-12
     _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_36)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3977:6-31
    _37=_2
    if (((- 1) <= _37) and (_37 <= 3)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3980:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_37)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioSymmetryLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3987:6-32
    _38=_2
    if (((- 1) <= _38) and (_38 <= 4)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3990:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_SYMMETRY_LEVEL",_38)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
   elif (_1=="mioPresolveAggregatorUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3997:10-44
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPresolveAggregatorUse)")
   if (_1=="mioNumericalEmphasisLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3999:6-41
    _39=_2
    if ((0 <= _39) and (_39 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4002:8-25
     _0._task_1put_1param_SI("MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL",_39)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
   if (_1=="mioMemoryEmphasisLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4009:6-38
    _40=_2
    if ((0 <= _40) and (_40 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4012:8-25
     _0._task_1put_1param_SI("MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL",_40)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4019:6-36
    _41=_2
    if (((- 1) <= _41) and (_41 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4022:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_41)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4029:6-35
    _42=_2
    if (((- 1) <= _42) and (_42 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4032:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_42)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   elif (_1=="mioBranchDir"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4039:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
   elif (_1=="mioRootOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4041:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
   elif (_1=="mioNodeOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4043:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
   elif (_1=="mioPerspectiveReformulate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4045:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
   elif (_1=="mioPropagateObjectiveConstraint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4047:10-51
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
   if (_1=="mioSeed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4049:6-23
    _43=_2
    if (0 <= _43): # bld/herlev/final/default/src/fusion/Parameters.mbi:4052:8-14
     _0._task_1put_1param_SI("MSK_IPAR_MIO_SEED",_43)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   elif (_1=="mioConicOuterApproximation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4059:10-46
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
   elif (_1=="mioQcqoReformulationMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4061:10-46
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioQcqoReformulationMethod)")
   elif (_1=="mioDataPermutationMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4063:10-44
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDataPermutationMethod)")
   if (_1=="writeLpLineWidth"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4065:6-32
    _44=_2
    if (40 <= _44): # bld/herlev/final/default/src/fusion/Parameters.mbi:4068:8-15
     _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_44)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   elif (_1=="writeLpFullObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4075:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
   elif (_1=="writeJsonIndentation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4077:10-40
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeJsonIndentation)")
   elif (_1=="infeasReportAuto"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4079:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasReportAuto)")
   if (_1=="logInfeasAna"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4081:6-28
    _45=_2
    if (0 <= _45): # bld/herlev/final/default/src/fusion/Parameters.mbi:4084:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_45)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   elif (_1=="licenseWait"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4091:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
   elif (_1=="licenseSuppressExpireWrns"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4093:10-45
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
   if (_1=="licensePauseTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4095:6-32
    _46=_2
    if ((0 <= _46) and (_46 <= 1000000)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4098:8-31
     _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_46)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   elif (_1=="licenseDebug"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4105:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
   if (_1=="log"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4107:6-19
    _47=_2
    if (0 <= _47): # bld/herlev/final/default/src/fusion/Parameters.mbi:4110:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG",_47)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4117:6-25
    _48=_2
    if (0 <= _48): # bld/herlev/final/default/src/fusion/Parameters.mbi:4120:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_48)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4127:6-23
    _49=_2
    if (0 <= _49): # bld/herlev/final/default/src/fusion/Parameters.mbi:4130:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_49)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4137:6-24
    _50=_2
    if (0 <= _50): # bld/herlev/final/default/src/fusion/Parameters.mbi:4140:8-14
     _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_50)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   elif (_1=="simScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4147:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
   elif (_1=="simScalingMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4149:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
   if (_1=="simPrimalPhaseoneMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4151:6-39
    _51=_2
    if ((0 <= _51) and (_51 <= 10)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4154:8-26
     _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_51)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4161:6-37
    _52=_2
    if ((0 <= _52) and (_52 <= 10)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4164:8-26
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_52)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4171:6-33
    _53=_2
    if (0 <= _53): # bld/herlev/final/default/src/fusion/Parameters.mbi:4174:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_53)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   elif (_1=="simHotstart"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4181:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
   elif (_1=="simBasisFactorUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4183:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
   elif (_1=="simDegen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4185:10-28
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
   elif (_1=="simReformulation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4187:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
   elif (_1=="simExploitDupvec"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4189:10-36
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
   elif (_1=="simSaveLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4191:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
   elif (_1=="simNonSingular"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4193:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
   if (_1=="simDualCrash"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4195:6-28
    _54=_2
    if (0 <= _54): # bld/herlev/final/default/src/fusion/Parameters.mbi:4198:8-14
     _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_54)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   elif (_1=="infeasPreferPrimal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4205:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
   if (_1=="mioRootRepeatPresolveLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4207:6-42
    _55=_2
    if (((- 1) <= _55) and (_55 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4210:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_55)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   elif (_1=="mioCutCmir"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4217:10-30
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
   elif (_1=="mioCutClique"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4219:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
   elif (_1=="mioCutImpliedBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4221:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
   elif (_1=="mioCutKnapsackCover"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4223:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
   elif (_1=="mioCutGmi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4225:10-29
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
   elif (_1=="mioCutLipro"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4227:10-31
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutLipro)")
   elif (_1=="mioConstructSol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4229:10-35
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
   if (_1=="presolveLindepRelWorkTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4231:6-40
    _56=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4234:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_56)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4241:6-40
    _57=_2
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4244:8-12
     _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_57)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   elif (_1=="cacheLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4251:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
   elif (_1=="intpntRegularizationUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4253:10-43
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
   elif (_1=="simSolveForm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4255:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
   elif (_1=="simSwitchOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4257:10-38
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
   if (_1=="mioRinsMaxNodes"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4259:6-31
    _58=_2
    if ((- 1) <= _58): # bld/herlev/final/default/src/fusion/Parameters.mbi:4262:8-15
     _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_58)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4269:6-32
    _59=_2
    if (((- 1) <= _59) and (_59 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4272:8-26
     _0._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",_59)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   elif (_1=="remoteUseCompression"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4279:10-40
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteUseCompression)")
   if (_1=="optimizerMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4281:6-32
    _60=numpy.float64(_2)
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4284:8-12
     _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_60)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4291:6-27
    _61=numpy.float64(_2)
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4294:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_61)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4301:6-27
    _62=numpy.float64(_2)
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4304:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_62)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4311:6-36
    _63=numpy.float64(_2)
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4314:8-12
     _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_63)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4321:6-36
    _64=numpy.float64(_2)
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4324:8-12
     _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_64)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4331:6-31
    _65=numpy.float64(_2)
    if (1.000000e-14 <= _65): # bld/herlev/final/default/src/fusion/Parameters.mbi:4334:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_65)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4341:6-33
    _66=numpy.float64(_2)
    if ((0.000000e+00 <= _66) and (_66 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4344:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_66)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4351:6-30
    _67=numpy.float64(_2)
    if ((1.000000e-06 <= _67) and (_67 <= 9.999990e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4354:8-47
     _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_67)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4361:6-32
    _68=numpy.float64(_2)
    if ((1.000000e-04 <= _68) and (_68 <= 9.999990e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4364:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_68)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4371:6-29
    _69=numpy.float64(_2)
    if ((0.000000e+00 <= _69) and (_69 <= 9.999000e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4374:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_69)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4381:6-30
    _70=numpy.float64(_2)
    if ((0.000000e+00 <= _70) and (_70 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4384:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_70)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4391:6-30
    _71=numpy.float64(_2)
    if ((0.000000e+00 <= _71) and (_71 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4394:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_71)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4401:6-30
    _72=numpy.float64(_2)
    if ((0.000000e+00 <= _72) and (_72 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4404:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_72)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4411:6-31
    _73=numpy.float64(_2)
    if ((0.000000e+00 <= _73) and (_73 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4414:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_73)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4421:6-33
    _74=numpy.float64(_2)
    if ((0.000000e+00 <= _74) and (_74 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4424:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_74)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4431:6-32
    _75=numpy.float64(_2)
    if ((0.000000e+00 <= _75) and (_75 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4434:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_75)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4441:6-32
    _76=numpy.float64(_2)
    if ((0.000000e+00 <= _76) and (_76 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4444:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_76)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4451:6-32
    _77=numpy.float64(_2)
    if ((0.000000e+00 <= _77) and (_77 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4454:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_77)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4461:6-34
    _78=numpy.float64(_2)
    if (1.000000e+00 <= _78): # bld/herlev/final/default/src/fusion/Parameters.mbi:4464:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_78)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4471:6-33
    _79=numpy.float64(_2)
    if ((0.000000e+00 <= _79) and (_79 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4474:8-47
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_79)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4481:6-30
    _80=numpy.float64(_2)
    if (1.000000e-04 <= _80): # bld/herlev/final/default/src/fusion/Parameters.mbi:4484:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_80)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4491:6-30
    _81=numpy.float64(_2)
    if (1.000000e-04 <= _81): # bld/herlev/final/default/src/fusion/Parameters.mbi:4494:8-25
     _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_81)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4501:6-26
    _82=numpy.float64(_2)
    if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:4504:8-12
     _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_82)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4511:6-30
    _83=numpy.float64(_2)
    if (1.000000e-15 <= _83): # bld/herlev/final/default/src/fusion/Parameters.mbi:4514:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_83)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4521:6-28
    _84=numpy.float64(_2)
    if (0.000000e+00 <= _84): # bld/herlev/final/default/src/fusion/Parameters.mbi:4524:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_84)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4531:6-28
    _85=numpy.float64(_2)
    if (0.000000e+00 <= _85): # bld/herlev/final/default/src/fusion/Parameters.mbi:4534:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_85)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4541:6-33
    _86=numpy.float64(_2)
    if (1.000000e-09 <= _86): # bld/herlev/final/default/src/fusion/Parameters.mbi:4544:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_86)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="mioDjcMaxBigm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4551:6-29
    _87=numpy.float64(_2)
    if (0.000000e+00 <= _87): # bld/herlev/final/default/src/fusion/Parameters.mbi:4554:8-25
     _0._task_1put_1param_SD("MSK_DPAR_MIO_DJC_MAX_BIGM",_87)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDjcMaxBigm)")
   if (_1=="basisTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4561:6-25
    _88=numpy.float64(_2)
    if (1.000000e-09 <= _88): # bld/herlev/final/default/src/fusion/Parameters.mbi:4564:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_88)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4571:6-25
    _89=numpy.float64(_2)
    if (1.000000e-09 <= _89): # bld/herlev/final/default/src/fusion/Parameters.mbi:4574:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_89)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4581:6-28
    _90=numpy.float64(_2)
    if (0.000000e+00 <= _90): # bld/herlev/final/default/src/fusion/Parameters.mbi:4584:8-25
     _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_90)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4591:6-28
    _91=numpy.float64(_2)
    if (0.000000e+00 <= _91): # bld/herlev/final/default/src/fusion/Parameters.mbi:4594:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_91)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolPrimalInfeasPerturbation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4601:6-51
    _92=numpy.float64(_2)
    if (0.000000e+00 <= _92): # bld/herlev/final/default/src/fusion/Parameters.mbi:4604:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION",_92)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolPrimalInfeasPerturbation)")
   if (_1=="presolveTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4611:6-28
    _93=numpy.float64(_2)
    if (0.000000e+00 <= _93): # bld/herlev/final/default/src/fusion/Parameters.mbi:4614:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_93)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4621:6-30
    _94=numpy.float64(_2)
    if (1.000000e-15 <= _94): # bld/herlev/final/default/src/fusion/Parameters.mbi:4624:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_94)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4631:6-36
    _95=numpy.float64(_2)
    if (0.000000e+00 <= _95): # bld/herlev/final/default/src/fusion/Parameters.mbi:4634:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_95)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4641:6-36
    _96=numpy.float64(_2)
    if (0.000000e+00 <= _96): # bld/herlev/final/default/src/fusion/Parameters.mbi:4644:8-25
     _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_96)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4651:6-32
    _97=numpy.float64(_2)
    if (1.000000e-12 <= _97): # bld/herlev/final/default/src/fusion/Parameters.mbi:4654:8-25
     _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_97)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4661:6-26
    _98=numpy.float64(_2)
    if ((1.000000e-09 <= _98) and (_98 <= 1.000000e-03)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4664:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_98)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4671:6-45
    _99=numpy.float64(_2)
    if ((0.000000e+00 <= _99) and (_99 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:4674:8-47
     _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_99)
     return 
    else:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   elif (_1=="dataFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4681:10-32
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (dataFileName)")
   elif (_1=="basSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4683:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basSolFileName)")
   elif (_1=="itrSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4685:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (itrSolFileName)")
   elif (_1=="intSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4687:10-34
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intSolFileName)")
   elif (_1=="writeLpGenVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4689:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpGenVarName)")
   elif (_1=="remoteOptserverHost"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4691:10-39
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteOptserverHost)")
   elif (_1=="remoteTlsCertPath"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4693:10-37
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteTlsCertPath)")
   elif (_1=="remoteTlsCert"): # bld/herlev/final/default/src/fusion/Parameters.mbi:4695:10-33
    raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteTlsCert)")
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def _match_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_match_Lmosek_4fusion_4Model_2__(_0) and __arg_match_S__(_1) and __arg_match_S__(_2))
  @staticmethod
  def _match_alt_setParameter_Lmosek_4fusion_4Model_2SS(*args):
    if len(args) != 3: return False
    _0,_1,_2, = args
    return (__arg_alt_match_Lmosek_4fusion_4Model_2__(_0) and __arg_alt_match_S__(_1) and __arg_alt_match_S__(_2))
  @staticmethod
  def _setParameter_alt_Lmosek_4fusion_4Model_2SS(_t__0,_t__1,_t__2):
    return mosek_fusion_Parameters._setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2)
  @staticmethod
  def _setParameter_Lmosek_4fusion_4Model_2SS(_0,_1,_2):
   if False: # bld/herlev/final/default/src/fusion/Parameters.mbi:1850:6-11
    pass
   if (_1=="autoUpdateSolInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1851:6-33
    _3=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_3 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:1854:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (autoUpdateSolInfo)")
    _0._task_1put_1param_SI("MSK_IPAR_AUTO_UPDATE_SOL_INFO",_3)
    return 
   if (_1=="removeUnusedSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1859:6-37
    _4=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_4 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:1862:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (removeUnusedSolutions)")
    _0._task_1put_1param_SI("MSK_IPAR_REMOVE_UNUSED_SOLUTIONS",_4)
    return 
   if (_1=="numThreads"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1867:6-26
    try:
     _5=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _5): # bld/herlev/final/default/src/fusion/Parameters.mbi:1872:10-16
      _0._task_1put_1param_SI("MSK_IPAR_NUM_THREADS",_5)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
    except mosek_fusion_ValueConversionError as _6:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (numThreads)")
   if (_1=="mtSpincount"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1879:6-27
    try:
     _7=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _7) and (_7 <= 1000000000)): # bld/herlev/final/default/src/fusion/Parameters.mbi:1884:10-36
      _0._task_1put_1param_SI("MSK_IPAR_MT_SPINCOUNT",_7)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
    except mosek_fusion_ValueConversionError as _8:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mtSpincount)")
   if (_1=="optimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1891:6-25
    _9=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_9 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:1894:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_OPTIMIZER",_9)
    return 
   if (_1=="biMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1899:6-31
    try:
     _10=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _10): # bld/herlev/final/default/src/fusion/Parameters.mbi:1904:10-16
      _0._task_1put_1param_SI("MSK_IPAR_BI_MAX_ITERATIONS",_10)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
    except mosek_fusion_ValueConversionError as _11:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biMaxIterations)")
   if (_1=="licenseTrhExpiryWrn"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1911:6-35
    try:
     _12=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _12): # bld/herlev/final/default/src/fusion/Parameters.mbi:1916:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_TRH_EXPIRY_WRN",_12)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
    except mosek_fusion_ValueConversionError as _13:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseTrhExpiryWrn)")
   if (_1=="logCutSecondOpt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1923:6-31
    try:
     _14=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _14): # bld/herlev/final/default/src/fusion/Parameters.mbi:1928:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_CUT_SECOND_OPT",_14)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
    except mosek_fusion_ValueConversionError as _15:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logCutSecondOpt)")
   if (_1=="logResponse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1935:6-27
    try:
     _16=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _16): # bld/herlev/final/default/src/fusion/Parameters.mbi:1940:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_RESPONSE",_16)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
    except mosek_fusion_ValueConversionError as _17:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logResponse)")
   if (_1=="logLocalInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1947:6-28
    _18=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_18 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:1950:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logLocalInfo)")
    _0._task_1put_1param_SI("MSK_IPAR_LOG_LOCAL_INFO",_18)
    return 
   if (_1=="logBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1955:6-21
    try:
     _19=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _19): # bld/herlev/final/default/src/fusion/Parameters.mbi:1960:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI",_19)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
    except mosek_fusion_ValueConversionError as _20:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBi)")
   if (_1=="logBiFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1967:6-25
    try:
     _21=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _21): # bld/herlev/final/default/src/fusion/Parameters.mbi:1972:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_BI_FREQ",_21)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
    except mosek_fusion_ValueConversionError as _22:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logBiFreq)")
   if (_1=="biCleanOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1979:6-32
    _23=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_23 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:1982:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biCleanOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_CLEAN_OPTIMIZER",_23)
    return 
   if (_1=="intpntStartingPoint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1987:6-35
    _24=mosek.fusion.Parameters.__string_1to_1startpointtype_1value_S(_2)
    if (_24 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:1990:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntStartingPoint)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_STARTING_POINT",_24)
    return 
   if (_1=="intpntDiffStep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1995:6-30
    _25=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_25 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:1998:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntDiffStep)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_DIFF_STEP",_25)
    return 
   if (_1=="intpntScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2003:6-29
    _26=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_26 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2006:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SCALING",_26)
    return 
   if (_1=="intpntSolveForm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2011:6-31
    _27=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_27 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2014:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_SOLVE_FORM",_27)
    return 
   if (_1=="logIntpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2019:6-25
    try:
     _28=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _28): # bld/herlev/final/default/src/fusion/Parameters.mbi:2024:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INTPNT",_28)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
    except mosek_fusion_ValueConversionError as _29:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logIntpnt)")
   if (_1=="intpntMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2031:6-35
    try:
     _30=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _30): # bld/herlev/final/default/src/fusion/Parameters.mbi:2036:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_ITERATIONS",_30)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
    except mosek_fusion_ValueConversionError as _31:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxIterations)")
   if (_1=="intpntOffColTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2043:6-31
    try:
     _32=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _32): # bld/herlev/final/default/src/fusion/Parameters.mbi:2048:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_OFF_COL_TRH",_32)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
    except mosek_fusion_ValueConversionError as _33:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOffColTrh)")
   if (_1=="intpntOrderMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2055:6-33
    _34=mosek.fusion.Parameters.__string_1to_1orderingtype_1value_S(_2)
    if (_34 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2058:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_METHOD",_34)
    return 
   if (_1=="intpntOrderGpNumSeeds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2063:6-37
    try:
     _35=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _35): # bld/herlev/final/default/src/fusion/Parameters.mbi:2068:10-16
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS",_35)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
    except mosek_fusion_ValueConversionError as _36:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntOrderGpNumSeeds)")
   if (_1=="intpntBasis"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2075:6-27
    _37=mosek.fusion.Parameters.__string_1to_1basindtype_1value_S(_2)
    if (_37 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2078:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntBasis)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_BASIS",_37)
    return 
   if (_1=="biIgnoreMaxIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2083:6-31
    _38=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_38 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2086:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreMaxIter)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_MAX_ITER",_38)
    return 
   if (_1=="biIgnoreNumError"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2091:6-32
    _39=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_39 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2094:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (biIgnoreNumError)")
    _0._task_1put_1param_SI("MSK_IPAR_BI_IGNORE_NUM_ERROR",_39)
    return 
   if (_1=="intpntMaxNumCor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2099:6-31
    try:
     _40=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _40): # bld/herlev/final/default/src/fusion/Parameters.mbi:2104:10-17
      _0._task_1put_1param_SI("MSK_IPAR_INTPNT_MAX_NUM_COR",_40)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
    except mosek_fusion_ValueConversionError as _41:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntMaxNumCor)")
   if (_1=="presolveUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2111:6-27
    _42=mosek.fusion.Parameters.__string_1to_1presolvemode_1value_S(_2)
    if (_42 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2114:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_USE",_42)
    return 
   if (_1=="presolveLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2119:6-29
    try:
     _43=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2124:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LEVEL",_43)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
    except mosek_fusion_ValueConversionError as _44:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLevel)")
   if (_1=="logPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2131:6-27
    try:
     _45=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _45): # bld/herlev/final/default/src/fusion/Parameters.mbi:2136:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_PRESOLVE",_45)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
    except mosek_fusion_ValueConversionError as _46:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logPresolve)")
   if (_1=="presolveLindepUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2143:6-33
    _47=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_47 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2146:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepUse)")
    _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_USE",_47)
    return 
   if (_1=="presolveMaxNumPass"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2151:6-34
    try:
     _48=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2156:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_MAX_NUM_PASS",_48)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
    except mosek_fusion_ValueConversionError as _49:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveMaxNumPass)")
   if (_1=="presolveEliminatorMaxNumTries"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2163:6-45
    try:
     _50=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2168:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES",_50)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
    except mosek_fusion_ValueConversionError as _51:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxNumTries)")
   if (_1=="presolveEliminatorMaxFill"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2175:6-41
    try:
     _52=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2180:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL",_52)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
    except mosek_fusion_ValueConversionError as _53:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveEliminatorMaxFill)")
   if (_1=="simPrimalCrash"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2187:6-30
    try:
     _54=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _54): # bld/herlev/final/default/src/fusion/Parameters.mbi:2192:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_CRASH",_54)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
    except mosek_fusion_ValueConversionError as _55:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalCrash)")
   if (_1=="logSim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2199:6-22
    try:
     _56=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _56): # bld/herlev/final/default/src/fusion/Parameters.mbi:2204:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM",_56)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
    except mosek_fusion_ValueConversionError as _57:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSim)")
   if (_1=="logSimMinor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2211:6-27
    try:
     _58=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _58): # bld/herlev/final/default/src/fusion/Parameters.mbi:2216:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_MINOR",_58)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
    except mosek_fusion_ValueConversionError as _59:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimMinor)")
   if (_1=="logSimFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2223:6-26
    try:
     _60=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _60): # bld/herlev/final/default/src/fusion/Parameters.mbi:2228:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_SIM_FREQ",_60)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
    except mosek_fusion_ValueConversionError as _61:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logSimFreq)")
   if (_1=="simPrimalRestrictSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2235:6-42
    try:
     _62=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _62) and (_62 <= 100)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2240:10-29
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION",_62)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
    except mosek_fusion_ValueConversionError as _63:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalRestrictSelection)")
   if (_1=="simPrimalSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2247:6-34
    _64=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_64 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2250:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_SELECTION",_64)
    return 
   if (_1=="simDualRestrictSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2255:6-40
    try:
     _65=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _65) and (_65 <= 100)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2260:10-29
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION",_65)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
    except mosek_fusion_ValueConversionError as _66:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualRestrictSelection)")
   if (_1=="simDualSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2267:6-32
    _67=mosek.fusion.Parameters.__string_1to_1simseltype_1value_S(_2)
    if (_67 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2270:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_SELECTION",_67)
    return 
   if (_1=="simMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2275:6-32
    try:
     _68=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _68): # bld/herlev/final/default/src/fusion/Parameters.mbi:2280:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_ITERATIONS",_68)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
    except mosek_fusion_ValueConversionError as _69:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxIterations)")
   if (_1=="simHotstartLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2287:6-29
    _70=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_70 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2290:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstartLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART_LU",_70)
    return 
   if (_1=="simRefactorFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2295:6-31
    try:
     _71=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _71): # bld/herlev/final/default/src/fusion/Parameters.mbi:2300:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_REFACTOR_FREQ",_71)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
    except mosek_fusion_ValueConversionError as _72:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simRefactorFreq)")
   if (_1=="simSeed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2307:6-23
    try:
     _73=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _73) and (_73 <= 32749)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2312:10-31
      _0._task_1put_1param_SI("MSK_IPAR_SIM_SEED",_73)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
    except mosek_fusion_ValueConversionError as _74:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSeed)")
   if (_1=="mioMode"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2319:6-23
    _75=mosek.fusion.Parameters.__string_1to_1miomode_1value_S(_2)
    if (_75 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2322:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMode)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_MODE",_75)
    return 
   if (_1=="logMio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2327:6-22
    try:
     _76=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _76): # bld/herlev/final/default/src/fusion/Parameters.mbi:2332:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO",_76)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
    except mosek_fusion_ValueConversionError as _77:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMio)")
   if (_1=="logMioFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2339:6-26
    try:
     _78=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2344:10-14
      _0._task_1put_1param_SI("MSK_IPAR_LOG_MIO_FREQ",_78)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
    except mosek_fusion_ValueConversionError as _79:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logMioFreq)")
   if (_1=="mioMaxNumRelaxs"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2351:6-31
    try:
     _80=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2356:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_RELAXS",_80)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
    except mosek_fusion_ValueConversionError as _81:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRelaxs)")
   if (_1=="mioMaxNumBranches"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2363:6-33
    try:
     _82=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2368:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_BRANCHES",_82)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
    except mosek_fusion_ValueConversionError as _83:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumBranches)")
   if (_1=="mioMaxNumRootCutRounds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2375:6-38
    try:
     _84=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _84): # bld/herlev/final/default/src/fusion/Parameters.mbi:2380:10-16
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS",_84)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
    except mosek_fusion_ValueConversionError as _85:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumRootCutRounds)")
   if (_1=="mioMaxNumSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2387:6-34
    try:
     _86=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2392:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MAX_NUM_SOLUTIONS",_86)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
    except mosek_fusion_ValueConversionError as _87:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxNumSolutions)")
   if (_1=="mioNodeSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2399:6-32
    _88=mosek.fusion.Parameters.__string_1to_1mionodeseltype_1value_S(_2)
    if (_88 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2402:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeSelection)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_SELECTION",_88)
    return 
   if (_1=="mioHeuristicLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2407:6-33
    try:
     _89=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2412:10-14
      _0._task_1put_1param_SI("MSK_IPAR_MIO_HEURISTIC_LEVEL",_89)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
    except mosek_fusion_ValueConversionError as _90:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioHeuristicLevel)")
   if (_1=="mioProbingLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2419:6-31
    try:
     _91=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _91) and (_91 <= 3)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2424:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_PROBING_LEVEL",_91)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
    except mosek_fusion_ValueConversionError as _92:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioProbingLevel)")
   if (_1=="mioSymmetryLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2431:6-32
    try:
     _93=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _93) and (_93 <= 4)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2436:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_SYMMETRY_LEVEL",_93)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
    except mosek_fusion_ValueConversionError as _94:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSymmetryLevel)")
   if (_1=="mioPresolveAggregatorUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2443:6-40
    _95=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_95 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2446:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPresolveAggregatorUse)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE",_95)
    return 
   if (_1=="mioNumericalEmphasisLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2451:6-41
    try:
     _96=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _96) and (_96 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2456:10-27
      _0._task_1put_1param_SI("MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL",_96)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
    except mosek_fusion_ValueConversionError as _97:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNumericalEmphasisLevel)")
   if (_1=="mioMemoryEmphasisLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2463:6-38
    try:
     _98=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _98) and (_98 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2468:10-27
      _0._task_1put_1param_SI("MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL",_98)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
    except mosek_fusion_ValueConversionError as _99:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMemoryEmphasisLevel)")
   if (_1=="mioCutSelectionLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2475:6-36
    try:
     _100=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _100) and (_100 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2480:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_SELECTION_LEVEL",_100)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
    except mosek_fusion_ValueConversionError as _101:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutSelectionLevel)")
   if (_1=="mioVbDetectionLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2487:6-35
    try:
     _102=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _102) and (_102 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2492:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_VB_DETECTION_LEVEL",_102)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
    except mosek_fusion_ValueConversionError as _103:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioVbDetectionLevel)")
   if (_1=="mioBranchDir"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2499:6-28
    _104=mosek.fusion.Parameters.__string_1to_1branchdir_1value_S(_2)
    if (_104 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2502:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioBranchDir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_BRANCH_DIR",_104)
    return 
   if (_1=="mioRootOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2507:6-32
    _105=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_105 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2510:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_OPTIMIZER",_105)
    return 
   if (_1=="mioNodeOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2515:6-32
    _106=mosek.fusion.Parameters.__string_1to_1optimizertype_1value_S(_2)
    if (_106 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2518:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioNodeOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_NODE_OPTIMIZER",_106)
    return 
   if (_1=="mioPerspectiveReformulate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2523:6-41
    _107=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_107 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2526:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPerspectiveReformulate)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE",_107)
    return 
   if (_1=="mioPropagateObjectiveConstraint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2531:6-47
    _108=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_108 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2534:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioPropagateObjectiveConstraint)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT",_108)
    return 
   if (_1=="mioSeed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2539:6-23
    try:
     _109=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _109): # bld/herlev/final/default/src/fusion/Parameters.mbi:2544:10-16
      _0._task_1put_1param_SI("MSK_IPAR_MIO_SEED",_109)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
    except mosek_fusion_ValueConversionError as _110:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioSeed)")
   if (_1=="mioConicOuterApproximation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2551:6-42
    _111=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_111 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2554:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConicOuterApproximation)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION",_111)
    return 
   if (_1=="mioQcqoReformulationMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2559:6-42
    _112=mosek.fusion.Parameters.__string_1to_1miqcqoreformmethod_1value_S(_2)
    if (_112 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2562:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioQcqoReformulationMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD",_112)
    return 
   if (_1=="mioDataPermutationMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2567:6-40
    _113=mosek.fusion.Parameters.__string_1to_1miodatapermmethod_1value_S(_2)
    if (_113 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2570:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDataPermutationMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_DATA_PERMUTATION_METHOD",_113)
    return 
   if (_1=="writeLpLineWidth"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2575:6-32
    try:
     _114=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (40 <= _114): # bld/herlev/final/default/src/fusion/Parameters.mbi:2580:10-17
      _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_LINE_WIDTH",_114)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
    except mosek_fusion_ValueConversionError as _115:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpLineWidth)")
   if (_1=="writeLpFullObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2587:6-30
    _116=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_116 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2590:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeLpFullObj)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_LP_FULL_OBJ",_116)
    return 
   if (_1=="writeJsonIndentation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2595:6-36
    _117=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_117 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2598:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (writeJsonIndentation)")
    _0._task_1put_1param_SI("MSK_IPAR_WRITE_JSON_INDENTATION",_117)
    return 
   if (_1=="infeasReportAuto"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2603:6-32
    _118=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_118 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2606:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasReportAuto)")
    _0._task_1put_1param_SI("MSK_IPAR_INFEAS_REPORT_AUTO",_118)
    return 
   if (_1=="logInfeasAna"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2611:6-28
    try:
     _119=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _119): # bld/herlev/final/default/src/fusion/Parameters.mbi:2616:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_INFEAS_ANA",_119)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
    except mosek_fusion_ValueConversionError as _120:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logInfeasAna)")
   if (_1=="licenseWait"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2623:6-27
    _121=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_121 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2626:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseWait)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_WAIT",_121)
    return 
   if (_1=="licenseSuppressExpireWrns"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2631:6-41
    _122=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_122 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2634:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseSuppressExpireWrns)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS",_122)
    return 
   if (_1=="licensePauseTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2639:6-32
    try:
     _123=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _123) and (_123 <= 1000000)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2644:10-33
      _0._task_1put_1param_SI("MSK_IPAR_LICENSE_PAUSE_TIME",_123)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
    except mosek_fusion_ValueConversionError as _124:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licensePauseTime)")
   if (_1=="licenseDebug"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2651:6-28
    _125=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_125 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2654:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (licenseDebug)")
    _0._task_1put_1param_SI("MSK_IPAR_LICENSE_DEBUG",_125)
    return 
   if (_1=="log"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2659:6-19
    try:
     _126=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _126): # bld/herlev/final/default/src/fusion/Parameters.mbi:2664:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG",_126)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
    except mosek_fusion_ValueConversionError as _127:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (log)")
   if (_1=="logExpand"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2671:6-25
    try:
     _128=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _128): # bld/herlev/final/default/src/fusion/Parameters.mbi:2676:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_EXPAND",_128)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
    except mosek_fusion_ValueConversionError as _129:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logExpand)")
   if (_1=="logFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2683:6-23
    try:
     _130=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _130): # bld/herlev/final/default/src/fusion/Parameters.mbi:2688:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_FILE",_130)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
    except mosek_fusion_ValueConversionError as _131:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logFile)")
   if (_1=="logOrder"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2695:6-24
    try:
     _132=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _132): # bld/herlev/final/default/src/fusion/Parameters.mbi:2700:10-16
      _0._task_1put_1param_SI("MSK_IPAR_LOG_ORDER",_132)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
    except mosek_fusion_ValueConversionError as _133:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (logOrder)")
   if (_1=="simScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2707:6-26
    _134=mosek.fusion.Parameters.__string_1to_1scalingtype_1value_S(_2)
    if (_134 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2710:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScaling)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING",_134)
    return 
   if (_1=="simScalingMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2715:6-32
    _135=mosek.fusion.Parameters.__string_1to_1scalingmethod_1value_S(_2)
    if (_135 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2718:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simScalingMethod)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SCALING_METHOD",_135)
    return 
   if (_1=="simPrimalPhaseoneMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2723:6-39
    try:
     _136=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _136) and (_136 <= 10)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2728:10-28
      _0._task_1put_1param_SI("MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD",_136)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _137:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simPrimalPhaseoneMethod)")
   if (_1=="simDualPhaseoneMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2735:6-37
    try:
     _138=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((0 <= _138) and (_138 <= 10)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2740:10-28
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_PHASEONE_METHOD",_138)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
    except mosek_fusion_ValueConversionError as _139:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualPhaseoneMethod)")
   if (_1=="simMaxNumSetbacks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2747:6-33
    try:
     _140=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _140): # bld/herlev/final/default/src/fusion/Parameters.mbi:2752:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_MAX_NUM_SETBACKS",_140)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
    except mosek_fusion_ValueConversionError as _141:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simMaxNumSetbacks)")
   if (_1=="simHotstart"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2759:6-27
    _142=mosek.fusion.Parameters.__string_1to_1simhotstart_1value_S(_2)
    if (_142 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2762:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simHotstart)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_HOTSTART",_142)
    return 
   if (_1=="simBasisFactorUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2767:6-33
    _143=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_143 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2770:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simBasisFactorUse)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_BASIS_FACTOR_USE",_143)
    return 
   if (_1=="simDegen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2775:6-24
    _144=mosek.fusion.Parameters.__string_1to_1simdegen_1value_S(_2)
    if (_144 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2778:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDegen)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_DEGEN",_144)
    return 
   if (_1=="simReformulation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2783:6-32
    _145=mosek.fusion.Parameters.__string_1to_1simreform_1value_S(_2)
    if (_145 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2786:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simReformulation)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_REFORMULATION",_145)
    return 
   if (_1=="simExploitDupvec"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2791:6-32
    _146=mosek.fusion.Parameters.__string_1to_1simdupvec_1value_S(_2)
    if (_146 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2794:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simExploitDupvec)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_EXPLOIT_DUPVEC",_146)
    return 
   if (_1=="simSaveLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2799:6-25
    _147=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_147 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2802:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSaveLu)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SAVE_LU",_147)
    return 
   if (_1=="simNonSingular"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2807:6-30
    _148=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_148 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2810:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simNonSingular)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_NON_SINGULAR",_148)
    return 
   if (_1=="simDualCrash"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2815:6-28
    try:
     _149=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (0 <= _149): # bld/herlev/final/default/src/fusion/Parameters.mbi:2820:10-16
      _0._task_1put_1param_SI("MSK_IPAR_SIM_DUAL_CRASH",_149)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
    except mosek_fusion_ValueConversionError as _150:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simDualCrash)")
   if (_1=="infeasPreferPrimal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2827:6-34
    _151=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_151 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2830:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (infeasPreferPrimal)")
    _0._task_1put_1param_SI("MSK_IPAR_INFEAS_PREFER_PRIMAL",_151)
    return 
   if (_1=="mioRootRepeatPresolveLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2835:6-42
    try:
     _152=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _152) and (_152 <= 1)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2840:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL",_152)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
    except mosek_fusion_ValueConversionError as _153:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRootRepeatPresolveLevel)")
   if (_1=="mioCutCmir"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2847:6-26
    _154=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_154 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2850:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutCmir)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CMIR",_154)
    return 
   if (_1=="mioCutClique"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2855:6-28
    _155=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_155 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2858:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutClique)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_CLIQUE",_155)
    return 
   if (_1=="mioCutImpliedBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2863:6-34
    _156=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_156 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2866:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutImpliedBound)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_IMPLIED_BOUND",_156)
    return 
   if (_1=="mioCutKnapsackCover"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2871:6-35
    _157=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_157 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2874:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutKnapsackCover)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_KNAPSACK_COVER",_157)
    return 
   if (_1=="mioCutGmi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2879:6-25
    _158=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_158 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2882:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutGmi)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_GMI",_158)
    return 
   if (_1=="mioCutLipro"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2887:6-27
    _159=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_159 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2890:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioCutLipro)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CUT_LIPRO",_159)
    return 
   if (_1=="mioConstructSol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2895:6-31
    _160=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_160 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2898:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioConstructSol)")
    _0._task_1put_1param_SI("MSK_IPAR_MIO_CONSTRUCT_SOL",_160)
    return 
   if (_1=="presolveLindepRelWorkTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2903:6-40
    try:
     _161=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2908:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH",_161)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
    except mosek_fusion_ValueConversionError as _162:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepRelWorkTrh)")
   if (_1=="presolveLindepAbsWorkTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2915:6-40
    try:
     _163=mosek.fusion.Utils.Tools._toInt_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2920:10-14
      _0._task_1put_1param_SI("MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH",_163)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
    except mosek_fusion_ValueConversionError as _164:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveLindepAbsWorkTrh)")
   if (_1=="cacheLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2927:6-28
    _165=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_165 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2930:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (cacheLicense)")
    _0._task_1put_1param_SI("MSK_IPAR_CACHE_LICENSE",_165)
    return 
   if (_1=="intpntRegularizationUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2935:6-39
    _166=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_166 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2938:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntRegularizationUse)")
    _0._task_1put_1param_SI("MSK_IPAR_INTPNT_REGULARIZATION_USE",_166)
    return 
   if (_1=="simSolveForm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2943:6-28
    _167=mosek.fusion.Parameters.__string_1to_1solveform_1value_S(_2)
    if (_167 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2946:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSolveForm)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SOLVE_FORM",_167)
    return 
   if (_1=="simSwitchOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2951:6-34
    _168=mosek.fusion.Parameters.__string_1to_1onoffkey_1value_S(_2)
    if (_168 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2954:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simSwitchOptimizer)")
    _0._task_1put_1param_SI("MSK_IPAR_SIM_SWITCH_OPTIMIZER",_168)
    return 
   if (_1=="mioRinsMaxNodes"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2959:6-31
    try:
     _169=mosek.fusion.Utils.Tools._toInt_S(_2)
     if ((- 1) <= _169): # bld/herlev/final/default/src/fusion/Parameters.mbi:2964:10-17
      _0._task_1put_1param_SI("MSK_IPAR_MIO_RINS_MAX_NODES",_169)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
    except mosek_fusion_ValueConversionError as _170:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRinsMaxNodes)")
   if (_1=="mioFeaspumpLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2971:6-32
    try:
     _171=mosek.fusion.Utils.Tools._toInt_S(_2)
     if (((- 1) <= _171) and (_171 <= 2)): # bld/herlev/final/default/src/fusion/Parameters.mbi:2976:10-28
      _0._task_1put_1param_SI("MSK_IPAR_MIO_FEASPUMP_LEVEL",_171)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
    except mosek_fusion_ValueConversionError as _172:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioFeaspumpLevel)")
   if (_1=="remoteUseCompression"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2983:6-36
    _173=mosek.fusion.Parameters.__string_1to_1compresstype_1value_S(_2)
    if (_173 < 0): # bld/herlev/final/default/src/fusion/Parameters.mbi:2986:8-13
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (remoteUseCompression)")
    _0._task_1put_1param_SI("MSK_IPAR_REMOTE_USE_COMPRESSION",_173)
    return 
   if (_1=="optimizerMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:2991:6-32
    try:
     _174=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:2996:10-14
      _0._task_1put_1param_SD("MSK_DPAR_OPTIMIZER_MAX_TIME",_174)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
    except mosek_fusion_ValueConversionError as _175:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (optimizerMaxTime)")
   if (_1=="lowerObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3005:6-27
    try:
     _176=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3010:10-14
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT",_176)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
    except mosek_fusion_ValueConversionError as _177:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCut)")
   if (_1=="upperObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3019:6-27
    try:
     _178=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3024:10-14
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT",_178)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
    except mosek_fusion_ValueConversionError as _179:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCut)")
   if (_1=="upperObjCutFiniteTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3033:6-36
    try:
     _180=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3038:10-14
      _0._task_1put_1param_SD("MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH",_180)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _181:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (upperObjCutFiniteTrh)")
   if (_1=="lowerObjCutFiniteTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3047:6-36
    try:
     _182=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3052:10-14
      _0._task_1put_1param_SD("MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH",_182)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
    except mosek_fusion_ValueConversionError as _183:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (lowerObjCutFiniteTrh)")
   if (_1=="intpntTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3061:6-31
    try:
     _184=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-14 <= _184): # bld/herlev/final/default/src/fusion/Parameters.mbi:3066:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_GAP",_184)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
    except mosek_fusion_ValueConversionError as _185:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelGap)")
   if (_1=="intpntTolStepSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3075:6-33
    try:
     _186=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _186) and (_186 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3080:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_STEP_SIZE",_186)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
    except mosek_fusion_ValueConversionError as _187:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolStepSize)")
   if (_1=="simLuTolRelPiv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3089:6-30
    try:
     _188=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-06 <= _188) and (_188 <= 9.999990e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3094:10-49
      _0._task_1put_1param_SD("MSK_DPAR_SIM_LU_TOL_REL_PIV",_188)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
    except mosek_fusion_ValueConversionError as _189:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simLuTolRelPiv)")
   if (_1=="intpntTolRelStep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3103:6-32
    try:
     _190=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-04 <= _190) and (_190 <= 9.999990e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3108:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_REL_STEP",_190)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
    except mosek_fusion_ValueConversionError as _191:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolRelStep)")
   if (_1=="intpntTolPath"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3117:6-29
    try:
     _192=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _192) and (_192 <= 9.999000e-01)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3122:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PATH",_192)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
    except mosek_fusion_ValueConversionError as _193:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPath)")
   if (_1=="intpntTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3131:6-30
    try:
     _194=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _194) and (_194 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3136:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PFEAS",_194)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
    except mosek_fusion_ValueConversionError as _195:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPfeas)")
   if (_1=="intpntTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3145:6-30
    try:
     _196=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _196) and (_196 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3150:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DFEAS",_196)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
    except mosek_fusion_ValueConversionError as _197:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDfeas)")
   if (_1=="intpntTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3159:6-30
    try:
     _198=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _198) and (_198 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3164:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_MU_RED",_198)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
    except mosek_fusion_ValueConversionError as _199:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolMuRed)")
   if (_1=="intpntTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3173:6-31
    try:
     _200=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _200) and (_200 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3178:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_INFEAS",_200)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
    except mosek_fusion_ValueConversionError as _201:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolInfeas)")
   if (_1=="intpntCoTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3187:6-33
    try:
     _202=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _202) and (_202 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3192:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_REL_GAP",_202)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
    except mosek_fusion_ValueConversionError as _203:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolRelGap)")
   if (_1=="intpntCoTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3201:6-32
    try:
     _204=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _204) and (_204 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3206:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_PFEAS",_204)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
    except mosek_fusion_ValueConversionError as _205:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolPfeas)")
   if (_1=="intpntCoTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3215:6-32
    try:
     _206=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _206) and (_206 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3220:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_DFEAS",_206)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
    except mosek_fusion_ValueConversionError as _207:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolDfeas)")
   if (_1=="intpntCoTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3229:6-32
    try:
     _208=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _208) and (_208 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3234:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_MU_RED",_208)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
    except mosek_fusion_ValueConversionError as _209:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolMuRed)")
   if (_1=="intpntCoTolNearRel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3243:6-34
    try:
     _210=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e+00 <= _210): # bld/herlev/final/default/src/fusion/Parameters.mbi:3248:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_NEAR_REL",_210)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
    except mosek_fusion_ValueConversionError as _211:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolNearRel)")
   if (_1=="intpntCoTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3257:6-33
    try:
     _212=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _212) and (_212 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3262:10-49
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_CO_TOL_INFEAS",_212)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
    except mosek_fusion_ValueConversionError as _213:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntCoTolInfeas)")
   if (_1=="intpntTolPsafe"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3271:6-30
    try:
     _214=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _214): # bld/herlev/final/default/src/fusion/Parameters.mbi:3276:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_PSAFE",_214)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
    except mosek_fusion_ValueConversionError as _215:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolPsafe)")
   if (_1=="intpntTolDsafe"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3285:6-30
    try:
     _216=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-04 <= _216): # bld/herlev/final/default/src/fusion/Parameters.mbi:3290:10-27
      _0._task_1put_1param_SD("MSK_DPAR_INTPNT_TOL_DSAFE",_216)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
    except mosek_fusion_ValueConversionError as _217:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (intpntTolDsafe)")
   if (_1=="mioMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3299:6-26
    try:
     _218=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if True: # bld/herlev/final/default/src/fusion/Parameters.mbi:3304:10-14
      _0._task_1put_1param_SD("MSK_DPAR_MIO_MAX_TIME",_218)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
    except mosek_fusion_ValueConversionError as _219:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioMaxTime)")
   if (_1=="mioRelGapConst"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3313:6-30
    try:
     _220=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _220): # bld/herlev/final/default/src/fusion/Parameters.mbi:3318:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_REL_GAP_CONST",_220)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
    except mosek_fusion_ValueConversionError as _221:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioRelGapConst)")
   if (_1=="mioTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3327:6-28
    try:
     _222=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _222): # bld/herlev/final/default/src/fusion/Parameters.mbi:3332:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_GAP",_222)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
    except mosek_fusion_ValueConversionError as _223:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelGap)")
   if (_1=="mioTolAbsGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3341:6-28
    try:
     _224=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _224): # bld/herlev/final/default/src/fusion/Parameters.mbi:3346:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_GAP",_224)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
    except mosek_fusion_ValueConversionError as _225:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsGap)")
   if (_1=="mioTolAbsRelaxInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3355:6-33
    try:
     _226=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _226): # bld/herlev/final/default/src/fusion/Parameters.mbi:3360:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_ABS_RELAX_INT",_226)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
    except mosek_fusion_ValueConversionError as _227:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolAbsRelaxInt)")
   if (_1=="mioDjcMaxBigm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3369:6-29
    try:
     _228=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _228): # bld/herlev/final/default/src/fusion/Parameters.mbi:3374:10-27
      _0._task_1put_1param_SD("MSK_DPAR_MIO_DJC_MAX_BIGM",_228)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDjcMaxBigm)")
    except mosek_fusion_ValueConversionError as _229:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioDjcMaxBigm)")
   if (_1=="basisTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3383:6-25
    try:
     _230=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _230): # bld/herlev/final/default/src/fusion/Parameters.mbi:3388:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_X",_230)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
    except mosek_fusion_ValueConversionError as _231:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolX)")
   if (_1=="basisTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3397:6-25
    try:
     _232=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-09 <= _232): # bld/herlev/final/default/src/fusion/Parameters.mbi:3402:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_TOL_S",_232)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
    except mosek_fusion_ValueConversionError as _233:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisTolS)")
   if (_1=="basisRelTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3411:6-28
    try:
     _234=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _234): # bld/herlev/final/default/src/fusion/Parameters.mbi:3416:10-27
      _0._task_1put_1param_SD("MSK_DPAR_BASIS_REL_TOL_S",_234)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
    except mosek_fusion_ValueConversionError as _235:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (basisRelTolS)")
   if (_1=="presolveTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3425:6-28
    try:
     _236=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _236): # bld/herlev/final/default/src/fusion/Parameters.mbi:3430:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_X",_236)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
    except mosek_fusion_ValueConversionError as _237:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolX)")
   if (_1=="presolveTolPrimalInfeasPerturbation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3439:6-51
    try:
     _238=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _238): # bld/herlev/final/default/src/fusion/Parameters.mbi:3444:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION",_238)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolPrimalInfeasPerturbation)")
    except mosek_fusion_ValueConversionError as _239:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolPrimalInfeasPerturbation)")
   if (_1=="presolveTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3453:6-28
    try:
     _240=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _240): # bld/herlev/final/default/src/fusion/Parameters.mbi:3458:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_S",_240)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
    except mosek_fusion_ValueConversionError as _241:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolS)")
   if (_1=="presolveTolAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3467:6-30
    try:
     _242=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-15 <= _242): # bld/herlev/final/default/src/fusion/Parameters.mbi:3472:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_AIJ",_242)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
    except mosek_fusion_ValueConversionError as _243:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAij)")
   if (_1=="presolveTolAbsLindep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3481:6-36
    try:
     _244=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _244): # bld/herlev/final/default/src/fusion/Parameters.mbi:3486:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP",_244)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
    except mosek_fusion_ValueConversionError as _245:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolAbsLindep)")
   if (_1=="presolveTolRelLindep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3495:6-36
    try:
     _246=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (0.000000e+00 <= _246): # bld/herlev/final/default/src/fusion/Parameters.mbi:3500:10-27
      _0._task_1put_1param_SD("MSK_DPAR_PRESOLVE_TOL_REL_LINDEP",_246)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
    except mosek_fusion_ValueConversionError as _247:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (presolveTolRelLindep)")
   if (_1=="simplexAbsTolPiv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3509:6-32
    try:
     _248=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if (1.000000e-12 <= _248): # bld/herlev/final/default/src/fusion/Parameters.mbi:3514:10-27
      _0._task_1put_1param_SD("MSK_DPAR_SIMPLEX_ABS_TOL_PIV",_248)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
    except mosek_fusion_ValueConversionError as _249:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (simplexAbsTolPiv)")
   if (_1=="mioTolFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3523:6-26
    try:
     _250=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((1.000000e-09 <= _250) and (_250 <= 1.000000e-03)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3528:10-49
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_FEAS",_250)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
    except mosek_fusion_ValueConversionError as _251:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolFeas)")
   if (_1=="mioTolRelDualBoundImprovement"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3537:6-45
    try:
     _252=mosek.fusion.Utils.Tools._toDouble_S(_2)
     if ((0.000000e+00 <= _252) and (_252 <= 1.000000e+00)): # bld/herlev/final/default/src/fusion/Parameters.mbi:3542:10-49
      _0._task_1put_1param_SD("MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT",_252)
      return 
     else:
      raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
    except mosek_fusion_ValueConversionError as _253:
     raise mosek_fusion_ParameterError._ctor_S("Invalid value for parameter (mioTolRelDualBoundImprovement)")
   if (_1=="dataFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3551:6-28
    _0._task_1put_1param_SS("MSK_SPAR_DATA_FILE_NAME",_2)
    return 
   if (_1=="basSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3556:6-30
    _0._task_1put_1param_SS("MSK_SPAR_BAS_SOL_FILE_NAME",_2)
    return 
   if (_1=="itrSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3561:6-30
    _0._task_1put_1param_SS("MSK_SPAR_ITR_SOL_FILE_NAME",_2)
    return 
   if (_1=="intSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3566:6-30
    _0._task_1put_1param_SS("MSK_SPAR_INT_SOL_FILE_NAME",_2)
    return 
   if (_1=="writeLpGenVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3571:6-33
    _0._task_1put_1param_SS("MSK_SPAR_WRITE_LP_GEN_VAR_NAME",_2)
    return 
   if (_1=="remoteOptserverHost"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3576:6-35
    _0._task_1put_1param_SS("MSK_SPAR_REMOTE_OPTSERVER_HOST",_2)
    return 
   if (_1=="remoteTlsCertPath"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3581:6-33
    _0._task_1put_1param_SS("MSK_SPAR_REMOTE_TLS_CERT_PATH",_2)
    return 
   if (_1=="remoteTlsCert"): # bld/herlev/final/default/src/fusion/Parameters.mbi:3586:6-29
    _0._task_1put_1param_SS("MSK_SPAR_REMOTE_TLS_CERT",_2)
    return 
   raise mosek_fusion_ParameterError._ctor_S("Unknown parameter")
  @staticmethod
  def __string_1to_1variabletype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1variabletype_1value_S(_0)
  @staticmethod
  def __string_1to_1variabletype_1value_S(_0):
   if (_0=="typeCont"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1843:6-21
    return numpy.int32(0)
   if (_0=="typeInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1844:6-20
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1value_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1value_1value_S(_0)
  @staticmethod
  def __string_1to_1value_1value_S(_0):
   if (_0=="maxStrLen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1837:6-22
    return numpy.int32(1024)
   if (_0=="licenseBufferLength"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1838:6-32
    return numpy.int32(21)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1streamtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1streamtype_1value_S(_0)
  @staticmethod
  def __string_1to_1streamtype_1value_S(_0):
   if (_0=="log"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1829:6-16
    return numpy.int32(0)
   if (_0=="msg"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1830:6-16
    return numpy.int32(1)
   if (_0=="err"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1831:6-16
    return numpy.int32(2)
   if (_0=="wrn"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1832:6-16
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1startpointtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1startpointtype_1value_S(_0)
  @staticmethod
  def __string_1to_1startpointtype_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1821:6-17
    return numpy.int32(0)
   if (_0=="guess"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1822:6-18
    return numpy.int32(1)
   if (_0=="constant"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1823:6-21
    return numpy.int32(2)
   if (_0=="satisfyBounds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1824:6-26
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1stakey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1stakey_1value_S(_0)
  @staticmethod
  def __string_1to_1stakey_1value_S(_0):
   if (_0=="unk"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1810:6-16
    return numpy.int32(0)
   if (_0=="bas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1811:6-16
    return numpy.int32(1)
   if (_0=="supbas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1812:6-19
    return numpy.int32(2)
   if (_0=="low"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1813:6-16
    return numpy.int32(3)
   if (_0=="upr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1814:6-16
    return numpy.int32(4)
   if (_0=="fix"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1815:6-16
    return numpy.int32(5)
   if (_0=="inf"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1816:6-16
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sparam_1value_S(_0)
  @staticmethod
  def __string_1to_1sparam_1value_S(_0):
   if (_0=="dataFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1781:6-25
    return numpy.int32(1)
   if (_0=="paramReadFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1782:6-30
    return numpy.int32(7)
   if (_0=="paramWriteFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1783:6-31
    return numpy.int32(8)
   if (_0=="paramCommentSign"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1784:6-29
    return numpy.int32(6)
   if (_0=="debugFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1785:6-26
    return numpy.int32(2)
   if (_0=="basSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1786:6-27
    return numpy.int32(0)
   if (_0=="itrSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1787:6-27
    return numpy.int32(4)
   if (_0=="intSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1788:6-27
    return numpy.int32(3)
   if (_0=="solFilterXcLow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1789:6-27
    return numpy.int32(18)
   if (_0=="solFilterXcUpr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1790:6-27
    return numpy.int32(19)
   if (_0=="solFilterXxLow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1791:6-27
    return numpy.int32(20)
   if (_0=="solFilterXxUpr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1792:6-27
    return numpy.int32(21)
   if (_0=="readMpsObjName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1793:6-27
    return numpy.int32(10)
   if (_0=="readMpsRanName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1794:6-27
    return numpy.int32(11)
   if (_0=="readMpsRhsName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1795:6-27
    return numpy.int32(12)
   if (_0=="readMpsBouName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1796:6-27
    return numpy.int32(9)
   if (_0=="statName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1797:6-21
    return numpy.int32(23)
   if (_0=="statKey"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1798:6-20
    return numpy.int32(22)
   if (_0=="writeLpGenVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1799:6-30
    return numpy.int32(24)
   if (_0=="sensitivityResFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1800:6-35
    return numpy.int32(17)
   if (_0=="sensitivityFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1801:6-32
    return numpy.int32(16)
   if (_0=="mioDebugString"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1802:6-27
    return numpy.int32(5)
   if (_0=="remoteOptserverHost"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1803:6-32
    return numpy.int32(13)
   if (_0=="remoteTlsCertPath"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1804:6-30
    return numpy.int32(15)
   if (_0=="remoteTlsCert"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1805:6-26
    return numpy.int32(14)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solveform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solveform_1value_S(_0)
  @staticmethod
  def __string_1to_1solveform_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1774:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1775:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1776:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1soltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1soltype_1value_S(_0)
  @staticmethod
  def __string_1to_1soltype_1value_S(_0):
   if (_0=="bas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1767:6-16
    return numpy.int32(1)
   if (_0=="itr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1768:6-16
    return numpy.int32(0)
   if (_0=="itg"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1769:6-16
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solsta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solsta_1value_S(_0)
  @staticmethod
  def __string_1to_1solsta_1value_S(_0):
   if (_0=="unknown"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1753:6-20
    return numpy.int32(0)
   if (_0=="optimal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1754:6-20
    return numpy.int32(1)
   if (_0=="primFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1755:6-21
    return numpy.int32(2)
   if (_0=="dualFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1756:6-21
    return numpy.int32(3)
   if (_0=="primAndDualFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1757:6-28
    return numpy.int32(4)
   if (_0=="primInfeasCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1758:6-26
    return numpy.int32(5)
   if (_0=="dualInfeasCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1759:6-26
    return numpy.int32(6)
   if (_0=="primIllposedCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1760:6-28
    return numpy.int32(7)
   if (_0=="dualIllposedCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1761:6-28
    return numpy.int32(8)
   if (_0=="integerOptimal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1762:6-27
    return numpy.int32(9)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solitem_1value_S(_0)
  @staticmethod
  def __string_1to_1solitem_1value_S(_0):
   if (_0=="xc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1741:6-15
    return numpy.int32(0)
   if (_0=="xx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1742:6-15
    return numpy.int32(1)
   if (_0=="y"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1743:6-14
    return numpy.int32(2)
   if (_0=="slc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1744:6-16
    return numpy.int32(3)
   if (_0=="suc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1745:6-16
    return numpy.int32(4)
   if (_0=="slx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1746:6-16
    return numpy.int32(5)
   if (_0=="sux"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1747:6-16
    return numpy.int32(6)
   if (_0=="snx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1748:6-16
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1simseltype_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1731:6-17
    return numpy.int32(0)
   if (_0=="full"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1732:6-17
    return numpy.int32(1)
   if (_0=="ase"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1733:6-16
    return numpy.int32(2)
   if (_0=="devex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1734:6-18
    return numpy.int32(3)
   if (_0=="se"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1735:6-15
    return numpy.int32(4)
   if (_0=="partial"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1736:6-20
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1sensitivitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1sensitivitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1sensitivitytype_1value_S(_0):
   if (_0=="basis"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1726:6-18
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingmethod_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingmethod_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingmethod_1value_S(_0):
   if (_0=="pow2"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1720:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1721:6-17
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1scalingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1scalingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1scalingtype_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1714:6-17
    return numpy.int32(0)
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1715:6-17
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescodetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescodetype_1value_S(_0)
  @staticmethod
  def __string_1to_1rescodetype_1value_S(_0):
   if (_0=="ok"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1705:6-15
    return numpy.int32(0)
   if (_0=="wrn"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1706:6-16
    return numpy.int32(1)
   if (_0=="trm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1707:6-16
    return numpy.int32(2)
   if (_0=="err"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1708:6-16
    return numpy.int32(3)
   if (_0=="unk"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1709:6-16
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1rescode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1rescode_1value_S(_0)
  @staticmethod
  def __string_1to_1rescode_1value_S(_0):
   if (_0=="ok"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1169:6-15
    return numpy.int32(0)
   if (_0=="wrnOpenParamFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1170:6-29
    return numpy.int32(50)
   if (_0=="wrnLargeBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1171:6-26
    return numpy.int32(51)
   if (_0=="wrnLargeLoBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1172:6-28
    return numpy.int32(52)
   if (_0=="wrnLargeUpBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1173:6-28
    return numpy.int32(53)
   if (_0=="wrnLargeConFx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1174:6-26
    return numpy.int32(54)
   if (_0=="wrnLargeCj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1175:6-23
    return numpy.int32(57)
   if (_0=="wrnLargeAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1176:6-24
    return numpy.int32(62)
   if (_0=="wrnZeroAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1177:6-23
    return numpy.int32(63)
   if (_0=="wrnNameMaxLen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1178:6-26
    return numpy.int32(65)
   if (_0=="wrnSparMaxLen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1179:6-26
    return numpy.int32(66)
   if (_0=="wrnMpsSplitRhsVector"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1180:6-33
    return numpy.int32(70)
   if (_0=="wrnMpsSplitRanVector"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1181:6-33
    return numpy.int32(71)
   if (_0=="wrnMpsSplitBouVector"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1182:6-33
    return numpy.int32(72)
   if (_0=="wrnLpOldQuadFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1183:6-31
    return numpy.int32(80)
   if (_0=="wrnLpDropVariable"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1184:6-30
    return numpy.int32(85)
   if (_0=="wrnNzInUprTri"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1185:6-26
    return numpy.int32(200)
   if (_0=="wrnDroppedNzQobj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1186:6-29
    return numpy.int32(201)
   if (_0=="wrnIgnoreInteger"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1187:6-29
    return numpy.int32(250)
   if (_0=="wrnNoGlobalOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1188:6-33
    return numpy.int32(251)
   if (_0=="wrnMioInfeasibleFinal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1189:6-34
    return numpy.int32(270)
   if (_0=="wrnSolFilter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1190:6-25
    return numpy.int32(300)
   if (_0=="wrnUndefSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1191:6-32
    return numpy.int32(350)
   if (_0=="wrnSolFileIgnoredCon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1192:6-33
    return numpy.int32(351)
   if (_0=="wrnSolFileIgnoredVar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1193:6-33
    return numpy.int32(352)
   if (_0=="wrnTooFewBasisVars"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1194:6-31
    return numpy.int32(400)
   if (_0=="wrnTooManyBasisVars"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1195:6-32
    return numpy.int32(405)
   if (_0=="wrnLicenseExpire"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1196:6-29
    return numpy.int32(500)
   if (_0=="wrnLicenseServer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1197:6-29
    return numpy.int32(501)
   if (_0=="wrnEmptyName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1198:6-25
    return numpy.int32(502)
   if (_0=="wrnUsingGenericNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1199:6-33
    return numpy.int32(503)
   if (_0=="wrnInvalidMpsName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1200:6-30
    return numpy.int32(504)
   if (_0=="wrnInvalidMpsObjName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1201:6-33
    return numpy.int32(505)
   if (_0=="wrnLicenseFeatureExpire"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1202:6-36
    return numpy.int32(509)
   if (_0=="wrnParamNameDou"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1203:6-28
    return numpy.int32(510)
   if (_0=="wrnParamNameInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1204:6-28
    return numpy.int32(511)
   if (_0=="wrnParamNameStr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1205:6-28
    return numpy.int32(512)
   if (_0=="wrnParamStrValue"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1206:6-29
    return numpy.int32(515)
   if (_0=="wrnParamIgnoredCmio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1207:6-32
    return numpy.int32(516)
   if (_0=="wrnZerosInSparseRow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1208:6-32
    return numpy.int32(705)
   if (_0=="wrnZerosInSparseCol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1209:6-32
    return numpy.int32(710)
   if (_0=="wrnIncompleteLinearDependencyCheck"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1210:6-47
    return numpy.int32(800)
   if (_0=="wrnEliminatorSpace"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1211:6-31
    return numpy.int32(801)
   if (_0=="wrnPresolveOutofspace"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1212:6-34
    return numpy.int32(802)
   if (_0=="wrnPresolvePrimalPertubations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1213:6-42
    return numpy.int32(803)
   if (_0=="wrnWriteChangedNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1214:6-33
    return numpy.int32(830)
   if (_0=="wrnWriteDiscardedCfix"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1215:6-34
    return numpy.int32(831)
   if (_0=="wrnDuplicateConstraintNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1216:6-40
    return numpy.int32(850)
   if (_0=="wrnDuplicateVariableNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1217:6-38
    return numpy.int32(851)
   if (_0=="wrnDuplicateBarvariableNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1218:6-41
    return numpy.int32(852)
   if (_0=="wrnDuplicateConeNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1219:6-34
    return numpy.int32(853)
   if (_0=="wrnWriteLpInvalidVarNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1220:6-38
    return numpy.int32(854)
   if (_0=="wrnWriteLpDuplicateVarNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1221:6-40
    return numpy.int32(855)
   if (_0=="wrnWriteLpInvalidConNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1222:6-38
    return numpy.int32(856)
   if (_0=="wrnWriteLpDuplicateConNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1223:6-40
    return numpy.int32(857)
   if (_0=="wrnAnaLargeBounds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1224:6-30
    return numpy.int32(900)
   if (_0=="wrnAnaCZero"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1225:6-24
    return numpy.int32(901)
   if (_0=="wrnAnaEmptyCols"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1226:6-28
    return numpy.int32(902)
   if (_0=="wrnAnaCloseBounds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1227:6-30
    return numpy.int32(903)
   if (_0=="wrnAnaAlmostIntBounds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1228:6-34
    return numpy.int32(904)
   if (_0=="wrnNoInfeasibilityReportWhenMatrixVariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1229:6-56
    return numpy.int32(930)
   if (_0=="wrnNoDualizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1230:6-26
    return numpy.int32(950)
   if (_0=="wrnSymMatLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1231:6-27
    return numpy.int32(960)
   if (_0=="wrnModifiedDoubleParameter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1232:6-39
    return numpy.int32(970)
   if (_0=="wrnLargeFij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1233:6-24
    return numpy.int32(980)
   if (_0=="errLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1234:6-23
    return numpy.int32(1000)
   if (_0=="errLicenseExpired"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1235:6-30
    return numpy.int32(1001)
   if (_0=="errLicenseVersion"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1236:6-30
    return numpy.int32(1002)
   if (_0=="errLicenseOldServerVersion"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1237:6-39
    return numpy.int32(1003)
   if (_0=="errSizeLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1238:6-27
    return numpy.int32(1005)
   if (_0=="errProbLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1239:6-27
    return numpy.int32(1006)
   if (_0=="errFileLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1240:6-27
    return numpy.int32(1007)
   if (_0=="errMissingLicenseFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1241:6-34
    return numpy.int32(1008)
   if (_0=="errSizeLicenseCon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1242:6-30
    return numpy.int32(1010)
   if (_0=="errSizeLicenseVar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1243:6-30
    return numpy.int32(1011)
   if (_0=="errSizeLicenseIntvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1244:6-33
    return numpy.int32(1012)
   if (_0=="errOptimizerLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1245:6-32
    return numpy.int32(1013)
   if (_0=="errFlexlm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1246:6-22
    return numpy.int32(1014)
   if (_0=="errLicenseServer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1247:6-29
    return numpy.int32(1015)
   if (_0=="errLicenseMax"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1248:6-26
    return numpy.int32(1016)
   if (_0=="errLicenseMoseklmDaemon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1249:6-36
    return numpy.int32(1017)
   if (_0=="errLicenseFeature"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1250:6-30
    return numpy.int32(1018)
   if (_0=="errPlatformNotLicensed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1251:6-35
    return numpy.int32(1019)
   if (_0=="errLicenseCannotAllocate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1252:6-37
    return numpy.int32(1020)
   if (_0=="errLicenseCannotConnect"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1253:6-36
    return numpy.int32(1021)
   if (_0=="errLicenseInvalidHostid"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1254:6-36
    return numpy.int32(1025)
   if (_0=="errLicenseServerVersion"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1255:6-36
    return numpy.int32(1026)
   if (_0=="errLicenseNoServerSupport"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1256:6-38
    return numpy.int32(1027)
   if (_0=="errLicenseNoServerLine"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1257:6-35
    return numpy.int32(1028)
   if (_0=="errOlderDll"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1258:6-24
    return numpy.int32(1035)
   if (_0=="errNewerDll"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1259:6-24
    return numpy.int32(1036)
   if (_0=="errLinkFileDll"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1260:6-27
    return numpy.int32(1040)
   if (_0=="errThreadMutexInit"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1261:6-31
    return numpy.int32(1045)
   if (_0=="errThreadMutexLock"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1262:6-31
    return numpy.int32(1046)
   if (_0=="errThreadMutexUnlock"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1263:6-33
    return numpy.int32(1047)
   if (_0=="errThreadCreate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1264:6-28
    return numpy.int32(1048)
   if (_0=="errThreadCondInit"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1265:6-30
    return numpy.int32(1049)
   if (_0=="errUnknown"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1266:6-23
    return numpy.int32(1050)
   if (_0=="errSpace"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1267:6-21
    return numpy.int32(1051)
   if (_0=="errFileOpen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1268:6-24
    return numpy.int32(1052)
   if (_0=="errFileRead"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1269:6-24
    return numpy.int32(1053)
   if (_0=="errFileWrite"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1270:6-25
    return numpy.int32(1054)
   if (_0=="errDataFileExt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1271:6-27
    return numpy.int32(1055)
   if (_0=="errInvalidFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1272:6-31
    return numpy.int32(1056)
   if (_0=="errInvalidSolFileName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1273:6-34
    return numpy.int32(1057)
   if (_0=="errEndOfFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1274:6-25
    return numpy.int32(1059)
   if (_0=="errNullEnv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1275:6-23
    return numpy.int32(1060)
   if (_0=="errNullTask"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1276:6-24
    return numpy.int32(1061)
   if (_0=="errInvalidStream"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1277:6-29
    return numpy.int32(1062)
   if (_0=="errNoInitEnv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1278:6-25
    return numpy.int32(1063)
   if (_0=="errInvalidTask"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1279:6-27
    return numpy.int32(1064)
   if (_0=="errNullPointer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1280:6-27
    return numpy.int32(1065)
   if (_0=="errLivingTasks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1281:6-27
    return numpy.int32(1066)
   if (_0=="errBlankName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1282:6-25
    return numpy.int32(1070)
   if (_0=="errDupName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1283:6-23
    return numpy.int32(1071)
   if (_0=="errFormatString"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1284:6-28
    return numpy.int32(1072)
   if (_0=="errSparsitySpecification"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1285:6-37
    return numpy.int32(1073)
   if (_0=="errMismatchingDimension"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1286:6-36
    return numpy.int32(1074)
   if (_0=="errInvalidObjName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1287:6-30
    return numpy.int32(1075)
   if (_0=="errInvalidConName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1288:6-30
    return numpy.int32(1076)
   if (_0=="errInvalidVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1289:6-30
    return numpy.int32(1077)
   if (_0=="errInvalidConeName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1290:6-31
    return numpy.int32(1078)
   if (_0=="errInvalidBarvarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1291:6-33
    return numpy.int32(1079)
   if (_0=="errSpaceLeaking"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1292:6-28
    return numpy.int32(1080)
   if (_0=="errSpaceNoInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1293:6-27
    return numpy.int32(1081)
   if (_0=="errDimensionSpecification"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1294:6-38
    return numpy.int32(1082)
   if (_0=="errAxisNameSpecification"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1295:6-37
    return numpy.int32(1083)
   if (_0=="errReadFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1296:6-26
    return numpy.int32(1090)
   if (_0=="errMpsFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1297:6-23
    return numpy.int32(1100)
   if (_0=="errMpsInvField"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1298:6-27
    return numpy.int32(1101)
   if (_0=="errMpsInvMarker"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1299:6-28
    return numpy.int32(1102)
   if (_0=="errMpsNullConName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1300:6-30
    return numpy.int32(1103)
   if (_0=="errMpsNullVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1301:6-30
    return numpy.int32(1104)
   if (_0=="errMpsUndefConName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1302:6-31
    return numpy.int32(1105)
   if (_0=="errMpsUndefVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1303:6-31
    return numpy.int32(1106)
   if (_0=="errMpsInvalidConKey"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1304:6-32
    return numpy.int32(1107)
   if (_0=="errMpsInvalidBoundKey"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1305:6-34
    return numpy.int32(1108)
   if (_0=="errMpsInvalidSecName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1306:6-33
    return numpy.int32(1109)
   if (_0=="errMpsNoObjective"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1307:6-30
    return numpy.int32(1110)
   if (_0=="errMpsSplittedVar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1308:6-30
    return numpy.int32(1111)
   if (_0=="errMpsMulConName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1309:6-29
    return numpy.int32(1112)
   if (_0=="errMpsMulQsec"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1310:6-26
    return numpy.int32(1113)
   if (_0=="errMpsMulQobj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1311:6-26
    return numpy.int32(1114)
   if (_0=="errMpsInvSecOrder"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1312:6-30
    return numpy.int32(1115)
   if (_0=="errMpsMulCsec"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1313:6-26
    return numpy.int32(1116)
   if (_0=="errMpsConeType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1314:6-27
    return numpy.int32(1117)
   if (_0=="errMpsConeOverlap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1315:6-30
    return numpy.int32(1118)
   if (_0=="errMpsConeRepeat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1316:6-29
    return numpy.int32(1119)
   if (_0=="errMpsNonSymmetricQ"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1317:6-32
    return numpy.int32(1120)
   if (_0=="errMpsDuplicateQElement"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1318:6-36
    return numpy.int32(1121)
   if (_0=="errMpsInvalidObjsense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1319:6-34
    return numpy.int32(1122)
   if (_0=="errMpsTabInField2"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1320:6-30
    return numpy.int32(1125)
   if (_0=="errMpsTabInField3"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1321:6-30
    return numpy.int32(1126)
   if (_0=="errMpsTabInField5"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1322:6-30
    return numpy.int32(1127)
   if (_0=="errMpsInvalidObjName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1323:6-33
    return numpy.int32(1128)
   if (_0=="errMpsInvalidKey"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1324:6-29
    return numpy.int32(1129)
   if (_0=="errMpsInvalidIndicatorConstraint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1325:6-45
    return numpy.int32(1130)
   if (_0=="errMpsInvalidIndicatorVariable"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1326:6-43
    return numpy.int32(1131)
   if (_0=="errMpsInvalidIndicatorValue"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1327:6-40
    return numpy.int32(1132)
   if (_0=="errMpsInvalidIndicatorQuadraticConstraint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1328:6-54
    return numpy.int32(1133)
   if (_0=="errOpfSyntax"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1329:6-25
    return numpy.int32(1134)
   if (_0=="errOpfPrematureEof"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1330:6-31
    return numpy.int32(1136)
   if (_0=="errOpfMismatchedTag"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1331:6-32
    return numpy.int32(1137)
   if (_0=="errOpfDuplicateBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1332:6-33
    return numpy.int32(1138)
   if (_0=="errOpfDuplicateConstraintName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1333:6-42
    return numpy.int32(1139)
   if (_0=="errOpfInvalidConeType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1334:6-34
    return numpy.int32(1140)
   if (_0=="errOpfIncorrectTagParam"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1335:6-36
    return numpy.int32(1141)
   if (_0=="errOpfInvalidTag"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1336:6-29
    return numpy.int32(1142)
   if (_0=="errOpfDuplicateConeEntry"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1337:6-37
    return numpy.int32(1143)
   if (_0=="errOpfTooLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1338:6-27
    return numpy.int32(1144)
   if (_0=="errOpfDualIntegerSolution"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1339:6-38
    return numpy.int32(1146)
   if (_0=="errLpIncompatible"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1340:6-30
    return numpy.int32(1150)
   if (_0=="errLpEmpty"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1341:6-23
    return numpy.int32(1151)
   if (_0=="errLpDupSlackName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1342:6-30
    return numpy.int32(1152)
   if (_0=="errWriteMpsInvalidName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1343:6-35
    return numpy.int32(1153)
   if (_0=="errLpInvalidVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1344:6-32
    return numpy.int32(1154)
   if (_0=="errLpFreeConstraint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1345:6-32
    return numpy.int32(1155)
   if (_0=="errWriteOpfInvalidVarName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1346:6-38
    return numpy.int32(1156)
   if (_0=="errLpFileFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1347:6-28
    return numpy.int32(1157)
   if (_0=="errWriteLpFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1348:6-29
    return numpy.int32(1158)
   if (_0=="errReadLpMissingEndTag"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1349:6-35
    return numpy.int32(1159)
   if (_0=="errLpIndicatorVar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1350:6-30
    return numpy.int32(1160)
   if (_0=="errWriteLpNonUniqueName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1351:6-36
    return numpy.int32(1161)
   if (_0=="errReadLpNonexistingName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1352:6-37
    return numpy.int32(1162)
   if (_0=="errLpWriteConicProblem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1353:6-35
    return numpy.int32(1163)
   if (_0=="errLpWriteGecoProblem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1354:6-34
    return numpy.int32(1164)
   if (_0=="errWritingFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1355:6-27
    return numpy.int32(1166)
   if (_0=="errInvalidNameInSolFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1356:6-36
    return numpy.int32(1170)
   if (_0=="errLpInvalidConName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1357:6-32
    return numpy.int32(1171)
   if (_0=="errJsonSyntax"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1358:6-26
    return numpy.int32(1175)
   if (_0=="errJsonString"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1359:6-26
    return numpy.int32(1176)
   if (_0=="errJsonNumberOverflow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1360:6-34
    return numpy.int32(1177)
   if (_0=="errJsonFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1361:6-26
    return numpy.int32(1178)
   if (_0=="errJsonData"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1362:6-24
    return numpy.int32(1179)
   if (_0=="errJsonMissingData"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1363:6-31
    return numpy.int32(1180)
   if (_0=="errPtfIncompatibility"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1364:6-34
    return numpy.int32(1181)
   if (_0=="errPtfUndefinedItem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1365:6-32
    return numpy.int32(1182)
   if (_0=="errPtfInconsistency"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1366:6-32
    return numpy.int32(1183)
   if (_0=="errPtfFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1367:6-25
    return numpy.int32(1184)
   if (_0=="errArgumentLenneq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1368:6-30
    return numpy.int32(1197)
   if (_0=="errArgumentType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1369:6-28
    return numpy.int32(1198)
   if (_0=="errNumArguments"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1370:6-28
    return numpy.int32(1199)
   if (_0=="errInArgument"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1371:6-26
    return numpy.int32(1200)
   if (_0=="errArgumentDimension"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1372:6-33
    return numpy.int32(1201)
   if (_0=="errShapeIsTooLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1373:6-31
    return numpy.int32(1202)
   if (_0=="errIndexIsTooSmall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1374:6-31
    return numpy.int32(1203)
   if (_0=="errIndexIsTooLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1375:6-31
    return numpy.int32(1204)
   if (_0=="errIndexIsNotUnique"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1376:6-32
    return numpy.int32(1205)
   if (_0=="errParamName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1377:6-25
    return numpy.int32(1206)
   if (_0=="errParamNameDou"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1378:6-28
    return numpy.int32(1207)
   if (_0=="errParamNameInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1379:6-28
    return numpy.int32(1208)
   if (_0=="errParamNameStr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1380:6-28
    return numpy.int32(1209)
   if (_0=="errParamIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1381:6-26
    return numpy.int32(1210)
   if (_0=="errParamIsTooLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1382:6-31
    return numpy.int32(1215)
   if (_0=="errParamIsTooSmall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1383:6-31
    return numpy.int32(1216)
   if (_0=="errParamValueStr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1384:6-29
    return numpy.int32(1217)
   if (_0=="errParamType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1385:6-25
    return numpy.int32(1218)
   if (_0=="errInfDouIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1386:6-27
    return numpy.int32(1219)
   if (_0=="errInfIntIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1387:6-27
    return numpy.int32(1220)
   if (_0=="errIndexArrIsTooSmall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1388:6-34
    return numpy.int32(1221)
   if (_0=="errIndexArrIsTooLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1389:6-34
    return numpy.int32(1222)
   if (_0=="errInfLintIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1390:6-28
    return numpy.int32(1225)
   if (_0=="errArgIsTooSmall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1391:6-29
    return numpy.int32(1226)
   if (_0=="errArgIsTooLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1392:6-29
    return numpy.int32(1227)
   if (_0=="errInvalidWhichsol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1393:6-31
    return numpy.int32(1228)
   if (_0=="errInfDouName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1394:6-26
    return numpy.int32(1230)
   if (_0=="errInfIntName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1395:6-26
    return numpy.int32(1231)
   if (_0=="errInfType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1396:6-23
    return numpy.int32(1232)
   if (_0=="errInfLintName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1397:6-27
    return numpy.int32(1234)
   if (_0=="errIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1398:6-21
    return numpy.int32(1235)
   if (_0=="errWhichsol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1399:6-24
    return numpy.int32(1236)
   if (_0=="errSolitem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1400:6-23
    return numpy.int32(1237)
   if (_0=="errWhichitemNotAllowed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1401:6-35
    return numpy.int32(1238)
   if (_0=="errMaxnumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1402:6-25
    return numpy.int32(1240)
   if (_0=="errMaxnumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1403:6-25
    return numpy.int32(1241)
   if (_0=="errMaxnumbarvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1404:6-28
    return numpy.int32(1242)
   if (_0=="errMaxnumqnz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1405:6-25
    return numpy.int32(1243)
   if (_0=="errTooSmallMaxNumNz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1406:6-32
    return numpy.int32(1245)
   if (_0=="errInvalidIdx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1407:6-26
    return numpy.int32(1246)
   if (_0=="errInvalidMaxNum"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1408:6-29
    return numpy.int32(1247)
   if (_0=="errUnallowedWhichsol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1409:6-33
    return numpy.int32(1248)
   if (_0=="errNumconlim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1410:6-25
    return numpy.int32(1250)
   if (_0=="errNumvarlim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1411:6-25
    return numpy.int32(1251)
   if (_0=="errTooSmallMaxnumanz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1412:6-33
    return numpy.int32(1252)
   if (_0=="errInvAptre"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1413:6-24
    return numpy.int32(1253)
   if (_0=="errMulAElement"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1414:6-27
    return numpy.int32(1254)
   if (_0=="errInvBk"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1415:6-21
    return numpy.int32(1255)
   if (_0=="errInvBkc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1416:6-22
    return numpy.int32(1256)
   if (_0=="errInvBkx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1417:6-22
    return numpy.int32(1257)
   if (_0=="errInvVarType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1418:6-26
    return numpy.int32(1258)
   if (_0=="errSolverProbtype"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1419:6-30
    return numpy.int32(1259)
   if (_0=="errObjectiveRange"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1420:6-30
    return numpy.int32(1260)
   if (_0=="errBasis"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1421:6-21
    return numpy.int32(1266)
   if (_0=="errInvSkc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1422:6-22
    return numpy.int32(1267)
   if (_0=="errInvSkx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1423:6-22
    return numpy.int32(1268)
   if (_0=="errInvSkn"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1424:6-22
    return numpy.int32(1274)
   if (_0=="errInvSkStr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1425:6-24
    return numpy.int32(1269)
   if (_0=="errInvSk"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1426:6-21
    return numpy.int32(1270)
   if (_0=="errInvConeTypeStr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1427:6-30
    return numpy.int32(1271)
   if (_0=="errInvConeType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1428:6-27
    return numpy.int32(1272)
   if (_0=="errInvalidSurplus"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1429:6-30
    return numpy.int32(1275)
   if (_0=="errInvNameItem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1430:6-27
    return numpy.int32(1280)
   if (_0=="errProItem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1431:6-23
    return numpy.int32(1281)
   if (_0=="errInvalidFormatType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1432:6-33
    return numpy.int32(1283)
   if (_0=="errFirsti"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1433:6-22
    return numpy.int32(1285)
   if (_0=="errLasti"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1434:6-21
    return numpy.int32(1286)
   if (_0=="errFirstj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1435:6-22
    return numpy.int32(1287)
   if (_0=="errLastj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1436:6-21
    return numpy.int32(1288)
   if (_0=="errMaxLenIsTooSmall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1437:6-32
    return numpy.int32(1289)
   if (_0=="errNonlinearEquality"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1438:6-33
    return numpy.int32(1290)
   if (_0=="errNonconvex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1439:6-25
    return numpy.int32(1291)
   if (_0=="errNonlinearRanged"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1440:6-31
    return numpy.int32(1292)
   if (_0=="errConQNotPsd"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1441:6-26
    return numpy.int32(1293)
   if (_0=="errConQNotNsd"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1442:6-26
    return numpy.int32(1294)
   if (_0=="errObjQNotPsd"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1443:6-26
    return numpy.int32(1295)
   if (_0=="errObjQNotNsd"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1444:6-26
    return numpy.int32(1296)
   if (_0=="errArgumentPermArray"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1445:6-33
    return numpy.int32(1299)
   if (_0=="errConeIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1446:6-25
    return numpy.int32(1300)
   if (_0=="errConeSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1447:6-24
    return numpy.int32(1301)
   if (_0=="errConeOverlap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1448:6-27
    return numpy.int32(1302)
   if (_0=="errConeRepVar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1449:6-26
    return numpy.int32(1303)
   if (_0=="errMaxnumcone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1450:6-26
    return numpy.int32(1304)
   if (_0=="errConeType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1451:6-24
    return numpy.int32(1305)
   if (_0=="errConeTypeStr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1452:6-27
    return numpy.int32(1306)
   if (_0=="errConeOverlapAppend"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1453:6-33
    return numpy.int32(1307)
   if (_0=="errRemoveConeVariable"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1454:6-34
    return numpy.int32(1310)
   if (_0=="errAppendingTooBigCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1455:6-35
    return numpy.int32(1311)
   if (_0=="errConeParameter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1456:6-29
    return numpy.int32(1320)
   if (_0=="errSolFileInvalidNumber"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1457:6-36
    return numpy.int32(1350)
   if (_0=="errHugeC"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1458:6-21
    return numpy.int32(1375)
   if (_0=="errHugeAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1459:6-23
    return numpy.int32(1380)
   if (_0=="errDuplicateAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1460:6-28
    return numpy.int32(1385)
   if (_0=="errLowerBoundIsANan"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1461:6-32
    return numpy.int32(1390)
   if (_0=="errUpperBoundIsANan"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1462:6-32
    return numpy.int32(1391)
   if (_0=="errInfiniteBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1463:6-29
    return numpy.int32(1400)
   if (_0=="errInvQobjSubi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1464:6-27
    return numpy.int32(1401)
   if (_0=="errInvQobjSubj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1465:6-27
    return numpy.int32(1402)
   if (_0=="errInvQobjVal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1466:6-26
    return numpy.int32(1403)
   if (_0=="errInvQconSubk"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1467:6-27
    return numpy.int32(1404)
   if (_0=="errInvQconSubi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1468:6-27
    return numpy.int32(1405)
   if (_0=="errInvQconSubj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1469:6-27
    return numpy.int32(1406)
   if (_0=="errInvQconVal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1470:6-26
    return numpy.int32(1407)
   if (_0=="errQconSubiTooSmall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1471:6-32
    return numpy.int32(1408)
   if (_0=="errQconSubiTooLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1472:6-32
    return numpy.int32(1409)
   if (_0=="errQobjUpperTriangle"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1473:6-33
    return numpy.int32(1415)
   if (_0=="errQconUpperTriangle"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1474:6-33
    return numpy.int32(1417)
   if (_0=="errFixedBoundValues"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1475:6-32
    return numpy.int32(1420)
   if (_0=="errTooSmallATruncationValue"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1476:6-40
    return numpy.int32(1421)
   if (_0=="errInvalidObjectiveSense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1477:6-37
    return numpy.int32(1445)
   if (_0=="errUndefinedObjectiveSense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1478:6-39
    return numpy.int32(1446)
   if (_0=="errYIsUndefined"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1479:6-28
    return numpy.int32(1449)
   if (_0=="errNanInDoubleData"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1480:6-31
    return numpy.int32(1450)
   if (_0=="errInfInDoubleData"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1481:6-31
    return numpy.int32(1451)
   if (_0=="errNanInBlc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1482:6-24
    return numpy.int32(1461)
   if (_0=="errNanInBuc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1483:6-24
    return numpy.int32(1462)
   if (_0=="errInvalidCfix"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1484:6-27
    return numpy.int32(1469)
   if (_0=="errNanInC"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1485:6-22
    return numpy.int32(1470)
   if (_0=="errNanInBlx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1486:6-24
    return numpy.int32(1471)
   if (_0=="errNanInBux"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1487:6-24
    return numpy.int32(1472)
   if (_0=="errInvalidAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1488:6-26
    return numpy.int32(1473)
   if (_0=="errInvalidCj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1489:6-25
    return numpy.int32(1474)
   if (_0=="errSymMatInvalid"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1490:6-29
    return numpy.int32(1480)
   if (_0=="errSymMatHuge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1491:6-26
    return numpy.int32(1482)
   if (_0=="errInvProblem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1492:6-26
    return numpy.int32(1500)
   if (_0=="errMixedConicAndNl"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1493:6-31
    return numpy.int32(1501)
   if (_0=="errGlobalInvConicProblem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1494:6-37
    return numpy.int32(1503)
   if (_0=="errInvOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1495:6-28
    return numpy.int32(1550)
   if (_0=="errMioNoOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1496:6-30
    return numpy.int32(1551)
   if (_0=="errNoOptimizerVarType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1497:6-34
    return numpy.int32(1552)
   if (_0=="errFinalSolution"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1498:6-29
    return numpy.int32(1560)
   if (_0=="errFirst"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1499:6-21
    return numpy.int32(1570)
   if (_0=="errLast"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1500:6-20
    return numpy.int32(1571)
   if (_0=="errSliceSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1501:6-25
    return numpy.int32(1572)
   if (_0=="errNegativeSurplus"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1502:6-31
    return numpy.int32(1573)
   if (_0=="errNegativeAppend"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1503:6-30
    return numpy.int32(1578)
   if (_0=="errPostsolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1504:6-25
    return numpy.int32(1580)
   if (_0=="errOverflow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1505:6-24
    return numpy.int32(1590)
   if (_0=="errNoBasisSol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1506:6-26
    return numpy.int32(1600)
   if (_0=="errBasisFactor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1507:6-27
    return numpy.int32(1610)
   if (_0=="errBasisSingular"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1508:6-29
    return numpy.int32(1615)
   if (_0=="errFactor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1509:6-22
    return numpy.int32(1650)
   if (_0=="errFeasrepairCannotRelax"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1510:6-37
    return numpy.int32(1700)
   if (_0=="errFeasrepairSolvingRelaxed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1511:6-40
    return numpy.int32(1701)
   if (_0=="errFeasrepairInconsistentBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1512:6-43
    return numpy.int32(1702)
   if (_0=="errRepairInvalidProblem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1513:6-36
    return numpy.int32(1710)
   if (_0=="errRepairOptimizationFailed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1514:6-40
    return numpy.int32(1711)
   if (_0=="errNameMaxLen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1515:6-26
    return numpy.int32(1750)
   if (_0=="errNameIsNull"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1516:6-26
    return numpy.int32(1760)
   if (_0=="errInvalidCompression"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1517:6-34
    return numpy.int32(1800)
   if (_0=="errInvalidIomode"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1518:6-29
    return numpy.int32(1801)
   if (_0=="errNoPrimalInfeasCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1519:6-33
    return numpy.int32(2000)
   if (_0=="errNoDualInfeasCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1520:6-31
    return numpy.int32(2001)
   if (_0=="errNoSolutionInCallback"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1521:6-36
    return numpy.int32(2500)
   if (_0=="errInvMarki"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1522:6-24
    return numpy.int32(2501)
   if (_0=="errInvMarkj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1523:6-24
    return numpy.int32(2502)
   if (_0=="errInvNumi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1524:6-23
    return numpy.int32(2503)
   if (_0=="errInvNumj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1525:6-23
    return numpy.int32(2504)
   if (_0=="errTaskIncompatible"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1526:6-32
    return numpy.int32(2560)
   if (_0=="errTaskInvalid"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1527:6-27
    return numpy.int32(2561)
   if (_0=="errTaskWrite"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1528:6-25
    return numpy.int32(2562)
   if (_0=="errLuMaxNumTries"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1529:6-29
    return numpy.int32(2800)
   if (_0=="errInvalidUtf8"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1530:6-27
    return numpy.int32(2900)
   if (_0=="errInvalidWchar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1531:6-28
    return numpy.int32(2901)
   if (_0=="errNoDualForItgSol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1532:6-31
    return numpy.int32(2950)
   if (_0=="errNoSnxForBasSol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1533:6-30
    return numpy.int32(2953)
   if (_0=="errInternal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1534:6-24
    return numpy.int32(3000)
   if (_0=="errApiArrayTooSmall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1535:6-32
    return numpy.int32(3001)
   if (_0=="errApiCbConnect"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1536:6-28
    return numpy.int32(3002)
   if (_0=="errApiFatalError"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1537:6-29
    return numpy.int32(3005)
   if (_0=="errApiInternal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1538:6-27
    return numpy.int32(3999)
   if (_0=="errSenFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1539:6-25
    return numpy.int32(3050)
   if (_0=="errSenUndefName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1540:6-28
    return numpy.int32(3051)
   if (_0=="errSenIndexRange"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1541:6-29
    return numpy.int32(3052)
   if (_0=="errSenBoundInvalidUp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1542:6-33
    return numpy.int32(3053)
   if (_0=="errSenBoundInvalidLo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1543:6-33
    return numpy.int32(3054)
   if (_0=="errSenIndexInvalid"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1544:6-31
    return numpy.int32(3055)
   if (_0=="errSenInvalidRegexp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1545:6-32
    return numpy.int32(3056)
   if (_0=="errSenSolutionStatus"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1546:6-33
    return numpy.int32(3057)
   if (_0=="errSenNumerical"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1547:6-28
    return numpy.int32(3058)
   if (_0=="errSenUnhandledProblemType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1548:6-39
    return numpy.int32(3080)
   if (_0=="errUnbStepSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1549:6-27
    return numpy.int32(3100)
   if (_0=="errIdenticalTasks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1550:6-30
    return numpy.int32(3101)
   if (_0=="errAdInvalidCodelist"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1551:6-33
    return numpy.int32(3102)
   if (_0=="errInternalTestFailed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1552:6-34
    return numpy.int32(3500)
   if (_0=="errXmlInvalidProblemType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1553:6-37
    return numpy.int32(3600)
   if (_0=="errInvalidAmplStub"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1554:6-31
    return numpy.int32(3700)
   if (_0=="errInt64ToInt32Cast"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1555:6-32
    return numpy.int32(3800)
   if (_0=="errSizeLicenseNumcores"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1556:6-35
    return numpy.int32(3900)
   if (_0=="errInfeasUndefined"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1557:6-31
    return numpy.int32(3910)
   if (_0=="errNoBarxForSolution"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1558:6-33
    return numpy.int32(3915)
   if (_0=="errNoBarsForSolution"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1559:6-33
    return numpy.int32(3916)
   if (_0=="errBarVarDim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1560:6-25
    return numpy.int32(3920)
   if (_0=="errSymMatInvalidRowIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1561:6-37
    return numpy.int32(3940)
   if (_0=="errSymMatInvalidColIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1562:6-37
    return numpy.int32(3941)
   if (_0=="errSymMatNotLowerTringular"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1563:6-39
    return numpy.int32(3942)
   if (_0=="errSymMatInvalidValue"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1564:6-34
    return numpy.int32(3943)
   if (_0=="errSymMatDuplicate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1565:6-31
    return numpy.int32(3944)
   if (_0=="errInvalidSymMatDim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1566:6-32
    return numpy.int32(3950)
   if (_0=="errInvalidFileFormatForSymMat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1567:6-42
    return numpy.int32(4000)
   if (_0=="errInvalidFileFormatForCfix"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1568:6-40
    return numpy.int32(4001)
   if (_0=="errInvalidFileFormatForRangedConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1569:6-53
    return numpy.int32(4002)
   if (_0=="errInvalidFileFormatForFreeConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1570:6-51
    return numpy.int32(4003)
   if (_0=="errInvalidFileFormatForCones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1571:6-41
    return numpy.int32(4005)
   if (_0=="errInvalidFileFormatForQuadraticTerms"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1572:6-50
    return numpy.int32(4006)
   if (_0=="errInvalidFileFormatForNonlinear"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1573:6-45
    return numpy.int32(4010)
   if (_0=="errInvalidFileFormatForDisjunctiveConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1574:6-58
    return numpy.int32(4011)
   if (_0=="errInvalidFileFormatForAffineConicConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1575:6-58
    return numpy.int32(4012)
   if (_0=="errDuplicateConstraintNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1576:6-40
    return numpy.int32(4500)
   if (_0=="errDuplicateVariableNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1577:6-38
    return numpy.int32(4501)
   if (_0=="errDuplicateBarvariableNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1578:6-41
    return numpy.int32(4502)
   if (_0=="errDuplicateConeNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1579:6-34
    return numpy.int32(4503)
   if (_0=="errDuplicateDomainNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1580:6-36
    return numpy.int32(4504)
   if (_0=="errDuplicateDjcNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1581:6-33
    return numpy.int32(4505)
   if (_0=="errNonUniqueArray"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1582:6-30
    return numpy.int32(5000)
   if (_0=="errArgumentIsTooSmall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1583:6-34
    return numpy.int32(5004)
   if (_0=="errArgumentIsTooLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1584:6-34
    return numpy.int32(5005)
   if (_0=="errMioInternal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1585:6-27
    return numpy.int32(5010)
   if (_0=="errInvalidProblemType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1586:6-34
    return numpy.int32(6000)
   if (_0=="errUnhandledSolutionStatus"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1587:6-39
    return numpy.int32(6010)
   if (_0=="errUpperTriangle"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1588:6-29
    return numpy.int32(6020)
   if (_0=="errLauSingularMatrix"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1589:6-33
    return numpy.int32(7000)
   if (_0=="errLauNotPositiveDefinite"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1590:6-38
    return numpy.int32(7001)
   if (_0=="errLauInvalidLowerTriangularMatrix"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1591:6-47
    return numpy.int32(7002)
   if (_0=="errLauUnknown"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1592:6-26
    return numpy.int32(7005)
   if (_0=="errLauArgM"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1593:6-23
    return numpy.int32(7010)
   if (_0=="errLauArgN"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1594:6-23
    return numpy.int32(7011)
   if (_0=="errLauArgK"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1595:6-23
    return numpy.int32(7012)
   if (_0=="errLauArgTransa"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1596:6-28
    return numpy.int32(7015)
   if (_0=="errLauArgTransb"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1597:6-28
    return numpy.int32(7016)
   if (_0=="errLauArgUplo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1598:6-26
    return numpy.int32(7017)
   if (_0=="errLauArgTrans"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1599:6-27
    return numpy.int32(7018)
   if (_0=="errLauInvalidSparseSymmetricMatrix"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1600:6-47
    return numpy.int32(7019)
   if (_0=="errCbfParse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1601:6-24
    return numpy.int32(7100)
   if (_0=="errCbfObjSense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1602:6-27
    return numpy.int32(7101)
   if (_0=="errCbfNoVariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1603:6-30
    return numpy.int32(7102)
   if (_0=="errCbfTooManyConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1604:6-37
    return numpy.int32(7103)
   if (_0=="errCbfTooManyVariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1605:6-35
    return numpy.int32(7104)
   if (_0=="errCbfNoVersionSpecified"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1606:6-37
    return numpy.int32(7105)
   if (_0=="errCbfSyntax"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1607:6-25
    return numpy.int32(7106)
   if (_0=="errCbfDuplicateObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1608:6-31
    return numpy.int32(7107)
   if (_0=="errCbfDuplicateCon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1609:6-31
    return numpy.int32(7108)
   if (_0=="errCbfDuplicateVar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1610:6-31
    return numpy.int32(7110)
   if (_0=="errCbfDuplicateInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1611:6-31
    return numpy.int32(7111)
   if (_0=="errCbfInvalidVarType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1612:6-33
    return numpy.int32(7112)
   if (_0=="errCbfInvalidConType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1613:6-33
    return numpy.int32(7113)
   if (_0=="errCbfInvalidDomainDimension"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1614:6-41
    return numpy.int32(7114)
   if (_0=="errCbfDuplicateObjacoord"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1615:6-37
    return numpy.int32(7115)
   if (_0=="errCbfDuplicateBcoord"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1616:6-34
    return numpy.int32(7116)
   if (_0=="errCbfDuplicateAcoord"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1617:6-34
    return numpy.int32(7117)
   if (_0=="errCbfTooFewVariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1618:6-34
    return numpy.int32(7118)
   if (_0=="errCbfTooFewConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1619:6-36
    return numpy.int32(7119)
   if (_0=="errCbfTooFewInts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1620:6-29
    return numpy.int32(7120)
   if (_0=="errCbfTooManyInts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1621:6-30
    return numpy.int32(7121)
   if (_0=="errCbfInvalidIntIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1622:6-34
    return numpy.int32(7122)
   if (_0=="errCbfUnsupported"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1623:6-30
    return numpy.int32(7123)
   if (_0=="errCbfDuplicatePsdvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1624:6-34
    return numpy.int32(7124)
   if (_0=="errCbfInvalidPsdvarDimension"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1625:6-41
    return numpy.int32(7125)
   if (_0=="errCbfTooFewPsdvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1626:6-31
    return numpy.int32(7126)
   if (_0=="errCbfInvalidExpDimension"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1627:6-38
    return numpy.int32(7127)
   if (_0=="errCbfDuplicatePowCones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1628:6-36
    return numpy.int32(7130)
   if (_0=="errCbfDuplicatePowStarCones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1629:6-40
    return numpy.int32(7131)
   if (_0=="errCbfInvalidPower"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1630:6-31
    return numpy.int32(7132)
   if (_0=="errCbfPowerConeIsTooLong"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1631:6-37
    return numpy.int32(7133)
   if (_0=="errCbfInvalidPowerConeIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1632:6-40
    return numpy.int32(7134)
   if (_0=="errCbfInvalidPowerStarConeIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1633:6-44
    return numpy.int32(7135)
   if (_0=="errCbfUnhandledPowerConeType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1634:6-41
    return numpy.int32(7136)
   if (_0=="errCbfUnhandledPowerStarConeType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1635:6-45
    return numpy.int32(7137)
   if (_0=="errCbfPowerConeMismatch"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1636:6-36
    return numpy.int32(7138)
   if (_0=="errCbfPowerStarConeMismatch"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1637:6-40
    return numpy.int32(7139)
   if (_0=="errCbfInvalidNumberOfCones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1638:6-39
    return numpy.int32(7140)
   if (_0=="errCbfInvalidDimensionOfCones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1639:6-42
    return numpy.int32(7141)
   if (_0=="errCbfInvalidNumPsdcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1640:6-35
    return numpy.int32(7200)
   if (_0=="errCbfDuplicatePsdcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1641:6-34
    return numpy.int32(7201)
   if (_0=="errCbfInvalidDimensionOfPsdcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1642:6-43
    return numpy.int32(7202)
   if (_0=="errCbfInvalidPsdconIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1643:6-37
    return numpy.int32(7203)
   if (_0=="errCbfInvalidPsdconVariableIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1644:6-45
    return numpy.int32(7204)
   if (_0=="errCbfInvalidPsdconBlockIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1645:6-42
    return numpy.int32(7205)
   if (_0=="errCbfUnsupportedChange"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1646:6-36
    return numpy.int32(7210)
   if (_0=="errMioInvalidRootOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1647:6-39
    return numpy.int32(7700)
   if (_0=="errMioInvalidNodeOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1648:6-39
    return numpy.int32(7701)
   if (_0=="errMpsWriteCplexInvalidConeType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1649:6-44
    return numpy.int32(7750)
   if (_0=="errToconicConstrQNotPsd"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1650:6-36
    return numpy.int32(7800)
   if (_0=="errToconicConstraintFx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1651:6-35
    return numpy.int32(7801)
   if (_0=="errToconicConstraintRa"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1652:6-35
    return numpy.int32(7802)
   if (_0=="errToconicConstrNotConic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1653:6-37
    return numpy.int32(7803)
   if (_0=="errToconicObjectiveNotPsd"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1654:6-38
    return numpy.int32(7804)
   if (_0=="errServerConnect"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1655:6-29
    return numpy.int32(8000)
   if (_0=="errServerProtocol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1656:6-30
    return numpy.int32(8001)
   if (_0=="errServerStatus"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1657:6-28
    return numpy.int32(8002)
   if (_0=="errServerToken"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1658:6-27
    return numpy.int32(8003)
   if (_0=="errServerAddress"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1659:6-29
    return numpy.int32(8004)
   if (_0=="errServerCertificate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1660:6-33
    return numpy.int32(8005)
   if (_0=="errServerTlsClient"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1661:6-31
    return numpy.int32(8006)
   if (_0=="errServerAccessToken"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1662:6-33
    return numpy.int32(8007)
   if (_0=="errServerProblemSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1663:6-33
    return numpy.int32(8008)
   if (_0=="errDuplicateFij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1664:6-28
    return numpy.int32(20100)
   if (_0=="errInvalidFij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1665:6-26
    return numpy.int32(20101)
   if (_0=="errHugeFij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1666:6-23
    return numpy.int32(20102)
   if (_0=="errInvalidG"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1667:6-24
    return numpy.int32(20103)
   if (_0=="errInvalidB"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1668:6-24
    return numpy.int32(20150)
   if (_0=="errDomainInvalidIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1669:6-34
    return numpy.int32(20400)
   if (_0=="errDomainDimension"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1670:6-31
    return numpy.int32(20401)
   if (_0=="errDomainDimensionPsd"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1671:6-34
    return numpy.int32(20402)
   if (_0=="errNotPowerDomain"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1672:6-30
    return numpy.int32(20403)
   if (_0=="errDomainPowerInvalidAlpha"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1673:6-39
    return numpy.int32(20404)
   if (_0=="errDomainPowerNegativeAlpha"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1674:6-40
    return numpy.int32(20405)
   if (_0=="errDomainPowerNleft"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1675:6-32
    return numpy.int32(20406)
   if (_0=="errAfeInvalidIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1676:6-31
    return numpy.int32(20500)
   if (_0=="errAccInvalidIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1677:6-31
    return numpy.int32(20600)
   if (_0=="errAccInvalidEntryIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1678:6-36
    return numpy.int32(20601)
   if (_0=="errAccAfeDomainMismatch"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1679:6-36
    return numpy.int32(20602)
   if (_0=="errDjcInvalidIndex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1680:6-31
    return numpy.int32(20700)
   if (_0=="errDjcUnsupportedDomainType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1681:6-40
    return numpy.int32(20701)
   if (_0=="errDjcAfeDomainMismatch"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1682:6-36
    return numpy.int32(20702)
   if (_0=="errDjcInvalidTermSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1683:6-34
    return numpy.int32(20703)
   if (_0=="errDjcDomainTermsizeMismatch"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1684:6-41
    return numpy.int32(20704)
   if (_0=="errDjcTotalNumTermsMismatch"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1685:6-40
    return numpy.int32(20705)
   if (_0=="errUndefSolution"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1686:6-29
    return numpy.int32(22000)
   if (_0=="errNoDoty"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1687:6-22
    return numpy.int32(22010)
   if (_0=="trmMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1688:6-29
    return numpy.int32(100000)
   if (_0=="trmMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1689:6-23
    return numpy.int32(100001)
   if (_0=="trmObjectiveRange"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1690:6-30
    return numpy.int32(100002)
   if (_0=="trmMioNumRelaxs"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1691:6-28
    return numpy.int32(100008)
   if (_0=="trmMioNumBranches"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1692:6-30
    return numpy.int32(100009)
   if (_0=="trmNumMaxNumIntSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1693:6-37
    return numpy.int32(100015)
   if (_0=="trmStall"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1694:6-21
    return numpy.int32(100006)
   if (_0=="trmUserCallback"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1695:6-28
    return numpy.int32(100007)
   if (_0=="trmMaxNumSetbacks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1696:6-30
    return numpy.int32(100020)
   if (_0=="trmNumericalProblem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1697:6-32
    return numpy.int32(100025)
   if (_0=="trmLostRace"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1698:6-24
    return numpy.int32(100027)
   if (_0=="trmInternal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1699:6-24
    return numpy.int32(100030)
   if (_0=="trmInternalStop"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1700:6-28
    return numpy.int32(100031)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1xmlwriteroutputtype_1value_S(_0)
  @staticmethod
  def __string_1to_1xmlwriteroutputtype_1value_S(_0):
   if (_0=="row"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1163:6-16
    return numpy.int32(0)
   if (_0=="col"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1164:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1prosta_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1prosta_1value_S(_0)
  @staticmethod
  def __string_1to_1prosta_1value_S(_0):
   if (_0=="unknown"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1150:6-20
    return numpy.int32(0)
   if (_0=="primAndDualFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1151:6-28
    return numpy.int32(1)
   if (_0=="primFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1152:6-21
    return numpy.int32(2)
   if (_0=="dualFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1153:6-21
    return numpy.int32(3)
   if (_0=="primInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1154:6-23
    return numpy.int32(4)
   if (_0=="dualInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1155:6-23
    return numpy.int32(5)
   if (_0=="primAndDualInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1156:6-30
    return numpy.int32(6)
   if (_0=="illPosed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1157:6-21
    return numpy.int32(7)
   if (_0=="primInfeasOrUnbounded"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1158:6-34
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemtype_1value_S(_0)
  @staticmethod
  def __string_1to_1problemtype_1value_S(_0):
   if (_0=="lo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1141:6-15
    return numpy.int32(0)
   if (_0=="qo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1142:6-15
    return numpy.int32(1)
   if (_0=="qcqo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1143:6-17
    return numpy.int32(2)
   if (_0=="conic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1144:6-18
    return numpy.int32(3)
   if (_0=="mixed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1145:6-18
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1problemitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1problemitem_1value_S(_0)
  @staticmethod
  def __string_1to_1problemitem_1value_S(_0):
   if (_0=="var"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1134:6-16
    return numpy.int32(0)
   if (_0=="con"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1135:6-16
    return numpy.int32(1)
   if (_0=="cone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1136:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1parametertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1parametertype_1value_S(_0)
  @staticmethod
  def __string_1to_1parametertype_1value_S(_0):
   if (_0=="invalidType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1126:6-24
    return numpy.int32(0)
   if (_0=="douType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1127:6-20
    return numpy.int32(1)
   if (_0=="intType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1128:6-20
    return numpy.int32(2)
   if (_0=="strType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1129:6-20
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1presolvemode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1presolvemode_1value_S(_0)
  @staticmethod
  def __string_1to_1presolvemode_1value_S(_0):
   if (_0=="off"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1119:6-16
    return numpy.int32(0)
   if (_0=="on"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1120:6-15
    return numpy.int32(1)
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1121:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1orderingtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1orderingtype_1value_S(_0)
  @staticmethod
  def __string_1to_1orderingtype_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1109:6-17
    return numpy.int32(0)
   if (_0=="appminloc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1110:6-22
    return numpy.int32(1)
   if (_0=="experimental"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1111:6-25
    return numpy.int32(2)
   if (_0=="tryGraphpar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1112:6-24
    return numpy.int32(3)
   if (_0=="forceGraphpar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1113:6-26
    return numpy.int32(4)
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1114:6-17
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1optimizertype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1optimizertype_1value_S(_0)
  @staticmethod
  def __string_1to_1optimizertype_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1098:6-17
    return numpy.int32(2)
   if (_0=="intpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1099:6-19
    return numpy.int32(4)
   if (_0=="conic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1100:6-18
    return numpy.int32(0)
   if (_0=="primalSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1101:6-26
    return numpy.int32(6)
   if (_0=="dualSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1102:6-24
    return numpy.int32(1)
   if (_0=="freeSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1103:6-24
    return numpy.int32(3)
   if (_0=="mixedInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1104:6-21
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1onoffkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1onoffkey_1value_S(_0)
  @staticmethod
  def __string_1to_1onoffkey_1value_S(_0):
   if (_0=="on"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1092:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1093:6-16
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1objsense_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1objsense_1value_S(_0)
  @staticmethod
  def __string_1to_1objsense_1value_S(_0):
   if (_0=="minimize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1086:6-21
    return numpy.int32(0)
   if (_0=="maximize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1087:6-21
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mpsformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mpsformat_1value_S(_0)
  @staticmethod
  def __string_1to_1mpsformat_1value_S(_0):
   if (_0=="strict"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1078:6-19
    return numpy.int32(0)
   if (_0=="relaxed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1079:6-20
    return numpy.int32(1)
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1080:6-17
    return numpy.int32(2)
   if (_0=="cplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1081:6-18
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mionodeseltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mionodeseltype_1value_S(_0)
  @staticmethod
  def __string_1to_1mionodeseltype_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1070:6-17
    return numpy.int32(0)
   if (_0=="first"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1071:6-18
    return numpy.int32(1)
   if (_0=="best"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1072:6-17
    return numpy.int32(2)
   if (_0=="pseudo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1073:6-19
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miomode_1value_S(_0)
  @staticmethod
  def __string_1to_1miomode_1value_S(_0):
   if (_0=="ignored"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1064:6-20
    return numpy.int32(0)
   if (_0=="satisfied"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1065:6-22
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miocontsoltype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miocontsoltype_1value_S(_0)
  @staticmethod
  def __string_1to_1miocontsoltype_1value_S(_0):
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1056:6-17
    return numpy.int32(0)
   if (_0=="root"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1057:6-17
    return numpy.int32(1)
   if (_0=="itg"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1058:6-16
    return numpy.int32(2)
   if (_0=="itgRel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1059:6-19
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miodatapermmethod_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miodatapermmethod_1value_S(_0)
  @staticmethod
  def __string_1to_1miodatapermmethod_1value_S(_0):
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1049:6-17
    return numpy.int32(0)
   if (_0=="cyclicShift"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1050:6-24
    return numpy.int32(1)
   if (_0=="random"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1051:6-19
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1miqcqoreformmethod_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1miqcqoreformmethod_1value_S(_0)
  @staticmethod
  def __string_1to_1miqcqoreformmethod_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1039:6-17
    return numpy.int32(0)
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1040:6-17
    return numpy.int32(1)
   if (_0=="linearization"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1041:6-26
    return numpy.int32(2)
   if (_0=="eigenValMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1042:6-27
    return numpy.int32(3)
   if (_0=="diagSdp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1043:6-20
    return numpy.int32(4)
   if (_0=="relaxSdp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1044:6-21
    return numpy.int32(5)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1branchdir_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1branchdir_1value_S(_0)
  @staticmethod
  def __string_1to_1branchdir_1value_S(_0):
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1027:6-17
    return numpy.int32(0)
   if (_0=="up"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1028:6-15
    return numpy.int32(1)
   if (_0=="down"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1029:6-17
    return numpy.int32(2)
   if (_0=="near"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1030:6-17
    return numpy.int32(3)
   if (_0=="far"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1031:6-16
    return numpy.int32(4)
   if (_0=="rootLp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1032:6-19
    return numpy.int32(5)
   if (_0=="guided"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1033:6-19
    return numpy.int32(6)
   if (_0=="pseudocost"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1034:6-23
    return numpy.int32(7)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iparam_1value_S(_0)
  @staticmethod
  def __string_1to_1iparam_1value_S(_0):
   if (_0=="autoUpdateSolInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:836:6-30
    return numpy.int32(3)
   if (_0=="removeUnusedSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:837:6-34
    return numpy.int32(127)
   if (_0=="intpntHotstart"): # bld/herlev/final/default/src/fusion/Parameters.mbi:838:6-27
    return numpy.int32(18)
   if (_0=="intpntPurify"): # bld/herlev/final/default/src/fusion/Parameters.mbi:839:6-25
    return numpy.int32(25)
   if (_0=="numThreads"): # bld/herlev/final/default/src/fusion/Parameters.mbi:840:6-23
    return numpy.int32(95)
   if (_0=="timingLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:841:6-24
    return numpy.int32(162)
   if (_0=="mtSpincount"): # bld/herlev/final/default/src/fusion/Parameters.mbi:842:6-24
    return numpy.int32(93)
   if (_0=="maxNumWarnings"): # bld/herlev/final/default/src/fusion/Parameters.mbi:843:6-27
    return numpy.int32(59)
   if (_0=="optimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:844:6-22
    return numpy.int32(105)
   if (_0=="biMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:845:6-28
    return numpy.int32(8)
   if (_0=="licenseTrhExpiryWrn"): # bld/herlev/final/default/src/fusion/Parameters.mbi:846:6-32
    return numpy.int32(33)
   if (_0=="logIncludeSummary"): # bld/herlev/final/default/src/fusion/Parameters.mbi:847:6-30
    return numpy.int32(44)
   if (_0=="logCutSecondOpt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:848:6-28
    return numpy.int32(40)
   if (_0=="logAnaPro"): # bld/herlev/final/default/src/fusion/Parameters.mbi:849:6-22
    return numpy.int32(36)
   if (_0=="logResponse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:850:6-24
    return numpy.int32(52)
   if (_0=="logLocalInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:851:6-25
    return numpy.int32(47)
   if (_0=="logBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:852:6-18
    return numpy.int32(37)
   if (_0=="logBiFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:853:6-22
    return numpy.int32(38)
   if (_0=="biCleanOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:854:6-29
    return numpy.int32(5)
   if (_0=="intpntMaxNumRefinementSteps"): # bld/herlev/final/default/src/fusion/Parameters.mbi:855:6-40
    return numpy.int32(21)
   if (_0=="intpntStartingPoint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:856:6-32
    return numpy.int32(29)
   if (_0=="intpntDiffStep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:857:6-27
    return numpy.int32(17)
   if (_0=="intpntScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:858:6-26
    return numpy.int32(27)
   if (_0=="intpntSolveForm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:859:6-28
    return numpy.int32(28)
   if (_0=="logIntpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:860:6-22
    return numpy.int32(46)
   if (_0=="intpntMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:861:6-32
    return numpy.int32(19)
   if (_0=="intpntOffColTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:862:6-28
    return numpy.int32(22)
   if (_0=="intpntOrderMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:863:6-30
    return numpy.int32(24)
   if (_0=="intpntOrderGpNumSeeds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:864:6-34
    return numpy.int32(23)
   if (_0=="intpntBasis"): # bld/herlev/final/default/src/fusion/Parameters.mbi:865:6-24
    return numpy.int32(16)
   if (_0=="biIgnoreMaxIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:866:6-28
    return numpy.int32(6)
   if (_0=="biIgnoreNumError"): # bld/herlev/final/default/src/fusion/Parameters.mbi:867:6-29
    return numpy.int32(7)
   if (_0=="intpntMaxNumCor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:868:6-28
    return numpy.int32(20)
   if (_0=="presolveUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:869:6-24
    return numpy.int32(116)
   if (_0=="presolveLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:870:6-26
    return numpy.int32(110)
   if (_0=="logPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:871:6-24
    return numpy.int32(51)
   if (_0=="presolveLindepUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:872:6-30
    return numpy.int32(113)
   if (_0=="presolveMaxNumPass"): # bld/herlev/final/default/src/fusion/Parameters.mbi:873:6-31
    return numpy.int32(114)
   if (_0=="presolveEliminatorMaxNumTries"): # bld/herlev/final/default/src/fusion/Parameters.mbi:874:6-42
    return numpy.int32(109)
   if (_0=="presolveEliminatorMaxFill"): # bld/herlev/final/default/src/fusion/Parameters.mbi:875:6-38
    return numpy.int32(108)
   if (_0=="presolveMaxNumReductions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:876:6-37
    return numpy.int32(115)
   if (_0=="simDetectPwl"): # bld/herlev/final/default/src/fusion/Parameters.mbi:877:6-25
    return numpy.int32(133)
   if (_0=="simStabilityPriority"): # bld/herlev/final/default/src/fusion/Parameters.mbi:878:6-33
    return numpy.int32(155)
   if (_0=="simPrimalCrash"): # bld/herlev/final/default/src/fusion/Parameters.mbi:879:6-27
    return numpy.int32(144)
   if (_0=="logSim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:880:6-19
    return numpy.int32(55)
   if (_0=="logSimMinor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:881:6-24
    return numpy.int32(57)
   if (_0=="logSimFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:882:6-23
    return numpy.int32(56)
   if (_0=="simPrimalRestrictSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:883:6-39
    return numpy.int32(146)
   if (_0=="simPrimalSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:884:6-31
    return numpy.int32(147)
   if (_0=="simDualRestrictSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:885:6-37
    return numpy.int32(136)
   if (_0=="simDualSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:886:6-29
    return numpy.int32(137)
   if (_0=="simMaxIterations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:887:6-29
    return numpy.int32(141)
   if (_0=="simHotstartLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:888:6-26
    return numpy.int32(140)
   if (_0=="simRefactorFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:889:6-28
    return numpy.int32(148)
   if (_0=="simSeed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:890:6-20
    return numpy.int32(153)
   if (_0=="mioMode"): # bld/herlev/final/default/src/fusion/Parameters.mbi:891:6-20
    return numpy.int32(78)
   if (_0=="logMio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:892:6-19
    return numpy.int32(48)
   if (_0=="logMioFreq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:893:6-23
    return numpy.int32(49)
   if (_0=="mioMaxNumRelaxs"): # bld/herlev/final/default/src/fusion/Parameters.mbi:894:6-28
    return numpy.int32(74)
   if (_0=="mioMaxNumBranches"): # bld/herlev/final/default/src/fusion/Parameters.mbi:895:6-30
    return numpy.int32(73)
   if (_0=="mioMaxNumRootCutRounds"): # bld/herlev/final/default/src/fusion/Parameters.mbi:896:6-35
    return numpy.int32(75)
   if (_0=="mioMaxNumSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:897:6-31
    return numpy.int32(76)
   if (_0=="mioNodeSelection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:898:6-29
    return numpy.int32(80)
   if (_0=="mioHeuristicLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:899:6-30
    return numpy.int32(72)
   if (_0=="mioProbingLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:900:6-28
    return numpy.int32(84)
   if (_0=="mioSymmetryLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:901:6-29
    return numpy.int32(91)
   if (_0=="mioPresolveAggregatorUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:902:6-37
    return numpy.int32(83)
   if (_0=="mioNumericalEmphasisLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:903:6-38
    return numpy.int32(81)
   if (_0=="mioMemoryEmphasisLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:904:6-35
    return numpy.int32(77)
   if (_0=="mioCutSelectionLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:905:6-33
    return numpy.int32(69)
   if (_0=="mioVbDetectionLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:906:6-32
    return numpy.int32(92)
   if (_0=="mioBranchDir"): # bld/herlev/final/default/src/fusion/Parameters.mbi:907:6-25
    return numpy.int32(60)
   if (_0=="mioRootOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:908:6-29
    return numpy.int32(88)
   if (_0=="mioNodeOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:909:6-29
    return numpy.int32(79)
   if (_0=="mioPerspectiveReformulate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:910:6-38
    return numpy.int32(82)
   if (_0=="mioPropagateObjectiveConstraint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:911:6-44
    return numpy.int32(85)
   if (_0=="mioSeed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:912:6-20
    return numpy.int32(90)
   if (_0=="mioConicOuterApproximation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:913:6-39
    return numpy.int32(61)
   if (_0=="mioQcqoReformulationMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:914:6-39
    return numpy.int32(86)
   if (_0=="mioDataPermutationMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:915:6-37
    return numpy.int32(70)
   if (_0=="readKeepFreeCon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:916:6-28
    return numpy.int32(122)
   if (_0=="readMpsFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:917:6-26
    return numpy.int32(123)
   if (_0=="writeMpsFormat"): # bld/herlev/final/default/src/fusion/Parameters.mbi:918:6-27
    return numpy.int32(178)
   if (_0=="readMpsWidth"): # bld/herlev/final/default/src/fusion/Parameters.mbi:919:6-25
    return numpy.int32(124)
   if (_0=="readDebug"): # bld/herlev/final/default/src/fusion/Parameters.mbi:920:6-22
    return numpy.int32(121)
   if (_0=="writeDataParam"): # bld/herlev/final/default/src/fusion/Parameters.mbi:921:6-27
    return numpy.int32(167)
   if (_0=="writeFreeCon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:922:6-25
    return numpy.int32(168)
   if (_0=="writeGenericNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:923:6-30
    return numpy.int32(169)
   if (_0=="writeGenericNamesIo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:924:6-32
    return numpy.int32(170)
   if (_0=="writeCompression"): # bld/herlev/final/default/src/fusion/Parameters.mbi:925:6-29
    return numpy.int32(166)
   if (_0=="writeMpsInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:926:6-24
    return numpy.int32(179)
   if (_0=="writeLpLineWidth"): # bld/herlev/final/default/src/fusion/Parameters.mbi:927:6-29
    return numpy.int32(177)
   if (_0=="writeLpFullObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:928:6-27
    return numpy.int32(176)
   if (_0=="writeJsonIndentation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:929:6-33
    return numpy.int32(175)
   if (_0=="writeSolIgnoreInvalidNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:930:6-39
    return numpy.int32(183)
   if (_0=="writeSolHead"): # bld/herlev/final/default/src/fusion/Parameters.mbi:931:6-25
    return numpy.int32(182)
   if (_0=="writeSolConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:932:6-32
    return numpy.int32(181)
   if (_0=="writeSolVariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:933:6-30
    return numpy.int32(184)
   if (_0=="writeSolBarvariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:934:6-33
    return numpy.int32(180)
   if (_0=="writeBasHead"): # bld/herlev/final/default/src/fusion/Parameters.mbi:935:6-25
    return numpy.int32(164)
   if (_0=="writeBasConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:936:6-32
    return numpy.int32(163)
   if (_0=="writeBasVariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:937:6-30
    return numpy.int32(165)
   if (_0=="writeIntHead"): # bld/herlev/final/default/src/fusion/Parameters.mbi:938:6-25
    return numpy.int32(173)
   if (_0=="writeIntConstraints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:939:6-32
    return numpy.int32(172)
   if (_0=="writeIntVariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:940:6-30
    return numpy.int32(174)
   if (_0=="solReadNameWidth"): # bld/herlev/final/default/src/fusion/Parameters.mbi:941:6-29
    return numpy.int32(159)
   if (_0=="solReadWidth"): # bld/herlev/final/default/src/fusion/Parameters.mbi:942:6-25
    return numpy.int32(160)
   if (_0=="infeasReportAuto"): # bld/herlev/final/default/src/fusion/Parameters.mbi:943:6-29
    return numpy.int32(14)
   if (_0=="infeasReportLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:944:6-30
    return numpy.int32(15)
   if (_0=="infeasGenericNames"): # bld/herlev/final/default/src/fusion/Parameters.mbi:945:6-31
    return numpy.int32(12)
   if (_0=="logInfeasAna"): # bld/herlev/final/default/src/fusion/Parameters.mbi:946:6-25
    return numpy.int32(45)
   if (_0=="licenseWait"): # bld/herlev/final/default/src/fusion/Parameters.mbi:947:6-24
    return numpy.int32(34)
   if (_0=="licenseSuppressExpireWrns"): # bld/herlev/final/default/src/fusion/Parameters.mbi:948:6-38
    return numpy.int32(32)
   if (_0=="licensePauseTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:949:6-29
    return numpy.int32(31)
   if (_0=="licenseDebug"): # bld/herlev/final/default/src/fusion/Parameters.mbi:950:6-25
    return numpy.int32(30)
   if (_0=="solFilterKeepBasic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:951:6-31
    return numpy.int32(157)
   if (_0=="solFilterKeepRanged"): # bld/herlev/final/default/src/fusion/Parameters.mbi:952:6-32
    return numpy.int32(158)
   if (_0=="log"): # bld/herlev/final/default/src/fusion/Parameters.mbi:953:6-16
    return numpy.int32(35)
   if (_0=="logExpand"): # bld/herlev/final/default/src/fusion/Parameters.mbi:954:6-22
    return numpy.int32(41)
   if (_0=="logFile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:955:6-20
    return numpy.int32(43)
   if (_0=="logOrder"): # bld/herlev/final/default/src/fusion/Parameters.mbi:956:6-21
    return numpy.int32(50)
   if (_0=="logSensitivity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:957:6-27
    return numpy.int32(53)
   if (_0=="logSensitivityOpt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:958:6-30
    return numpy.int32(54)
   if (_0=="readTaskIgnoreParam"): # bld/herlev/final/default/src/fusion/Parameters.mbi:959:6-32
    return numpy.int32(125)
   if (_0=="writeTaskIncSol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:960:6-28
    return numpy.int32(185)
   if (_0=="paramReadCaseName"): # bld/herlev/final/default/src/fusion/Parameters.mbi:961:6-30
    return numpy.int32(106)
   if (_0=="paramReadIgnError"): # bld/herlev/final/default/src/fusion/Parameters.mbi:962:6-30
    return numpy.int32(107)
   if (_0=="solutionCallback"): # bld/herlev/final/default/src/fusion/Parameters.mbi:963:6-29
    return numpy.int32(161)
   if (_0=="simScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:964:6-23
    return numpy.int32(151)
   if (_0=="simScalingMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:965:6-29
    return numpy.int32(152)
   if (_0=="simPrimalPhaseoneMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:966:6-36
    return numpy.int32(145)
   if (_0=="simDualPhaseoneMethod"): # bld/herlev/final/default/src/fusion/Parameters.mbi:967:6-34
    return numpy.int32(135)
   if (_0=="simMaxNumSetbacks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:968:6-30
    return numpy.int32(142)
   if (_0=="simHotstart"): # bld/herlev/final/default/src/fusion/Parameters.mbi:969:6-24
    return numpy.int32(139)
   if (_0=="simBasisFactorUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:970:6-30
    return numpy.int32(131)
   if (_0=="simDegen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:971:6-21
    return numpy.int32(132)
   if (_0=="simReformulation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:972:6-29
    return numpy.int32(149)
   if (_0=="simExploitDupvec"): # bld/herlev/final/default/src/fusion/Parameters.mbi:973:6-29
    return numpy.int32(138)
   if (_0=="simSaveLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:974:6-22
    return numpy.int32(150)
   if (_0=="simNonSingular"): # bld/herlev/final/default/src/fusion/Parameters.mbi:975:6-27
    return numpy.int32(143)
   if (_0=="simDualCrash"): # bld/herlev/final/default/src/fusion/Parameters.mbi:976:6-25
    return numpy.int32(134)
   if (_0=="logStorage"): # bld/herlev/final/default/src/fusion/Parameters.mbi:977:6-23
    return numpy.int32(58)
   if (_0=="infeasPreferPrimal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:978:6-31
    return numpy.int32(13)
   if (_0=="opfWriteLineLength"): # bld/herlev/final/default/src/fusion/Parameters.mbi:979:6-31
    return numpy.int32(98)
   if (_0=="opfWriteHints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:980:6-26
    return numpy.int32(97)
   if (_0=="opfWriteParameters"): # bld/herlev/final/default/src/fusion/Parameters.mbi:981:6-31
    return numpy.int32(99)
   if (_0=="opfWriteProblem"): # bld/herlev/final/default/src/fusion/Parameters.mbi:982:6-28
    return numpy.int32(100)
   if (_0=="opfWriteHeader"): # bld/herlev/final/default/src/fusion/Parameters.mbi:983:6-27
    return numpy.int32(96)
   if (_0=="opfWriteSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:984:6-30
    return numpy.int32(104)
   if (_0=="opfWriteSolBas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:985:6-27
    return numpy.int32(101)
   if (_0=="opfWriteSolItg"): # bld/herlev/final/default/src/fusion/Parameters.mbi:986:6-27
    return numpy.int32(102)
   if (_0=="opfWriteSolItr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:987:6-27
    return numpy.int32(103)
   if (_0=="ptfWriteTransform"): # bld/herlev/final/default/src/fusion/Parameters.mbi:988:6-30
    return numpy.int32(120)
   if (_0=="ptfWriteSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:989:6-30
    return numpy.int32(119)
   if (_0=="ptfWriteParameters"): # bld/herlev/final/default/src/fusion/Parameters.mbi:990:6-31
    return numpy.int32(118)
   if (_0=="primalRepairOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:991:6-34
    return numpy.int32(117)
   if (_0=="mioRootRepeatPresolveLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:992:6-39
    return numpy.int32(89)
   if (_0=="mioCutCmir"): # bld/herlev/final/default/src/fusion/Parameters.mbi:993:6-23
    return numpy.int32(64)
   if (_0=="mioCutClique"): # bld/herlev/final/default/src/fusion/Parameters.mbi:994:6-25
    return numpy.int32(63)
   if (_0=="mioCutImpliedBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:995:6-31
    return numpy.int32(66)
   if (_0=="mioCutKnapsackCover"): # bld/herlev/final/default/src/fusion/Parameters.mbi:996:6-32
    return numpy.int32(67)
   if (_0=="mioCutGmi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:997:6-22
    return numpy.int32(65)
   if (_0=="mioCutLipro"): # bld/herlev/final/default/src/fusion/Parameters.mbi:998:6-24
    return numpy.int32(68)
   if (_0=="sensitivityType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:999:6-28
    return numpy.int32(130)
   if (_0=="mioConstructSol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1000:6-28
    return numpy.int32(62)
   if (_0=="presolveLindepRelWorkTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1001:6-37
    return numpy.int32(112)
   if (_0=="presolveLindepAbsWorkTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1002:6-37
    return numpy.int32(111)
   if (_0=="sensitivityAll"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1003:6-27
    return numpy.int32(128)
   if (_0=="logFeasRepair"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1004:6-26
    return numpy.int32(42)
   if (_0=="cacheLicense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1005:6-25
    return numpy.int32(9)
   if (_0=="intpntRegularizationUse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1006:6-36
    return numpy.int32(26)
   if (_0=="simSolveForm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1007:6-25
    return numpy.int32(154)
   if (_0=="simSwitchOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1008:6-31
    return numpy.int32(156)
   if (_0=="writeIgnoreIncompatibleItems"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1009:6-41
    return numpy.int32(171)
   if (_0=="checkConvexity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1010:6-27
    return numpy.int32(10)
   if (_0=="logCheckConvexity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1011:6-30
    return numpy.int32(39)
   if (_0=="autoSortABeforeOpt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1012:6-31
    return numpy.int32(2)
   if (_0=="sensitivityOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1013:6-33
    return numpy.int32(129)
   if (_0=="writeXmlMode"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1014:6-25
    return numpy.int32(186)
   if (_0=="anaSolBasis"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1015:6-24
    return numpy.int32(0)
   if (_0=="anaSolPrintViolated"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1016:6-32
    return numpy.int32(1)
   if (_0=="basisSolveUsePlusOne"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1017:6-33
    return numpy.int32(4)
   if (_0=="compressStatfile"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1018:6-29
    return numpy.int32(11)
   if (_0=="mioRinsMaxNodes"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1019:6-28
    return numpy.int32(87)
   if (_0=="mioFeaspumpLevel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1020:6-29
    return numpy.int32(71)
   if (_0=="ng"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1021:6-15
    return numpy.int32(94)
   if (_0=="remoteUseCompression"): # bld/herlev/final/default/src/fusion/Parameters.mbi:1022:6-33
    return numpy.int32(126)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iomode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iomode_1value_S(_0)
  @staticmethod
  def __string_1to_1iomode_1value_S(_0):
   if (_0=="read"): # bld/herlev/final/default/src/fusion/Parameters.mbi:829:6-17
    return numpy.int32(0)
   if (_0=="write"): # bld/herlev/final/default/src/fusion/Parameters.mbi:830:6-18
    return numpy.int32(1)
   if (_0=="readwrite"): # bld/herlev/final/default/src/fusion/Parameters.mbi:831:6-22
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1iinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1iinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1iinf_1value_S(_0):
   if (_0=="versionMajor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:703:6-25
    return numpy.int32(119)
   if (_0=="versionMinor"): # bld/herlev/final/default/src/fusion/Parameters.mbi:704:6-25
    return numpy.int32(120)
   if (_0=="versionRevision"): # bld/herlev/final/default/src/fusion/Parameters.mbi:705:6-28
    return numpy.int32(121)
   if (_0=="presolveLindepWork"): # bld/herlev/final/default/src/fusion/Parameters.mbi:706:6-31
    return numpy.int32(69)
   if (_0=="presolveLindepPivots"): # bld/herlev/final/default/src/fusion/Parameters.mbi:707:6-33
    return numpy.int32(67)
   if (_0=="presolveLindepSkipped"): # bld/herlev/final/default/src/fusion/Parameters.mbi:708:6-34
    return numpy.int32(68)
   if (_0=="presolveOutofspace"): # bld/herlev/final/default/src/fusion/Parameters.mbi:709:6-31
    return numpy.int32(88)
   if (_0=="optObjectiveSense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:710:6-30
    return numpy.int32(38)
   if (_0=="optimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:711:6-22
    return numpy.int32(39)
   if (_0=="intpntFirRefIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:712:6-29
    return numpy.int32(17)
   if (_0=="intpntNumRefSteps"): # bld/herlev/final/default/src/fusion/Parameters.mbi:713:6-30
    return numpy.int32(22)
   if (_0=="intpntFactorSchurNumDup"): # bld/herlev/final/default/src/fusion/Parameters.mbi:714:6-36
    return numpy.int32(15)
   if (_0=="intpntFactorSchurNumBlk"): # bld/herlev/final/default/src/fusion/Parameters.mbi:715:6-36
    return numpy.int32(14)
   if (_0=="intpntFactorSchurMinBlkDim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:716:6-39
    return numpy.int32(13)
   if (_0=="intpntFactorSchurMaxBlkDim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:717:6-39
    return numpy.int32(12)
   if (_0=="intpntFactorSchurNumSingular"): # bld/herlev/final/default/src/fusion/Parameters.mbi:718:6-41
    return numpy.int32(16)
   if (_0=="intpntFactorDim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:719:6-28
    return numpy.int32(2)
   if (_0=="intpntFactorLDim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:720:6-29
    return numpy.int32(3)
   if (_0=="intpntFactorOrderMlLNumDense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:721:6-41
    return numpy.int32(11)
   if (_0=="intpntFactorOrderMlLMaxHeight"): # bld/herlev/final/default/src/fusion/Parameters.mbi:722:6-42
    return numpy.int32(10)
   if (_0=="intpntFactorOrderGpLMaxHeight"): # bld/herlev/final/default/src/fusion/Parameters.mbi:723:6-42
    return numpy.int32(9)
   if (_0=="intpntFactorNumDenseA"): # bld/herlev/final/default/src/fusion/Parameters.mbi:724:6-34
    return numpy.int32(5)
   if (_0=="intpntFactorNumDenseADup"): # bld/herlev/final/default/src/fusion/Parameters.mbi:725:6-37
    return numpy.int32(6)
   if (_0=="intpntFactorNumDenseW"): # bld/herlev/final/default/src/fusion/Parameters.mbi:726:6-34
    return numpy.int32(7)
   if (_0=="intpntNumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:727:6-25
    return numpy.int32(29)
   if (_0=="intpntNumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:728:6-25
    return numpy.int32(36)
   if (_0=="intpntNumbarvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:729:6-28
    return numpy.int32(23)
   if (_0=="intpntNumblo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:730:6-25
    return numpy.int32(26)
   if (_0=="intpntNumbup"): # bld/herlev/final/default/src/fusion/Parameters.mbi:731:6-25
    return numpy.int32(28)
   if (_0=="intpntNumbfr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:732:6-25
    return numpy.int32(24)
   if (_0=="intpntNumbfx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:733:6-25
    return numpy.int32(25)
   if (_0=="intpntNumcone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:734:6-26
    return numpy.int32(30)
   if (_0=="intpntNumconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:735:6-29
    return numpy.int32(31)
   if (_0=="intpntNumbndcone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:736:6-29
    return numpy.int32(27)
   if (_0=="intpntNumrqcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:737:6-29
    return numpy.int32(35)
   if (_0=="intpntNumqcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:738:6-28
    return numpy.int32(34)
   if (_0=="intpntNumpexpcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:739:6-31
    return numpy.int32(32)
   if (_0=="intpntNumppowcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:740:6-31
    return numpy.int32(33)
   if (_0=="intpntMinconedim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:741:6-29
    return numpy.int32(21)
   if (_0=="intpntMaxconedim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:742:6-29
    return numpy.int32(20)
   if (_0=="intpntMaxbarvardim"): # bld/herlev/final/default/src/fusion/Parameters.mbi:743:6-31
    return numpy.int32(19)
   if (_0=="presolveNumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:744:6-27
    return numpy.int32(77)
   if (_0=="presolveNumcfr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:745:6-27
    return numpy.int32(73)
   if (_0=="presolveNumcfx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:746:6-27
    return numpy.int32(74)
   if (_0=="presolveNumclo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:747:6-27
    return numpy.int32(75)
   if (_0=="presolveNumcup"): # bld/herlev/final/default/src/fusion/Parameters.mbi:748:6-27
    return numpy.int32(79)
   if (_0=="presolveNumcra"): # bld/herlev/final/default/src/fusion/Parameters.mbi:749:6-27
    return numpy.int32(78)
   if (_0=="presolveNumcnl"): # bld/herlev/final/default/src/fusion/Parameters.mbi:750:6-27
    return numpy.int32(76)
   if (_0=="presolveNumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:751:6-27
    return numpy.int32(81)
   if (_0=="presolveNumvfr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:752:6-27
    return numpy.int32(82)
   if (_0=="presolveNumvfx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:753:6-27
    return numpy.int32(83)
   if (_0=="presolveNumvlo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:754:6-27
    return numpy.int32(84)
   if (_0=="presolveNumvup"): # bld/herlev/final/default/src/fusion/Parameters.mbi:755:6-27
    return numpy.int32(87)
   if (_0=="presolveNumvra"): # bld/herlev/final/default/src/fusion/Parameters.mbi:756:6-27
    return numpy.int32(86)
   if (_0=="presolveNumvnl"): # bld/herlev/final/default/src/fusion/Parameters.mbi:757:6-27
    return numpy.int32(85)
   if (_0=="presolveNumnza"): # bld/herlev/final/default/src/fusion/Parameters.mbi:758:6-27
    return numpy.int32(80)
   if (_0=="presolveFnumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:759:6-28
    return numpy.int32(49)
   if (_0=="presolveFnumcfr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:760:6-28
    return numpy.int32(45)
   if (_0=="presolveFnumcfx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:761:6-28
    return numpy.int32(46)
   if (_0=="presolveFnumclo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:762:6-28
    return numpy.int32(47)
   if (_0=="presolveFnumcup"): # bld/herlev/final/default/src/fusion/Parameters.mbi:763:6-28
    return numpy.int32(51)
   if (_0=="presolveFnumcra"): # bld/herlev/final/default/src/fusion/Parameters.mbi:764:6-28
    return numpy.int32(50)
   if (_0=="presolveFnumcnl"): # bld/herlev/final/default/src/fusion/Parameters.mbi:765:6-28
    return numpy.int32(48)
   if (_0=="presolveFnumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:766:6-28
    return numpy.int32(53)
   if (_0=="presolveFnumvfr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:767:6-28
    return numpy.int32(54)
   if (_0=="presolveFnumvfx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:768:6-28
    return numpy.int32(55)
   if (_0=="presolveFnumvlo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:769:6-28
    return numpy.int32(56)
   if (_0=="presolveFnumvup"): # bld/herlev/final/default/src/fusion/Parameters.mbi:770:6-28
    return numpy.int32(59)
   if (_0=="presolveFnumvra"): # bld/herlev/final/default/src/fusion/Parameters.mbi:771:6-28
    return numpy.int32(58)
   if (_0=="presolveFnumvnl"): # bld/herlev/final/default/src/fusion/Parameters.mbi:772:6-28
    return numpy.int32(57)
   if (_0=="presolveFnumnza"): # bld/herlev/final/default/src/fusion/Parameters.mbi:773:6-28
    return numpy.int32(52)
   if (_0=="presolveNumElimns"): # bld/herlev/final/default/src/fusion/Parameters.mbi:774:6-30
    return numpy.int32(71)
   if (_0=="presolveEliNumTries"): # bld/herlev/final/default/src/fusion/Parameters.mbi:775:6-32
    return numpy.int32(44)
   if (_0=="presolveEliNumFreedCon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:776:6-35
    return numpy.int32(42)
   if (_0=="presolveEliNumFreedConTotal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:777:6-40
    return numpy.int32(43)
   if (_0=="presolveLindepNumTries"): # bld/herlev/final/default/src/fusion/Parameters.mbi:778:6-35
    return numpy.int32(65)
   if (_0=="presolveLindepNum"): # bld/herlev/final/default/src/fusion/Parameters.mbi:779:6-30
    return numpy.int32(64)
   if (_0=="presolveForceConNum"): # bld/herlev/final/default/src/fusion/Parameters.mbi:780:6-32
    return numpy.int32(60)
   if (_0=="presolveForceConNumVar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:781:6-35
    return numpy.int32(61)
   if (_0=="presolveForceVarNum"): # bld/herlev/final/default/src/fusion/Parameters.mbi:782:6-32
    return numpy.int32(62)
   if (_0=="presolveForceVarNumCon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:783:6-35
    return numpy.int32(63)
   if (_0=="presolvePivOnConNum"): # bld/herlev/final/default/src/fusion/Parameters.mbi:784:6-32
    return numpy.int32(89)
   if (_0=="presolveNumDouBlocks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:785:6-33
    return numpy.int32(70)
   if (_0=="presolveNumSimplifiedDouBlocks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:786:6-43
    return numpy.int32(72)
   if (_0=="presolveSizeSimplifiedDouBlocks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:787:6-44
    return numpy.int32(90)
   if (_0=="presolveAccNumDupVarInNrmtwo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:788:6-41
    return numpy.int32(41)
   if (_0=="presolveAccNumDoubletonChainInNrmtwo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:789:6-49
    return numpy.int32(40)
   if (_0=="intpntFactorNum"): # bld/herlev/final/default/src/fusion/Parameters.mbi:790:6-28
    return numpy.int32(4)
   if (_0=="intpntFactorNumSolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:791:6-33
    return numpy.int32(8)
   if (_0=="simplexPrimalHotstartNumBasics"): # bld/herlev/final/default/src/fusion/Parameters.mbi:792:6-43
    return numpy.int32(109)
   if (_0=="simplexPrimalHotstartBasisRank"): # bld/herlev/final/default/src/fusion/Parameters.mbi:793:6-43
    return numpy.int32(108)
   if (_0=="simplexDualHotstartNumBasics"): # bld/herlev/final/default/src/fusion/Parameters.mbi:794:6-41
    return numpy.int32(104)
   if (_0=="simplexDualHotstartBasisRank"): # bld/herlev/final/default/src/fusion/Parameters.mbi:795:6-41
    return numpy.int32(103)
   if (_0=="intpntGpOrderEmployed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:796:6-34
    return numpy.int32(18)
   if (_0=="numLuFactorizations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:797:6-32
    return numpy.int32(37)
   if (_0=="simplexPwlNumPotential"): # bld/herlev/final/default/src/fusion/Parameters.mbi:798:6-35
    return numpy.int32(115)
   if (_0=="simplexPwlNumUsed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:799:6-30
    return numpy.int32(116)
   if (_0=="simplexPwlNumVariables"): # bld/herlev/final/default/src/fusion/Parameters.mbi:800:6-35
    return numpy.int32(117)
   if (_0=="simplexPwlMinNumBreakpoints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:801:6-40
    return numpy.int32(114)
   if (_0=="simplexPwlMaxNumBreakpoints"): # bld/herlev/final/default/src/fusion/Parameters.mbi:802:6-40
    return numpy.int32(112)
   if (_0=="simplexPwlMaxNz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:803:6-28
    return numpy.int32(113)
   if (_0=="simplexPwlNzReduction"): # bld/herlev/final/default/src/fusion/Parameters.mbi:804:6-34
    return numpy.int32(118)
   if (_0=="simplexPrimalNumSetbacks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:805:6-37
    return numpy.int32(110)
   if (_0=="simplexDualNumSetbacks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:806:6-35
    return numpy.int32(105)
   if (_0=="simplexPrimalFeasNa"): # bld/herlev/final/default/src/fusion/Parameters.mbi:807:6-32
    return numpy.int32(107)
   if (_0=="simplexDualFeasNa"): # bld/herlev/final/default/src/fusion/Parameters.mbi:808:6-30
    return numpy.int32(102)
   if (_0=="simplexPrimalObjNa"): # bld/herlev/final/default/src/fusion/Parameters.mbi:809:6-31
    return numpy.int32(111)
   if (_0=="simplexDualObjNa"): # bld/herlev/final/default/src/fusion/Parameters.mbi:810:6-29
    return numpy.int32(106)
   if (_0=="simNumPrimalBoundswaps"): # bld/herlev/final/default/src/fusion/Parameters.mbi:811:6-35
    return numpy.int32(101)
   if (_0=="simNumDualBoundswaps"): # bld/herlev/final/default/src/fusion/Parameters.mbi:812:6-33
    return numpy.int32(99)
   if (_0=="simNumDualIntegerPivots"): # bld/herlev/final/default/src/fusion/Parameters.mbi:813:6-36
    return numpy.int32(100)
   if (_0=="purifyNumRow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:814:6-25
    return numpy.int32(96)
   if (_0=="purifyPNumNullRow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:815:6-30
    return numpy.int32(97)
   if (_0=="purifyPNumSingletonCol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:816:6-35
    return numpy.int32(98)
   if (_0=="purifyCrashL11NumRow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:817:6-33
    return numpy.int32(91)
   if (_0=="purifyCrashL22NumRow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:818:6-33
    return numpy.int32(92)
   if (_0=="purifyCrashL33NumRow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:819:6-33
    return numpy.int32(94)
   if (_0=="purifyCrashL33NumCol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:820:6-33
    return numpy.int32(93)
   if (_0=="purifyCrashSingularity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:821:6-35
    return numpy.int32(95)
   if (_0=="biPrimalInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:822:6-25
    return numpy.int32(1)
   if (_0=="biDualInfo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:823:6-23
    return numpy.int32(0)
   if (_0=="presolveLindepNumTruncTries"): # bld/herlev/final/default/src/fusion/Parameters.mbi:824:6-40
    return numpy.int32(66)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1dinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1dinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1dinf_1value_S(_0):
   if (_0=="sensitivityPrimalTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:604:6-34
    return numpy.int32(90)
   if (_0=="sensitivityDualTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:605:6-32
    return numpy.int32(89)
   if (_0=="intpntGfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:606:6-24
    return numpy.int32(67)
   if (_0=="intpntMu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:607:6-21
    return numpy.int32(74)
   if (_0=="intpntInitIterTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:608:6-31
    return numpy.int32(69)
   if (_0=="intpntFactorTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:609:6-29
    return numpy.int32(65)
   if (_0=="intpntInitSearchTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:610:6-33
    return numpy.int32(70)
   if (_0=="intpntFormSearchTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:611:6-33
    return numpy.int32(66)
   if (_0=="intpntCorrectorTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:612:6-32
    return numpy.int32(12)
   if (_0=="intpntUpdateTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:613:6-29
    return numpy.int32(79)
   if (_0=="intpntFactorSetupTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:614:6-34
    return numpy.int32(58)
   if (_0=="intpntFactorSchurTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:615:6-34
    return numpy.int32(51)
   if (_0=="intpntFactorHatSchurTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:616:6-37
    return numpy.int32(48)
   if (_0=="intpntFactorHatSchurPushTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:617:6-41
    return numpy.int32(47)
   if (_0=="intpntFactorHatSchurPullTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:618:6-41
    return numpy.int32(45)
   if (_0=="intpntFactorBarSchurTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:619:6-37
    return numpy.int32(17)
   if (_0=="intpntFactorBarSchurDeTabTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:620:6-42
    return numpy.int32(13)
   if (_0=="intpntFactorBarSchurSpTabTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:621:6-42
    return numpy.int32(16)
   if (_0=="intpntFactorSparseLTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:622:6-36
    return numpy.int32(62)
   if (_0=="intpntFactorSparseLUpdateLastTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:623:6-46
    return numpy.int32(64)
   if (_0=="intpntFactorSparseLFactorLastTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:624:6-46
    return numpy.int32(60)
   if (_0=="intpntFactorDenseLTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:625:6-35
    return numpy.int32(40)
   if (_0=="intpntFactorDenseTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:626:6-34
    return numpy.int32(41)
   if (_0=="intpntFactorDenseDotaTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:627:6-38
    return numpy.int32(28)
   if (_0=="intpntFactorDenseDotaSolveTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:628:6-43
    return numpy.int32(27)
   if (_0=="intpntFactorDenseDotatdotaTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:629:6-43
    return numpy.int32(30)
   if (_0=="intpntFactorDenseDotlInitTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:630:6-42
    return numpy.int32(37)
   if (_0=="intpntFactorDenseDotlFactorTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:631:6-44
    return numpy.int32(36)
   if (_0=="intpntFactorBarSchurUpdateTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:632:6-43
    return numpy.int32(25)
   if (_0=="intpntFactorBarSchurUpdateCompressedETime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:633:6-54
    return numpy.int32(18)
   if (_0=="intpntFactorBarSchurUpdateSparseTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:634:6-49
    return numpy.int32(24)
   if (_0=="intpntFactorBarSchurUpdateSparseSyr2kTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:635:6-54
    return numpy.int32(23)
   if (_0=="intpntFactorBarSchurUpdateSparseDotTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:636:6-52
    return numpy.int32(22)
   if (_0=="intpntFactorBarSchurUpdateDenseTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:637:6-48
    return numpy.int32(21)
   if (_0=="intpntFactorBarSchurUpdateDenseSyr2kTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:638:6-53
    return numpy.int32(20)
   if (_0=="intpntFactorBarSchurUpdateDenseDotTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:639:6-51
    return numpy.int32(19)
   if (_0=="intpntFactorBarSchurPushTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:640:6-41
    return numpy.int32(15)
   if (_0=="intpntIterNonCorrectorFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:641:6-40
    return numpy.int32(71)
   if (_0=="intpntIterOneCorrectorFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:642:6-40
    return numpy.int32(72)
   if (_0=="intpntSolveTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:643:6-28
    return numpy.int32(78)
   if (_0=="intpntIterRefTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:644:6-30
    return numpy.int32(73)
   if (_0=="intpntSolveSparseLTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:645:6-35
    return numpy.int32(77)
   if (_0=="intpntSolveDenseLTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:646:6-34
    return numpy.int32(76)
   if (_0=="intpntFactorSetupFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:647:6-35
    return numpy.int32(53)
   if (_0=="intpntFactorSetupHatSchurFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:648:6-43
    return numpy.int32(56)
   if (_0=="intpntFactorSchurFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:649:6-35
    return numpy.int32(50)
   if (_0=="intpntFactorHatSchurFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:650:6-38
    return numpy.int32(43)
   if (_0=="intpntFactorHatSchurPushFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:651:6-42
    return numpy.int32(46)
   if (_0=="intpntFactorHatSchurPullFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:652:6-42
    return numpy.int32(44)
   if (_0=="intpntFactorBarSchurFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:653:6-38
    return numpy.int32(14)
   if (_0=="intpntFactorSparseLFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:654:6-37
    return numpy.int32(61)
   if (_0=="intpntFactorMlOrderSparseLFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:655:6-44
    return numpy.int32(49)
   if (_0=="intpntFactorGpOrderSparseLFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:656:6-44
    return numpy.int32(42)
   if (_0=="intpntFactorSparseLUpdateLastFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:657:6-47
    return numpy.int32(63)
   if (_0=="intpntFactorSparseLFactorLastFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:658:6-47
    return numpy.int32(59)
   if (_0=="intpntFactorDenseLFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:659:6-36
    return numpy.int32(39)
   if (_0=="intpntFactorDenseFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:660:6-35
    return numpy.int32(38)
   if (_0=="intpntFactorDenseDotaFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:661:6-39
    return numpy.int32(26)
   if (_0=="intpntFactorDenseDotatdotaFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:662:6-44
    return numpy.int32(29)
   if (_0=="intpntFactorDenseDotlFactor_initFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:663:6-50
    return numpy.int32(34)
   if (_0=="intpntFactorDenseDotlFactorFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:664:6-45
    return numpy.int32(35)
   if (_0=="intpntFactorDenseDotl11FactorFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:665:6-47
    return numpy.int32(31)
   if (_0=="intpntFactorDenseDotl21FactorFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:666:6-47
    return numpy.int32(32)
   if (_0=="intpntFactorDenseDotl22FactorFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:667:6-47
    return numpy.int32(33)
   if (_0=="presolveAcoltTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:668:6-30
    return numpy.int32(80)
   if (_0=="presolveSetupTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:669:6-30
    return numpy.int32(85)
   if (_0=="presolveCheckproTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:670:6-33
    return numpy.int32(81)
   if (_0=="presolveDupconTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:671:6-31
    return numpy.int32(82)
   if (_0=="presolveDupvarTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:672:6-31
    return numpy.int32(83)
   if (_0=="presolveFinalTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:673:6-30
    return numpy.int32(84)
   if (_0=="presolveSubDomvarTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:674:6-34
    return numpy.int32(86)
   if (_0=="presolveSubRelaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:675:6-33
    return numpy.int32(87)
   if (_0=="primalSimplexInftime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:676:6-33
    return numpy.int32(88)
   if (_0=="dualSimplexInftime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:677:6-31
    return numpy.int32(11)
   if (_0=="intpntGpOrderSavedFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:678:6-36
    return numpy.int32(68)
   if (_0=="intpntFactorSetupDetectDenseTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:679:6-45
    return numpy.int32(52)
   if (_0=="intpntFactorSetupMlOrderTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:680:6-41
    return numpy.int32(57)
   if (_0=="intpntFactorSetupGpOrderTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:681:6-41
    return numpy.int32(55)
   if (_0=="intpntFactorSetupGpOrderPostTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:682:6-45
    return numpy.int32(54)
   if (_0=="biCrashTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:683:6-24
    return numpy.int32(1)
   if (_0=="biCrashLuTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:684:6-26
    return numpy.int32(0)
   if (_0=="biFactorTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:685:6-25
    return numpy.int32(5)
   if (_0=="biFactorWork"): # bld/herlev/final/default/src/fusion/Parameters.mbi:686:6-25
    return numpy.int32(6)
   if (_0=="biPrimalDone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:687:6-25
    return numpy.int32(8)
   if (_0=="biDualDone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:688:6-23
    return numpy.int32(2)
   if (_0=="simplexPrimalObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:689:6-29
    return numpy.int32(94)
   if (_0=="simplexPrimalFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:690:6-30
    return numpy.int32(93)
   if (_0=="simplexDualObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:691:6-27
    return numpy.int32(92)
   if (_0=="simplexDualFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:692:6-28
    return numpy.int32(91)
   if (_0=="biInitialBasisCond"): # bld/herlev/final/default/src/fusion/Parameters.mbi:693:6-31
    return numpy.int32(7)
   if (_0=="biPrimalObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:694:6-24
    return numpy.int32(10)
   if (_0=="biDualObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:695:6-22
    return numpy.int32(4)
   if (_0=="biPrimalFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:696:6-25
    return numpy.int32(9)
   if (_0=="biDualFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:697:6-23
    return numpy.int32(3)
   if (_0=="intpntPurifyTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:698:6-29
    return numpy.int32(75)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1inftype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1inftype_1value_S(_0)
  @staticmethod
  def __string_1to_1inftype_1value_S(_0):
   if (_0=="douType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:597:6-20
    return numpy.int32(0)
   if (_0=="intType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:598:6-20
    return numpy.int32(1)
   if (_0=="lintType"): # bld/herlev/final/default/src/fusion/Parameters.mbi:599:6-21
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1iinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1iinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1iinfitem_1value_S(_0):
   if (_0=="anaProNumCon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:487:6-25
    return numpy.int32(0)
   if (_0=="anaProNumConLo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:488:6-27
    return numpy.int32(3)
   if (_0=="anaProNumConUp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:489:6-27
    return numpy.int32(5)
   if (_0=="anaProNumConRa"): # bld/herlev/final/default/src/fusion/Parameters.mbi:490:6-27
    return numpy.int32(4)
   if (_0=="anaProNumConEq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:491:6-27
    return numpy.int32(1)
   if (_0=="anaProNumConFr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:492:6-27
    return numpy.int32(2)
   if (_0=="anaProNumVar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:493:6-25
    return numpy.int32(6)
   if (_0=="anaProNumVarLo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:494:6-27
    return numpy.int32(12)
   if (_0=="anaProNumVarUp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:495:6-27
    return numpy.int32(14)
   if (_0=="anaProNumVarRa"): # bld/herlev/final/default/src/fusion/Parameters.mbi:496:6-27
    return numpy.int32(13)
   if (_0=="anaProNumVarEq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:497:6-27
    return numpy.int32(9)
   if (_0=="anaProNumVarFr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:498:6-27
    return numpy.int32(10)
   if (_0=="anaProNumVarCont"): # bld/herlev/final/default/src/fusion/Parameters.mbi:499:6-29
    return numpy.int32(8)
   if (_0=="anaProNumVarBin"): # bld/herlev/final/default/src/fusion/Parameters.mbi:500:6-28
    return numpy.int32(7)
   if (_0=="anaProNumVarInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:501:6-28
    return numpy.int32(11)
   if (_0=="optimizeResponse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:502:6-29
    return numpy.int32(75)
   if (_0=="presolveNumPrimalPerturbations"): # bld/herlev/final/default/src/fusion/Parameters.mbi:503:6-43
    return numpy.int32(76)
   if (_0=="intpntIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:504:6-23
    return numpy.int32(16)
   if (_0=="intpntFactorDimDense"): # bld/herlev/final/default/src/fusion/Parameters.mbi:505:6-33
    return numpy.int32(15)
   if (_0=="intpntSolveDual"): # bld/herlev/final/default/src/fusion/Parameters.mbi:506:6-28
    return numpy.int32(18)
   if (_0=="mioNodeDepth"): # bld/herlev/final/default/src/fusion/Parameters.mbi:507:6-25
    return numpy.int32(23)
   if (_0=="mioNumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:508:6-22
    return numpy.int32(51)
   if (_0=="mioNumbin"): # bld/herlev/final/default/src/fusion/Parameters.mbi:509:6-22
    return numpy.int32(35)
   if (_0=="mioNumint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:510:6-22
    return numpy.int32(45)
   if (_0=="mioNumcont"): # bld/herlev/final/default/src/fusion/Parameters.mbi:511:6-23
    return numpy.int32(40)
   if (_0=="mioNumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:512:6-22
    return numpy.int32(37)
   if (_0=="mioNumcone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:513:6-23
    return numpy.int32(38)
   if (_0=="mioNumqcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:514:6-25
    return numpy.int32(49)
   if (_0=="mioNumrqcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:515:6-26
    return numpy.int32(50)
   if (_0=="mioNumpexpcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:516:6-28
    return numpy.int32(47)
   if (_0=="mioNumdexpcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:517:6-28
    return numpy.int32(42)
   if (_0=="mioNumppowcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:518:6-28
    return numpy.int32(48)
   if (_0=="mioNumdpowcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:519:6-28
    return numpy.int32(44)
   if (_0=="mioNumconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:520:6-26
    return numpy.int32(39)
   if (_0=="mioNumbinconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:521:6-29
    return numpy.int32(36)
   if (_0=="mioNumintconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:522:6-29
    return numpy.int32(46)
   if (_0=="mioNumcontconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:523:6-30
    return numpy.int32(41)
   if (_0=="mioNumdjc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:524:6-22
    return numpy.int32(43)
   if (_0=="mioPresolvedNumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:525:6-31
    return numpy.int32(69)
   if (_0=="mioPresolvedNumbin"): # bld/herlev/final/default/src/fusion/Parameters.mbi:526:6-31
    return numpy.int32(53)
   if (_0=="mioPresolvedNumint"): # bld/herlev/final/default/src/fusion/Parameters.mbi:527:6-31
    return numpy.int32(63)
   if (_0=="mioPresolvedNumcont"): # bld/herlev/final/default/src/fusion/Parameters.mbi:528:6-32
    return numpy.int32(58)
   if (_0=="mioPresolvedNumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:529:6-31
    return numpy.int32(55)
   if (_0=="mioPresolvedNumcone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:530:6-32
    return numpy.int32(56)
   if (_0=="mioPresolvedNumqcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:531:6-34
    return numpy.int32(67)
   if (_0=="mioPresolvedNumrqcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:532:6-35
    return numpy.int32(68)
   if (_0=="mioPresolvedNumpexpcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:533:6-37
    return numpy.int32(65)
   if (_0=="mioPresolvedNumdexpcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:534:6-37
    return numpy.int32(60)
   if (_0=="mioPresolvedNumppowcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:535:6-37
    return numpy.int32(66)
   if (_0=="mioPresolvedNumdpowcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:536:6-37
    return numpy.int32(62)
   if (_0=="mioPresolvedNumconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:537:6-35
    return numpy.int32(57)
   if (_0=="mioPresolvedNumbinconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:538:6-38
    return numpy.int32(54)
   if (_0=="mioPresolvedNumintconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:539:6-38
    return numpy.int32(64)
   if (_0=="mioPresolvedNumcontconevar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:540:6-39
    return numpy.int32(59)
   if (_0=="mioPresolvedNumdjc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:541:6-31
    return numpy.int32(61)
   if (_0=="mioCliqueTableSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:542:6-31
    return numpy.int32(20)
   if (_0=="mioConstructSolution"): # bld/herlev/final/default/src/fusion/Parameters.mbi:543:6-33
    return numpy.int32(21)
   if (_0=="mioInitialFeasibleSolution"): # bld/herlev/final/default/src/fusion/Parameters.mbi:544:6-39
    return numpy.int32(22)
   if (_0=="mioNumIntSolutions"): # bld/herlev/final/default/src/fusion/Parameters.mbi:545:6-31
    return numpy.int32(30)
   if (_0=="mioObjBoundDefined"): # bld/herlev/final/default/src/fusion/Parameters.mbi:546:6-31
    return numpy.int32(52)
   if (_0=="mioNumActiveNodes"): # bld/herlev/final/default/src/fusion/Parameters.mbi:547:6-30
    return numpy.int32(24)
   if (_0=="mioNumRelax"): # bld/herlev/final/default/src/fusion/Parameters.mbi:548:6-24
    return numpy.int32(33)
   if (_0=="mioNumBranch"): # bld/herlev/final/default/src/fusion/Parameters.mbi:549:6-25
    return numpy.int32(25)
   if (_0=="mioTotalNumCuts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:550:6-28
    return numpy.int32(71)
   if (_0=="mioNumCmirCuts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:551:6-27
    return numpy.int32(27)
   if (_0=="mioNumCliqueCuts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:552:6-29
    return numpy.int32(26)
   if (_0=="mioNumImpliedBoundCuts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:553:6-35
    return numpy.int32(29)
   if (_0=="mioNumKnapsackCoverCuts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:554:6-36
    return numpy.int32(31)
   if (_0=="mioNumGomoryCuts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:555:6-29
    return numpy.int32(28)
   if (_0=="mioNumLiproCuts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:556:6-28
    return numpy.int32(32)
   if (_0=="mioNumRepeatedPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:557:6-35
    return numpy.int32(34)
   if (_0=="mioUserObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:558:6-26
    return numpy.int32(72)
   if (_0=="mioRelgapSatisfied"): # bld/herlev/final/default/src/fusion/Parameters.mbi:559:6-31
    return numpy.int32(70)
   if (_0=="mioAbsgapSatisfied"): # bld/herlev/final/default/src/fusion/Parameters.mbi:560:6-31
    return numpy.int32(19)
   if (_0=="rdProtype"): # bld/herlev/final/default/src/fusion/Parameters.mbi:561:6-22
    return numpy.int32(85)
   if (_0=="rdNumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:562:6-21
    return numpy.int32(80)
   if (_0=="rdNumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:563:6-21
    return numpy.int32(84)
   if (_0=="rdNumbarvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:564:6-24
    return numpy.int32(79)
   if (_0=="rdNumintvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:565:6-24
    return numpy.int32(82)
   if (_0=="rdNumq"): # bld/herlev/final/default/src/fusion/Parameters.mbi:566:6-19
    return numpy.int32(83)
   if (_0=="simDualDegIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:567:6-27
    return numpy.int32(86)
   if (_0=="simDualInfIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:568:6-27
    return numpy.int32(89)
   if (_0=="simDualHotstartLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:569:6-30
    return numpy.int32(88)
   if (_0=="simPrimalIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:570:6-26
    return numpy.int32(97)
   if (_0=="simDualIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:571:6-24
    return numpy.int32(90)
   if (_0=="intpntNumThreads"): # bld/herlev/final/default/src/fusion/Parameters.mbi:572:6-29
    return numpy.int32(17)
   if (_0=="simPrimalInfIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:573:6-29
    return numpy.int32(96)
   if (_0=="simPrimalDegIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:574:6-29
    return numpy.int32(93)
   if (_0=="simPrimalHotstart"): # bld/herlev/final/default/src/fusion/Parameters.mbi:575:6-30
    return numpy.int32(94)
   if (_0=="simPrimalHotstartLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:576:6-32
    return numpy.int32(95)
   if (_0=="simDualHotstart"): # bld/herlev/final/default/src/fusion/Parameters.mbi:577:6-28
    return numpy.int32(87)
   if (_0=="solItrProsta"): # bld/herlev/final/default/src/fusion/Parameters.mbi:578:6-25
    return numpy.int32(103)
   if (_0=="solItrSolsta"): # bld/herlev/final/default/src/fusion/Parameters.mbi:579:6-25
    return numpy.int32(104)
   if (_0=="solBasProsta"): # bld/herlev/final/default/src/fusion/Parameters.mbi:580:6-25
    return numpy.int32(99)
   if (_0=="solBasSolsta"): # bld/herlev/final/default/src/fusion/Parameters.mbi:581:6-25
    return numpy.int32(100)
   if (_0=="solItgProsta"): # bld/herlev/final/default/src/fusion/Parameters.mbi:582:6-25
    return numpy.int32(101)
   if (_0=="solItgSolsta"): # bld/herlev/final/default/src/fusion/Parameters.mbi:583:6-25
    return numpy.int32(102)
   if (_0=="simNumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:584:6-22
    return numpy.int32(91)
   if (_0=="simNumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:585:6-22
    return numpy.int32(92)
   if (_0=="optNumcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:586:6-22
    return numpy.int32(73)
   if (_0=="optNumvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:587:6-22
    return numpy.int32(74)
   if (_0=="stoNumARealloc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:588:6-27
    return numpy.int32(105)
   if (_0=="rdNumcone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:589:6-22
    return numpy.int32(81)
   if (_0=="simSolveDual"): # bld/herlev/final/default/src/fusion/Parameters.mbi:590:6-25
    return numpy.int32(98)
   if (_0=="purifyPrimalSuccess"): # bld/herlev/final/default/src/fusion/Parameters.mbi:591:6-32
    return numpy.int32(78)
   if (_0=="purifyDualSuccess"): # bld/herlev/final/default/src/fusion/Parameters.mbi:592:6-30
    return numpy.int32(77)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1internal_1liinf_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1internal_1liinf_1value_S(_0)
  @staticmethod
  def __string_1to_1internal_1liinf_1value_S(_0):
   if (_0=="intpntLenbarvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:473:6-28
    return numpy.int32(3)
   if (_0=="presolveStackSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:474:6-30
    return numpy.int32(4)
   if (_0=="intpntFactorNumNzBefore"): # bld/herlev/final/default/src/fusion/Parameters.mbi:475:6-36
    return numpy.int32(2)
   if (_0=="intpntFactorNumNzAfter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:476:6-35
    return numpy.int32(1)
   if (_0=="intpntFactorGpOrderSavedNzs"): # bld/herlev/final/default/src/fusion/Parameters.mbi:477:6-40
    return numpy.int32(0)
   if (_0=="simplexPrimalIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:478:6-30
    return numpy.int32(8)
   if (_0=="simplexDualIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:479:6-28
    return numpy.int32(5)
   if (_0=="simplexPrimalNumTicks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:480:6-34
    return numpy.int32(9)
   if (_0=="simplexDualNumTicks"): # bld/herlev/final/default/src/fusion/Parameters.mbi:481:6-32
    return numpy.int32(7)
   if (_0=="simplexDualNumIllposedCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:482:6-38
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1liinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1liinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1liinfitem_1value_S(_0):
   if (_0=="anaProScalarizedConstraintMatrixNumRows"): # bld/herlev/final/default/src/fusion/Parameters.mbi:448:6-52
    return numpy.int32(2)
   if (_0=="anaProScalarizedConstraintMatrixNumColumns"): # bld/herlev/final/default/src/fusion/Parameters.mbi:449:6-55
    return numpy.int32(0)
   if (_0=="anaProScalarizedConstraintMatrixNumNz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:450:6-50
    return numpy.int32(1)
   if (_0=="mioAnz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:451:6-19
    return numpy.int32(10)
   if (_0=="mioPresolvedAnz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:452:6-28
    return numpy.int32(14)
   if (_0=="mioSimplexIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:453:6-27
    return numpy.int32(15)
   if (_0=="mioIntpntIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:454:6-26
    return numpy.int32(11)
   if (_0=="mioNumPrimIllposedCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:455:6-34
    return numpy.int32(13)
   if (_0=="mioNumDualIllposedCer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:456:6-34
    return numpy.int32(12)
   if (_0=="biPrimalIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:457:6-25
    return numpy.int32(8)
   if (_0=="biDualIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:458:6-23
    return numpy.int32(7)
   if (_0=="biCleanPrimalIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:459:6-30
    return numpy.int32(6)
   if (_0=="biCleanDualIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:460:6-28
    return numpy.int32(4)
   if (_0=="biCleanPrimalDegIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:461:6-33
    return numpy.int32(5)
   if (_0=="biCleanDualDegIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:462:6-31
    return numpy.int32(3)
   if (_0=="intpntFactorNumNz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:463:6-30
    return numpy.int32(9)
   if (_0=="rdNumacc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:464:6-21
    return numpy.int32(16)
   if (_0=="rdNumdjc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:465:6-21
    return numpy.int32(18)
   if (_0=="rdNumanz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:466:6-21
    return numpy.int32(17)
   if (_0=="rdNumqnz"): # bld/herlev/final/default/src/fusion/Parameters.mbi:467:6-21
    return numpy.int32(19)
   if (_0=="simplexIter"): # bld/herlev/final/default/src/fusion/Parameters.mbi:468:6-24
    return numpy.int32(20)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dparam_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dparam_1value_S(_0)
  @staticmethod
  def __string_1to_1dparam_1value_S(_0):
   if (_0=="dataTolCjLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:383:6-27
    return numpy.int32(13)
   if (_0=="dataTolCHuge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:384:6-25
    return numpy.int32(12)
   if (_0=="dataTolAijLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:385:6-28
    return numpy.int32(9)
   if (_0=="dataTolAijHuge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:386:6-27
    return numpy.int32(8)
   if (_0=="dataSymMatTol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:387:6-26
    return numpy.int32(5)
   if (_0=="dataSymMatTolLarge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:388:6-31
    return numpy.int32(7)
   if (_0=="dataSymMatTolHuge"): # bld/herlev/final/default/src/fusion/Parameters.mbi:389:6-30
    return numpy.int32(6)
   if (_0=="dataTolBoundInf"): # bld/herlev/final/default/src/fusion/Parameters.mbi:390:6-28
    return numpy.int32(10)
   if (_0=="dataTolBoundWrn"): # bld/herlev/final/default/src/fusion/Parameters.mbi:391:6-28
    return numpy.int32(11)
   if (_0=="dataTolQij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:392:6-23
    return numpy.int32(14)
   if (_0=="dataTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:393:6-21
    return numpy.int32(15)
   if (_0=="semidefiniteTolApprox"): # bld/herlev/final/default/src/fusion/Parameters.mbi:394:6-34
    return numpy.int32(56)
   if (_0=="optimizerMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:395:6-29
    return numpy.int32(48)
   if (_0=="lowerObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:396:6-24
    return numpy.int32(38)
   if (_0=="upperObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:397:6-24
    return numpy.int32(59)
   if (_0=="upperObjCutFiniteTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:398:6-33
    return numpy.int32(60)
   if (_0=="lowerObjCutFiniteTrh"): # bld/herlev/final/default/src/fusion/Parameters.mbi:399:6-33
    return numpy.int32(39)
   if (_0=="intpntTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:400:6-28
    return numpy.int32(35)
   if (_0=="intpntTolStepSize"): # bld/herlev/final/default/src/fusion/Parameters.mbi:401:6-30
    return numpy.int32(37)
   if (_0=="simLuTolRelPiv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:402:6-27
    return numpy.int32(57)
   if (_0=="intpntTolRelStep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:403:6-29
    return numpy.int32(36)
   if (_0=="intpntTolPath"): # bld/herlev/final/default/src/fusion/Parameters.mbi:404:6-26
    return numpy.int32(32)
   if (_0=="intpntTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:405:6-27
    return numpy.int32(33)
   if (_0=="intpntTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:406:6-27
    return numpy.int32(28)
   if (_0=="intpntTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:407:6-27
    return numpy.int32(31)
   if (_0=="intpntTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:408:6-28
    return numpy.int32(30)
   if (_0=="intpntCoTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:409:6-30
    return numpy.int32(21)
   if (_0=="intpntCoTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:410:6-29
    return numpy.int32(20)
   if (_0=="intpntCoTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:411:6-29
    return numpy.int32(16)
   if (_0=="intpntCoTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:412:6-29
    return numpy.int32(18)
   if (_0=="intpntCoTolNearRel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:413:6-31
    return numpy.int32(19)
   if (_0=="intpntCoTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:414:6-30
    return numpy.int32(17)
   if (_0=="intpntQoTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:415:6-30
    return numpy.int32(27)
   if (_0=="intpntQoTolPfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:416:6-29
    return numpy.int32(26)
   if (_0=="intpntQoTolDfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:417:6-29
    return numpy.int32(22)
   if (_0=="intpntQoTolMuRed"): # bld/herlev/final/default/src/fusion/Parameters.mbi:418:6-29
    return numpy.int32(24)
   if (_0=="intpntQoTolNearRel"): # bld/herlev/final/default/src/fusion/Parameters.mbi:419:6-31
    return numpy.int32(25)
   if (_0=="intpntQoTolInfeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:420:6-30
    return numpy.int32(23)
   if (_0=="intpntTolPsafe"): # bld/herlev/final/default/src/fusion/Parameters.mbi:421:6-27
    return numpy.int32(34)
   if (_0=="intpntTolDsafe"): # bld/herlev/final/default/src/fusion/Parameters.mbi:422:6-27
    return numpy.int32(29)
   if (_0=="mioMaxTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:423:6-23
    return numpy.int32(41)
   if (_0=="mioRelGapConst"): # bld/herlev/final/default/src/fusion/Parameters.mbi:424:6-27
    return numpy.int32(42)
   if (_0=="mioTolRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:425:6-25
    return numpy.int32(47)
   if (_0=="mioTolAbsGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:426:6-25
    return numpy.int32(43)
   if (_0=="mioTolAbsRelaxInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:427:6-30
    return numpy.int32(44)
   if (_0=="mioDjcMaxBigm"): # bld/herlev/final/default/src/fusion/Parameters.mbi:428:6-26
    return numpy.int32(40)
   if (_0=="basisTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:429:6-22
    return numpy.int32(3)
   if (_0=="basisTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:430:6-22
    return numpy.int32(2)
   if (_0=="basisRelTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:431:6-25
    return numpy.int32(1)
   if (_0=="presolveTolX"): # bld/herlev/final/default/src/fusion/Parameters.mbi:432:6-25
    return numpy.int32(54)
   if (_0=="presolveTolPrimalInfeasPerturbation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:433:6-48
    return numpy.int32(51)
   if (_0=="presolveTolS"): # bld/herlev/final/default/src/fusion/Parameters.mbi:434:6-25
    return numpy.int32(53)
   if (_0=="presolveTolAij"): # bld/herlev/final/default/src/fusion/Parameters.mbi:435:6-27
    return numpy.int32(50)
   if (_0=="presolveTolAbsLindep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:436:6-33
    return numpy.int32(49)
   if (_0=="presolveTolRelLindep"): # bld/herlev/final/default/src/fusion/Parameters.mbi:437:6-33
    return numpy.int32(52)
   if (_0=="simplexAbsTolPiv"): # bld/herlev/final/default/src/fusion/Parameters.mbi:438:6-29
    return numpy.int32(58)
   if (_0=="mioTolFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:439:6-23
    return numpy.int32(45)
   if (_0=="anaSolInfeasTol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:440:6-28
    return numpy.int32(0)
   if (_0=="checkConvexityRelTol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:441:6-33
    return numpy.int32(4)
   if (_0=="qcqoReformulateRelDropTol"): # bld/herlev/final/default/src/fusion/Parameters.mbi:442:6-38
    return numpy.int32(55)
   if (_0=="mioTolRelDualBoundImprovement"): # bld/herlev/final/default/src/fusion/Parameters.mbi:443:6-42
    return numpy.int32(46)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1feature_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1feature_1value_S(_0)
  @staticmethod
  def __string_1to_1feature_1value_S(_0):
   if (_0=="pts"): # bld/herlev/final/default/src/fusion/Parameters.mbi:377:6-16
    return numpy.int32(0)
   if (_0=="pton"): # bld/herlev/final/default/src/fusion/Parameters.mbi:378:6-17
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dinfitem_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dinfitem_1value_S(_0)
  @staticmethod
  def __string_1to_1dinfitem_1value_S(_0):
   if (_0=="anaProScalarizedConstraintMatrixDensity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:272:6-52
    return numpy.int32(0)
   if (_0=="biTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:273:6-19
    return numpy.int32(6)
   if (_0=="biPrimalTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:274:6-25
    return numpy.int32(5)
   if (_0=="biDualTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:275:6-23
    return numpy.int32(4)
   if (_0=="biCleanTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:276:6-24
    return numpy.int32(3)
   if (_0=="biCleanPrimalTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:277:6-30
    return numpy.int32(2)
   if (_0=="biCleanDualTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:278:6-28
    return numpy.int32(1)
   if (_0=="intpntTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:279:6-23
    return numpy.int32(14)
   if (_0=="intpntOrderTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:280:6-28
    return numpy.int32(11)
   if (_0=="intpntPrimalObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:281:6-28
    return numpy.int32(13)
   if (_0=="intpntDualObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:282:6-26
    return numpy.int32(8)
   if (_0=="intpntPrimalFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:283:6-29
    return numpy.int32(12)
   if (_0=="intpntDualFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:284:6-27
    return numpy.int32(7)
   if (_0=="intpntOptStatus"): # bld/herlev/final/default/src/fusion/Parameters.mbi:285:6-28
    return numpy.int32(10)
   if (_0=="simTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:286:6-20
    return numpy.int32(51)
   if (_0=="simPrimalTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:287:6-26
    return numpy.int32(50)
   if (_0=="simDualTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:288:6-24
    return numpy.int32(47)
   if (_0=="simObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:289:6-19
    return numpy.int32(49)
   if (_0=="simFeas"): # bld/herlev/final/default/src/fusion/Parameters.mbi:290:6-20
    return numpy.int32(48)
   if (_0=="mioTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:291:6-20
    return numpy.int32(33)
   if (_0=="mioRootPresolveTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:292:6-32
    return numpy.int32(31)
   if (_0=="mioRootOptimizerTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:293:6-33
    return numpy.int32(30)
   if (_0=="mioRootTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:294:6-24
    return numpy.int32(32)
   if (_0=="toConicTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:295:6-24
    return numpy.int32(99)
   if (_0=="mioConstructSolutionObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:296:6-36
    return numpy.int32(17)
   if (_0=="mioInitialFeasibleSolutionObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:297:6-42
    return numpy.int32(21)
   if (_0=="mioObjInt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:298:6-22
    return numpy.int32(26)
   if (_0=="mioObjBound"): # bld/herlev/final/default/src/fusion/Parameters.mbi:299:6-24
    return numpy.int32(25)
   if (_0=="mioObjRelGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:300:6-25
    return numpy.int32(27)
   if (_0=="mioObjAbsGap"): # bld/herlev/final/default/src/fusion/Parameters.mbi:301:6-25
    return numpy.int32(24)
   if (_0=="mioUserObjCut"): # bld/herlev/final/default/src/fusion/Parameters.mbi:302:6-26
    return numpy.int32(34)
   if (_0=="mioCmirSeparationTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:303:6-34
    return numpy.int32(16)
   if (_0=="mioCliqueSeparationTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:304:6-36
    return numpy.int32(15)
   if (_0=="mioKnapsackCoverSeparationTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:305:6-43
    return numpy.int32(22)
   if (_0=="mioGmiSeparationTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:306:6-33
    return numpy.int32(19)
   if (_0=="mioImpliedBoundTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:307:6-32
    return numpy.int32(20)
   if (_0=="mioLiproSeparationTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:308:6-35
    return numpy.int32(23)
   if (_0=="mioRootCutgenTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:309:6-30
    return numpy.int32(29)
   if (_0=="mioProbingTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:310:6-27
    return numpy.int32(28)
   if (_0=="optimizerTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:311:6-26
    return numpy.int32(35)
   if (_0=="presolveTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:312:6-25
    return numpy.int32(38)
   if (_0=="mioDualBoundAfterPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:313:6-38
    return numpy.int32(18)
   if (_0=="presolveEliTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:314:6-28
    return numpy.int32(36)
   if (_0=="presolveLindepTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:315:6-31
    return numpy.int32(37)
   if (_0=="readDataTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:316:6-25
    return numpy.int32(45)
   if (_0=="writeDataTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:317:6-26
    return numpy.int32(100)
   if (_0=="solItrPrimalObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:318:6-28
    return numpy.int32(93)
   if (_0=="solItrPviolcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:319:6-27
    return numpy.int32(96)
   if (_0=="solItrPviolvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:320:6-27
    return numpy.int32(98)
   if (_0=="solItrPviolbarvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:321:6-30
    return numpy.int32(95)
   if (_0=="solItrPviolcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:322:6-29
    return numpy.int32(97)
   if (_0=="solItrPviolacc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:323:6-27
    return numpy.int32(94)
   if (_0=="solItrDualObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:324:6-26
    return numpy.int32(77)
   if (_0=="solItrDviolcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:325:6-27
    return numpy.int32(80)
   if (_0=="solItrDviolvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:326:6-27
    return numpy.int32(82)
   if (_0=="solItrDviolbarvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:327:6-30
    return numpy.int32(79)
   if (_0=="solItrDviolcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:328:6-29
    return numpy.int32(81)
   if (_0=="solItrDviolacc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:329:6-27
    return numpy.int32(78)
   if (_0=="solItrNrmXc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:330:6-24
    return numpy.int32(90)
   if (_0=="solItrNrmXx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:331:6-24
    return numpy.int32(91)
   if (_0=="solItrNrmBarx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:332:6-26
    return numpy.int32(84)
   if (_0=="solItrNrmY"): # bld/herlev/final/default/src/fusion/Parameters.mbi:333:6-23
    return numpy.int32(92)
   if (_0=="solItrNrmSlc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:334:6-25
    return numpy.int32(85)
   if (_0=="solItrNrmSuc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:335:6-25
    return numpy.int32(88)
   if (_0=="solItrNrmSlx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:336:6-25
    return numpy.int32(86)
   if (_0=="solItrNrmSux"): # bld/herlev/final/default/src/fusion/Parameters.mbi:337:6-25
    return numpy.int32(89)
   if (_0=="solItrNrmSnx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:338:6-25
    return numpy.int32(87)
   if (_0=="solItrNrmBars"): # bld/herlev/final/default/src/fusion/Parameters.mbi:339:6-26
    return numpy.int32(83)
   if (_0=="solBasPrimalObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:340:6-28
    return numpy.int32(63)
   if (_0=="solBasPviolcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:341:6-27
    return numpy.int32(64)
   if (_0=="solBasPviolvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:342:6-27
    return numpy.int32(65)
   if (_0=="solBasDualObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:343:6-26
    return numpy.int32(52)
   if (_0=="solBasDviolcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:344:6-27
    return numpy.int32(53)
   if (_0=="solBasDviolvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:345:6-27
    return numpy.int32(54)
   if (_0=="solBasNrmXc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:346:6-24
    return numpy.int32(60)
   if (_0=="solBasNrmXx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:347:6-24
    return numpy.int32(61)
   if (_0=="solBasNrmBarx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:348:6-26
    return numpy.int32(55)
   if (_0=="solBasNrmY"): # bld/herlev/final/default/src/fusion/Parameters.mbi:349:6-23
    return numpy.int32(62)
   if (_0=="solBasNrmSlc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:350:6-25
    return numpy.int32(56)
   if (_0=="solBasNrmSuc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:351:6-25
    return numpy.int32(58)
   if (_0=="solBasNrmSlx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:352:6-25
    return numpy.int32(57)
   if (_0=="solBasNrmSux"): # bld/herlev/final/default/src/fusion/Parameters.mbi:353:6-25
    return numpy.int32(59)
   if (_0=="solItgPrimalObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:354:6-28
    return numpy.int32(69)
   if (_0=="solItgPviolcon"): # bld/herlev/final/default/src/fusion/Parameters.mbi:355:6-27
    return numpy.int32(72)
   if (_0=="solItgPviolvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:356:6-27
    return numpy.int32(76)
   if (_0=="solItgPviolbarvar"): # bld/herlev/final/default/src/fusion/Parameters.mbi:357:6-30
    return numpy.int32(71)
   if (_0=="solItgPviolcones"): # bld/herlev/final/default/src/fusion/Parameters.mbi:358:6-29
    return numpy.int32(73)
   if (_0=="solItgPviolacc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:359:6-27
    return numpy.int32(70)
   if (_0=="solItgPviolitg"): # bld/herlev/final/default/src/fusion/Parameters.mbi:360:6-27
    return numpy.int32(75)
   if (_0=="solItgPvioldjc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:361:6-27
    return numpy.int32(74)
   if (_0=="solItgNrmXc"): # bld/herlev/final/default/src/fusion/Parameters.mbi:362:6-24
    return numpy.int32(67)
   if (_0=="solItgNrmXx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:363:6-24
    return numpy.int32(68)
   if (_0=="solItgNrmBarx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:364:6-26
    return numpy.int32(66)
   if (_0=="presolveTotalPrimalPerturbation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:365:6-44
    return numpy.int32(39)
   if (_0=="intpntFactorNumFlops"): # bld/herlev/final/default/src/fusion/Parameters.mbi:366:6-33
    return numpy.int32(9)
   if (_0=="qcqoReformulateTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:367:6-32
    return numpy.int32(42)
   if (_0=="qcqoReformulateMaxPerturbation"): # bld/herlev/final/default/src/fusion/Parameters.mbi:368:6-43
    return numpy.int32(41)
   if (_0=="qcqoReformulateWorstCholeskyDiagScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:369:6-52
    return numpy.int32(44)
   if (_0=="qcqoReformulateWorstCholeskyColumnScaling"): # bld/herlev/final/default/src/fusion/Parameters.mbi:370:6-54
    return numpy.int32(43)
   if (_0=="primalRepairPenaltyObj"): # bld/herlev/final/default/src/fusion/Parameters.mbi:371:6-35
    return numpy.int32(40)
   if (_0=="remoteTime"): # bld/herlev/final/default/src/fusion/Parameters.mbi:372:6-23
    return numpy.int32(46)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1solformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1solformat_1value_S(_0)
  @staticmethod
  def __string_1to_1solformat_1value_S(_0):
   if (_0=="extension"): # bld/herlev/final/default/src/fusion/Parameters.mbi:264:6-22
    return numpy.int32(0)
   if (_0=="b"): # bld/herlev/final/default/src/fusion/Parameters.mbi:265:6-14
    return numpy.int32(1)
   if (_0=="task"): # bld/herlev/final/default/src/fusion/Parameters.mbi:266:6-17
    return numpy.int32(2)
   if (_0=="jsonTask"): # bld/herlev/final/default/src/fusion/Parameters.mbi:267:6-21
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1dataformat_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1dataformat_1value_S(_0)
  @staticmethod
  def __string_1to_1dataformat_1value_S(_0):
   if (_0=="extension"): # bld/herlev/final/default/src/fusion/Parameters.mbi:251:6-22
    return numpy.int32(0)
   if (_0=="mps"): # bld/herlev/final/default/src/fusion/Parameters.mbi:252:6-16
    return numpy.int32(1)
   if (_0=="lp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:253:6-15
    return numpy.int32(2)
   if (_0=="op"): # bld/herlev/final/default/src/fusion/Parameters.mbi:254:6-15
    return numpy.int32(3)
   if (_0=="freeMps"): # bld/herlev/final/default/src/fusion/Parameters.mbi:255:6-20
    return numpy.int32(4)
   if (_0=="task"): # bld/herlev/final/default/src/fusion/Parameters.mbi:256:6-17
    return numpy.int32(5)
   if (_0=="ptf"): # bld/herlev/final/default/src/fusion/Parameters.mbi:257:6-16
    return numpy.int32(6)
   if (_0=="cb"): # bld/herlev/final/default/src/fusion/Parameters.mbi:258:6-15
    return numpy.int32(7)
   if (_0=="jsonTask"): # bld/herlev/final/default/src/fusion/Parameters.mbi:259:6-21
    return numpy.int32(8)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1symmattype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1symmattype_1value_S(_0)
  @staticmethod
  def __string_1to_1symmattype_1value_S(_0):
   if (_0=="sparse"): # bld/herlev/final/default/src/fusion/Parameters.mbi:246:6-19
    return numpy.int32(0)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1nametype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1nametype_1value_S(_0)
  @staticmethod
  def __string_1to_1nametype_1value_S(_0):
   if (_0=="gen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:239:6-16
    return numpy.int32(0)
   if (_0=="mps"): # bld/herlev/final/default/src/fusion/Parameters.mbi:240:6-16
    return numpy.int32(1)
   if (_0=="lp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:241:6-15
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1domaintype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1domaintype_1value_S(_0)
  @staticmethod
  def __string_1to_1domaintype_1value_S(_0):
   if (_0=="r"): # bld/herlev/final/default/src/fusion/Parameters.mbi:222:6-14
    return numpy.int32(0)
   if (_0=="rzero"): # bld/herlev/final/default/src/fusion/Parameters.mbi:223:6-18
    return numpy.int32(1)
   if (_0=="rplus"): # bld/herlev/final/default/src/fusion/Parameters.mbi:224:6-18
    return numpy.int32(2)
   if (_0=="rminus"): # bld/herlev/final/default/src/fusion/Parameters.mbi:225:6-19
    return numpy.int32(3)
   if (_0=="quadraticCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:226:6-26
    return numpy.int32(4)
   if (_0=="rquadraticCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:227:6-27
    return numpy.int32(5)
   if (_0=="primalExpCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:228:6-26
    return numpy.int32(6)
   if (_0=="dualExpCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:229:6-24
    return numpy.int32(7)
   if (_0=="primalPowerCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:230:6-28
    return numpy.int32(8)
   if (_0=="dualPowerCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:231:6-26
    return numpy.int32(9)
   if (_0=="primalGeoMeanCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:232:6-30
    return numpy.int32(10)
   if (_0=="dualGeoMeanCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:233:6-28
    return numpy.int32(11)
   if (_0=="svecPsdCone"): # bld/herlev/final/default/src/fusion/Parameters.mbi:234:6-24
    return numpy.int32(12)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1conetype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1conetype_1value_S(_0)
  @staticmethod
  def __string_1to_1conetype_1value_S(_0):
   if (_0=="quad"): # bld/herlev/final/default/src/fusion/Parameters.mbi:211:6-17
    return numpy.int32(0)
   if (_0=="rquad"): # bld/herlev/final/default/src/fusion/Parameters.mbi:212:6-18
    return numpy.int32(1)
   if (_0=="pexp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:213:6-17
    return numpy.int32(2)
   if (_0=="dexp"): # bld/herlev/final/default/src/fusion/Parameters.mbi:214:6-17
    return numpy.int32(3)
   if (_0=="ppow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:215:6-17
    return numpy.int32(4)
   if (_0=="dpow"): # bld/herlev/final/default/src/fusion/Parameters.mbi:216:6-17
    return numpy.int32(5)
   if (_0=="zero"): # bld/herlev/final/default/src/fusion/Parameters.mbi:217:6-17
    return numpy.int32(6)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1compresstype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1compresstype_1value_S(_0)
  @staticmethod
  def __string_1to_1compresstype_1value_S(_0):
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:203:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:204:6-17
    return numpy.int32(1)
   if (_0=="gzip"): # bld/herlev/final/default/src/fusion/Parameters.mbi:205:6-17
    return numpy.int32(2)
   if (_0=="zstd"): # bld/herlev/final/default/src/fusion/Parameters.mbi:206:6-17
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1checkconvexitytype_1value_S(_0)
  @staticmethod
  def __string_1to_1checkconvexitytype_1value_S(_0):
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:196:6-17
    return numpy.int32(0)
   if (_0=="simple"): # bld/herlev/final/default/src/fusion/Parameters.mbi:197:6-19
    return numpy.int32(1)
   if (_0=="full"): # bld/herlev/final/default/src/fusion/Parameters.mbi:198:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1callbackcode_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1callbackcode_1value_S(_0)
  @staticmethod
  def __string_1to_1callbackcode_1value_S(_0):
   if (_0=="beginRootCutgen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:99:6-28
    return numpy.int32(21)
   if (_0=="imRootCutgen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:100:6-25
    return numpy.int32(75)
   if (_0=="endRootCutgen"): # bld/herlev/final/default/src/fusion/Parameters.mbi:101:6-26
    return numpy.int32(50)
   if (_0=="beginSolveRootRelax"): # bld/herlev/final/default/src/fusion/Parameters.mbi:102:6-32
    return numpy.int32(24)
   if (_0=="endSolveRootRelax"): # bld/herlev/final/default/src/fusion/Parameters.mbi:103:6-30
    return numpy.int32(53)
   if (_0=="beginOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:104:6-27
    return numpy.int32(11)
   if (_0=="endOptimizer"): # bld/herlev/final/default/src/fusion/Parameters.mbi:105:6-25
    return numpy.int32(40)
   if (_0=="beginPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:106:6-26
    return numpy.int32(12)
   if (_0=="updatePresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:107:6-27
    return numpy.int32(87)
   if (_0=="imPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:108:6-23
    return numpy.int32(69)
   if (_0=="endPresolve"): # bld/herlev/final/default/src/fusion/Parameters.mbi:109:6-24
    return numpy.int32(41)
   if (_0=="beginIntpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:110:6-24
    return numpy.int32(8)
   if (_0=="intpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:111:6-19
    return numpy.int32(78)
   if (_0=="imIntpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:112:6-21
    return numpy.int32(61)
   if (_0=="endIntpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:113:6-22
    return numpy.int32(37)
   if (_0=="beginConic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:114:6-23
    return numpy.int32(1)
   if (_0=="conic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:115:6-18
    return numpy.int32(27)
   if (_0=="imConic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:116:6-20
    return numpy.int32(57)
   if (_0=="endConic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:117:6-21
    return numpy.int32(30)
   if (_0=="primalSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:118:6-26
    return numpy.int32(80)
   if (_0=="dualSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:119:6-24
    return numpy.int32(28)
   if (_0=="beginBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:120:6-20
    return numpy.int32(0)
   if (_0=="imBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:121:6-17
    return numpy.int32(56)
   if (_0=="endBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:122:6-18
    return numpy.int32(29)
   if (_0=="beginPrimalBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:123:6-26
    return numpy.int32(13)
   if (_0=="imPrimalBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:124:6-23
    return numpy.int32(70)
   if (_0=="updatePrimalBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:125:6-27
    return numpy.int32(88)
   if (_0=="endPrimalBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:126:6-24
    return numpy.int32(42)
   if (_0=="beginDualBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:127:6-24
    return numpy.int32(2)
   if (_0=="imDualBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:128:6-21
    return numpy.int32(58)
   if (_0=="updateDualBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:129:6-25
    return numpy.int32(84)
   if (_0=="endDualBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:130:6-22
    return numpy.int32(31)
   if (_0=="beginSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:131:6-27
    return numpy.int32(23)
   if (_0=="imSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:132:6-24
    return numpy.int32(77)
   if (_0=="beginPrimalSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:133:6-33
    return numpy.int32(18)
   if (_0=="updatePrimalSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:134:6-34
    return numpy.int32(90)
   if (_0=="endPrimalSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:135:6-31
    return numpy.int32(47)
   if (_0=="beginDualSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:136:6-31
    return numpy.int32(6)
   if (_0=="updateDualSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:137:6-32
    return numpy.int32(86)
   if (_0=="endDualSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:138:6-29
    return numpy.int32(35)
   if (_0=="endSimplexBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:139:6-25
    return numpy.int32(52)
   if (_0=="beginMio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:140:6-21
    return numpy.int32(10)
   if (_0=="imMio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:141:6-18
    return numpy.int32(64)
   if (_0=="newIntMio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:142:6-22
    return numpy.int32(79)
   if (_0=="endMio"): # bld/herlev/final/default/src/fusion/Parameters.mbi:143:6-19
    return numpy.int32(39)
   if (_0=="beginSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:144:6-25
    return numpy.int32(22)
   if (_0=="imSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:145:6-22
    return numpy.int32(76)
   if (_0=="updateSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:146:6-26
    return numpy.int32(91)
   if (_0=="beginDualSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:147:6-29
    return numpy.int32(5)
   if (_0=="imDualSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:148:6-26
    return numpy.int32(60)
   if (_0=="updateDualSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:149:6-30
    return numpy.int32(85)
   if (_0=="endDualSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:150:6-27
    return numpy.int32(34)
   if (_0=="beginPrimalSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:151:6-31
    return numpy.int32(17)
   if (_0=="imPrimalSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:152:6-28
    return numpy.int32(72)
   if (_0=="updatePrimalSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:153:6-32
    return numpy.int32(89)
   if (_0=="endPrimalSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:154:6-29
    return numpy.int32(46)
   if (_0=="endSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:155:6-23
    return numpy.int32(51)
   if (_0=="beginInfeasAna"): # bld/herlev/final/default/src/fusion/Parameters.mbi:156:6-27
    return numpy.int32(7)
   if (_0=="endInfeasAna"): # bld/herlev/final/default/src/fusion/Parameters.mbi:157:6-25
    return numpy.int32(36)
   if (_0=="imPrimalSensivity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:158:6-30
    return numpy.int32(71)
   if (_0=="imDualSensivity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:159:6-28
    return numpy.int32(59)
   if (_0=="imMioIntpnt"): # bld/herlev/final/default/src/fusion/Parameters.mbi:160:6-24
    return numpy.int32(66)
   if (_0=="imMioPrimalSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:161:6-31
    return numpy.int32(67)
   if (_0=="imMioDualSimplex"): # bld/herlev/final/default/src/fusion/Parameters.mbi:162:6-29
    return numpy.int32(65)
   if (_0=="beginPrimalSetupBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:163:6-31
    return numpy.int32(16)
   if (_0=="endPrimalSetupBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:164:6-29
    return numpy.int32(45)
   if (_0=="beginDualSetupBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:165:6-29
    return numpy.int32(4)
   if (_0=="endDualSetupBi"): # bld/herlev/final/default/src/fusion/Parameters.mbi:166:6-27
    return numpy.int32(33)
   if (_0=="beginPrimalSensitivity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:167:6-35
    return numpy.int32(15)
   if (_0=="endPrimalSensitivity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:168:6-33
    return numpy.int32(44)
   if (_0=="beginDualSensitivity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:169:6-33
    return numpy.int32(3)
   if (_0=="endDualSensitivity"): # bld/herlev/final/default/src/fusion/Parameters.mbi:170:6-31
    return numpy.int32(32)
   if (_0=="beginLicenseWait"): # bld/herlev/final/default/src/fusion/Parameters.mbi:171:6-29
    return numpy.int32(9)
   if (_0=="endLicenseWait"): # bld/herlev/final/default/src/fusion/Parameters.mbi:172:6-27
    return numpy.int32(38)
   if (_0=="imLicenseWait"): # bld/herlev/final/default/src/fusion/Parameters.mbi:173:6-26
    return numpy.int32(62)
   if (_0=="beginQcqoReformulate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:174:6-33
    return numpy.int32(19)
   if (_0=="endQcqoReformulate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:175:6-31
    return numpy.int32(48)
   if (_0=="imQoReformulate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:176:6-28
    return numpy.int32(73)
   if (_0=="beginToConic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:177:6-25
    return numpy.int32(25)
   if (_0=="endToConic"): # bld/herlev/final/default/src/fusion/Parameters.mbi:178:6-23
    return numpy.int32(54)
   if (_0=="beginPrimalRepair"): # bld/herlev/final/default/src/fusion/Parameters.mbi:179:6-30
    return numpy.int32(14)
   if (_0=="endPrimalRepair"): # bld/herlev/final/default/src/fusion/Parameters.mbi:180:6-28
    return numpy.int32(43)
   if (_0=="beginRead"): # bld/herlev/final/default/src/fusion/Parameters.mbi:181:6-22
    return numpy.int32(20)
   if (_0=="imRead"): # bld/herlev/final/default/src/fusion/Parameters.mbi:182:6-19
    return numpy.int32(74)
   if (_0=="endRead"): # bld/herlev/final/default/src/fusion/Parameters.mbi:183:6-20
    return numpy.int32(49)
   if (_0=="beginWrite"): # bld/herlev/final/default/src/fusion/Parameters.mbi:184:6-23
    return numpy.int32(26)
   if (_0=="endWrite"): # bld/herlev/final/default/src/fusion/Parameters.mbi:185:6-21
    return numpy.int32(55)
   if (_0=="readOpfSection"): # bld/herlev/final/default/src/fusion/Parameters.mbi:186:6-27
    return numpy.int32(82)
   if (_0=="imLu"): # bld/herlev/final/default/src/fusion/Parameters.mbi:187:6-17
    return numpy.int32(63)
   if (_0=="imOrder"): # bld/herlev/final/default/src/fusion/Parameters.mbi:188:6-20
    return numpy.int32(68)
   if (_0=="readOpf"): # bld/herlev/final/default/src/fusion/Parameters.mbi:189:6-20
    return numpy.int32(81)
   if (_0=="writeOpf"): # bld/herlev/final/default/src/fusion/Parameters.mbi:190:6-21
    return numpy.int32(92)
   if (_0=="solvingRemote"): # bld/herlev/final/default/src/fusion/Parameters.mbi:191:6-26
    return numpy.int32(83)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1purify_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1purify_1value_S(_0)
  @staticmethod
  def __string_1to_1purify_1value_S(_0):
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:90:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:91:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/herlev/final/default/src/fusion/Parameters.mbi:92:6-17
    return numpy.int32(2)
   if (_0=="primalDual"): # bld/herlev/final/default/src/fusion/Parameters.mbi:93:6-23
    return numpy.int32(3)
   if (_0=="auto"): # bld/herlev/final/default/src/fusion/Parameters.mbi:94:6-17
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1intpnthotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1intpnthotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1intpnthotstart_1value_S(_0):
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:82:6-17
    return numpy.int32(0)
   if (_0=="primal"): # bld/herlev/final/default/src/fusion/Parameters.mbi:83:6-19
    return numpy.int32(1)
   if (_0=="dual"): # bld/herlev/final/default/src/fusion/Parameters.mbi:84:6-17
    return numpy.int32(2)
   if (_0=="primalDual"): # bld/herlev/final/default/src/fusion/Parameters.mbi:85:6-23
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simhotstart_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simhotstart_1value_S(_0)
  @staticmethod
  def __string_1to_1simhotstart_1value_S(_0):
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:75:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:76:6-17
    return numpy.int32(1)
   if (_0=="statusKeys"): # bld/herlev/final/default/src/fusion/Parameters.mbi:77:6-23
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdupvec_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdupvec_1value_S(_0)
  @staticmethod
  def __string_1to_1simdupvec_1value_S(_0):
   if (_0=="on"): # bld/herlev/final/default/src/fusion/Parameters.mbi:68:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/herlev/final/default/src/fusion/Parameters.mbi:69:6-16
    return numpy.int32(0)
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:70:6-17
    return numpy.int32(2)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simreform_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simreform_1value_S(_0)
  @staticmethod
  def __string_1to_1simreform_1value_S(_0):
   if (_0=="on"): # bld/herlev/final/default/src/fusion/Parameters.mbi:60:6-15
    return numpy.int32(1)
   if (_0=="off"): # bld/herlev/final/default/src/fusion/Parameters.mbi:61:6-16
    return numpy.int32(0)
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:62:6-17
    return numpy.int32(2)
   if (_0=="aggressive"): # bld/herlev/final/default/src/fusion/Parameters.mbi:63:6-23
    return numpy.int32(3)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1uplo_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1uplo_1value_S(_0)
  @staticmethod
  def __string_1to_1uplo_1value_S(_0):
   if (_0=="lo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:54:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/herlev/final/default/src/fusion/Parameters.mbi:55:6-15
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1transpose_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1transpose_1value_S(_0)
  @staticmethod
  def __string_1to_1transpose_1value_S(_0):
   if (_0=="no"): # bld/herlev/final/default/src/fusion/Parameters.mbi:48:6-15
    return numpy.int32(0)
   if (_0=="yes"): # bld/herlev/final/default/src/fusion/Parameters.mbi:49:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1simdegen_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1simdegen_1value_S(_0)
  @staticmethod
  def __string_1to_1simdegen_1value_S(_0):
   if (_0=="none"): # bld/herlev/final/default/src/fusion/Parameters.mbi:39:6-17
    return numpy.int32(0)
   if (_0=="free"): # bld/herlev/final/default/src/fusion/Parameters.mbi:40:6-17
    return numpy.int32(1)
   if (_0=="aggressive"): # bld/herlev/final/default/src/fusion/Parameters.mbi:41:6-23
    return numpy.int32(2)
   if (_0=="moderate"): # bld/herlev/final/default/src/fusion/Parameters.mbi:42:6-21
    return numpy.int32(3)
   if (_0=="minimum"): # bld/herlev/final/default/src/fusion/Parameters.mbi:43:6-20
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1mark_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1mark_1value_S(_0)
  @staticmethod
  def __string_1to_1mark_1value_S(_0):
   if (_0=="lo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:33:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/herlev/final/default/src/fusion/Parameters.mbi:34:6-15
    return numpy.int32(1)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1boundkey_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1boundkey_1value_S(_0)
  @staticmethod
  def __string_1to_1boundkey_1value_S(_0):
   if (_0=="lo"): # bld/herlev/final/default/src/fusion/Parameters.mbi:24:6-15
    return numpy.int32(0)
   if (_0=="up"): # bld/herlev/final/default/src/fusion/Parameters.mbi:25:6-15
    return numpy.int32(1)
   if (_0=="fx"): # bld/herlev/final/default/src/fusion/Parameters.mbi:26:6-15
    return numpy.int32(2)
   if (_0=="fr"): # bld/herlev/final/default/src/fusion/Parameters.mbi:27:6-15
    return numpy.int32(3)
   if (_0=="ra"): # bld/herlev/final/default/src/fusion/Parameters.mbi:28:6-15
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1basindtype_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1basindtype_1value_S(_0)
  @staticmethod
  def __string_1to_1basindtype_1value_S(_0):
   if (_0=="never"): # bld/herlev/final/default/src/fusion/Parameters.mbi:15:6-18
    return numpy.int32(0)
   if (_0=="always"): # bld/herlev/final/default/src/fusion/Parameters.mbi:16:6-19
    return numpy.int32(1)
   if (_0=="noError"): # bld/herlev/final/default/src/fusion/Parameters.mbi:17:6-20
    return numpy.int32(2)
   if (_0=="ifFeasible"): # bld/herlev/final/default/src/fusion/Parameters.mbi:18:6-23
    return numpy.int32(3)
   if (_0=="reservered"): # bld/herlev/final/default/src/fusion/Parameters.mbi:19:6-23
    return numpy.int32(4)
   return numpy.int32((- 1))
  @staticmethod
  def __string_1to_1language_1value_alt_S(_t__0):
    return mosek_fusion_Parameters.__string_1to_1language_1value_S(_0)
  @staticmethod
  def __string_1to_1language_1value_S(_0):
   if (_0=="eng"): # bld/herlev/final/default/src/fusion/Parameters.mbi:9:6-16
    return numpy.int32(0)
   if (_0=="dan"): # bld/herlev/final/default/src/fusion/Parameters.mbi:10:6-16
    return numpy.int32(1)
   return numpy.int32((- 1))
 return Parameters
mosek_fusion_Parameters=__mk_mosek_fusion_Parameters()
del __mk_mosek_fusion_Parameters
def __mk_mosek_fusion_Utils_StringIntMap():
  class StringIntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_S(self,key): return key in self.__d
    def _getItem_S(self,key): return self.__d[key]
    def _setItem_SI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  return StringIntMap
mosek_fusion_Utils_StringIntMap=__mk_mosek_fusion_Utils_StringIntMap()
def __mk_mosek_fusion_Utils_IntMap():
  class IntMap:
    def __init__ (self):
      self.__d = {}
    def _hasItem_J(self,key): return key in self.__d
    def _getItem_J(self,key): return self.__d[key]
    def _setItem_JI(self,key,val): self.__d[key] = val
    def _keys_(self): return numpy.array(list(self.__d.keys()))
    def _values_(self): return numpy.array(list(self.__d.values()))
    def _clone_(self):
      r = self.__class__()
      r.__d.update(self.__d)
      return r
  
  
  
  return IntMap
mosek_fusion_Utils_IntMap=__mk_mosek_fusion_Utils_IntMap()
def __mk_mosek_fusion_Utils_StringBuffer():
  class StringBuffer:
    def __init__(self):
      self.__buf = []
    def __a(self,v):
      self.__buf.append(str(v))
      return self
    def __a_array(self,v):
      if v is None: self.__buf.append("None")
      else: self.__buf.append(str(v))
      return self
  
    _a_Z   = __a
    _a_I   = __a
    _a_J   = __a
    _a_U   = __a
    _a_D   = __a
    _a_S   = __a
    _a_B   = __a
    _a__3I = __a_array
    def _a__3J(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%i' % i for i in v]),']'])
      else:             self.__buf.append('None')
      return self
    def _a__3D(self,v):
      if v is not None: self.__buf.extend([ '[',','.join(['%g' % i for i in v]),']'])
      else:             self.__buf.append('None')
      return self
    _a__3S = __a_array
    def _lf_(self):
      self.__buf.append('\n')
      return self
    def _clear_ (self):
      self.__buf = []
      return self
    def _toString_(self):
      return ''.join(self.__buf)
    def _toString_(self):
      return ''.join(self.__buf)
    def _consolePrint_(self):
      print(self._toString_())
      self._clear_()
      return(self)
  return StringBuffer
mosek_fusion_Utils_StringBuffer=__mk_mosek_fusion_Utils_StringBuffer()
def __mk_mosek_fusion_Utils_Tools():
  
  import random,ctypes,math
  class Tools:
    @staticmethod
    def __arraycopy(src,srcoffset,tgt,tgtoffset,size):
      if len(tgt) < tgtoffset+size or len(src) < srcoffset+size:
        raise IndexError("Copy slice out of range")
      tgt[tgtoffset:tgtoffset+size] = src[srcoffset:srcoffset+size]
  
    _arraycopy__3II_3III =  __arraycopy
    _arraycopy__3JI_3JII = __arraycopy
    _arraycopy__3_3II_3_3III = __arraycopy
    _arraycopy__3_3DI_3_3DII = __arraycopy
    _arraycopy__3DI_3DII = __arraycopy
    _arraycopy__3IJ_3IJJ = __arraycopy
    _arraycopy__3JJ_3JJJ = __arraycopy
    _arraycopy__3DJ_3DJJ = __arraycopy
  
    @staticmethod
    def __arrayclone(a): 
      if isinstance(a,numpy.ndarray):
        return a.copy()
      else:      
        return numpy.array(a)
  
    _arraycopy__3D = __arrayclone
    _arraycopy__3I = __arrayclone
    _arraycopy__3J = __arrayclone
    _arraycopy__3S = __arrayclone
  
    @staticmethod
    def __arraylength(a): return len(a)
  
    _arraylength__3Lmosek_4fusion_4Variable_2   = __arraylength
    _arraylength__3Lmosek_4fusion_4Constranit_2 = __arraylength  
    _arraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength  
    _arraylength__3S   = __arraylength  
    _arraylength__3I   = __arraylength  
    _arraylength__3J   = __arraylength  
    _arraylength__3D   = __arraylength  
    _arraylength__3_3D = __arraylength  
    _arraylength__3_3I = __arraylength  
    _uarraylength__3I  = __arraylength 
    _uarraylength__3J  = __arraylength 
    _uarraylength__3D  = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Variable_2   = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Constraint_2 = __arraylength 
    _uarraylength__3Lmosek_4fusion_4Matrix_2     = __arraylength 
    _uarraylength__3_3S = __arraylength 
    _uarraylength__3_3D = __arraylength 
    _uarraylength__3_3I = __arraylength 
  
    @staticmethod
    def __matrixheight(m): return m.shape[0]
    @staticmethod
    def __matrixwidth(m): return m.shape[1]
    
    _matrixheight__3_3D = __matrixheight
    _matrixwidth__3_3D  = __matrixwidth
    _matrixheight__3_3Lmosek_4fusion_4Matrix_2 = __matrixheight
    _matrixwidth__3_3Lmosek_4fusion_4Matrix_2  = __matrixwidth
   
    @staticmethod   
    def _range_J (last): return numpy.arange(last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJ(first,last): return numpy.arange(first,last,dtype=numpy.int64)
    @staticmethod   
    def _range_JJJ(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int64)
  
    @staticmethod   
    def _range_I (last): return numpy.arange(last,dtype=numpy.int32)
    @staticmethod   
    def _range_II(first,last): return numpy.arange(first,last,dtype=numpy.int32)
    @staticmethod   
    def _range_III(first,last,step): return numpy.arange(first,last,step,dtype=numpy.int32)
  
    @staticmethod   
    def _zeros_I (num): return  numpy.zeros((num,),dtype=numpy.float64)
    @staticmethod   
    def _zeros_II (dimi,dimj): return  numpy.zeros((dimi,dimj),dtype=numpy.float64)
    @staticmethod   
    def _ones_I(num):  return  numpy.ones((num,),numpy.float64)
    
    __rand = random.Random()
    @staticmethod   
    def _randInt_I(max):
      return Tools.__rand.randint(0,max-1)
      
    @staticmethod   
    def _argsort__3J_3I_3JII(perm,val1,val2,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val1[lhs],val1[rhs]) or cmp(val2[lhs],val2[rhs]))
        perm[first:last] = p
  
    @staticmethod   
    def _argsort__3J_3I_3I(perm,val1,val2):    
      Tools._argsort__3I_3I_3III(perm,val1,val2,0,len(perm))
    
    @staticmethod   
    def _argsort__3J_3I(perm,vals):
      Tools._argsort__3I_3III(perm,vals,0,len(perm))
  
    @staticmethod   
    def _argsort__3J_3III(perm,val,first,last):
      if last-first > 1:
        p = list(perm[first:last])
        p.sort(lambda lhs,rhs: cmp(val[lhs],val[rhs]))
        perm[first:last] = p
  
    @staticmethod
    def _sort__3I_II (vals,first,last):
      if last-first > 1:
        tmp = vals[first:last]
        tmp.sort()
        vals[first:last] = tmp
  
    @staticmethod   
    def _makevector_DI(val,num): 
      r = numpy.zeros((num,), numpy.float64)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_II(val,num): 
      r = numpy.zeros((num,), numpy.int32)
      r[:] = val
      return r
    @staticmethod   
    def _makevector_JI(val,num): 
      r = numpy.zeros((num,), numpy.int64)
      r[:] = val
      return r
    @staticmethod   
    def _repeatrange_III(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int32)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod   
    def _repeatrange_JJJ(first,last,num):
      res = numpy.zeros(((last-first)*num,),numpy.int64)
      ra = numpy.arange(first,last)
      l = last-first
      for i in range(num):
        res[i*l:(i+1)*l] = ra
      return res
    @staticmethod
    def  _stringvalue_I(v): return str(v)
    @staticmethod
    def  _stringvalue_J(v): return str(v)
  
    @staticmethod
    def _toDouble_S(v):    
      return float(v)
  
    @staticmethod
    def _sqrt_D(v):
      return math.sqrt(v)
    
    @staticmethod
    def _toInt_S(v):
      return int(v)
  
  
    @staticmethod 
    def _argsort2(perm,v,first,last):
      l = sorted(perm[first:last],key=lambda i: v[i])
      perm[first:last] = l
    
    @staticmethod 
    def _argsort2x(perm,v0,v1,first,last):
      l = sorted(perm[first:last],key=lambda i: (v0[i],v1[i]))
      perm[first:last] = l
  
  
  
    @staticmethod 
    def _argsort__3J_3IJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
    
    @staticmethod 
    def _argsort__3J_3JJJ(perm,v,first,last):
      return Tools._argsort2(perm,v,first,last)
  
    @staticmethod 
    def _argsort__3J_3I_3IJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
    
    @staticmethod 
    def _argsort__3J_3J_3JJJ(perm,v0,v1,first,last):
      return Tools._argsort2x(perm,v0,v1,first,last)
  
    @staticmethod
    def _bucketsort__3JJJ_3III(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        if perm_ct.strides[0] == 8:
          #print( perm_ct.strides[:], perm_ct.shape[:],perm_ct.get_data())
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
        if v_ct.strides[0] == 4:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int32)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_int))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3III_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
        del arg_perm,arg_v
  
        if copy_v: 
          v[:] = tmpv
          del tmpv
        if copy_perm: 
          perm[first:last] = tmpperm
          del tmpperm
  
      
    @staticmethod
    def _bucketsort__3JJJ_3JJJ(perm,first,last,v,minval,maxval):
      if True:
        count = numpy.zeros((maxval-minval+2,),numpy.int64)
        for i in range(first,last): count[v[perm[i]]-minval+1] += 1
        ptrb = count.cumsum()
        rperm = numpy.zeros((last-first,),numpy.int64)
        for i in range(first,last):
          rperm[ptrb[v[perm[i]]-minval]] = perm[i]
          ptrb[v[perm[i]]-minval] += 1
        perm[first:last] = rperm
        #print( rperm,v)
  
      else:
        perm_ct = perm.ctypes
        v_ct    = v.ctypes
        
       
        if perm_ct.strides[0] == 8:
          arg_perm  = perm_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = False
        else:
          tmpperm = numpy.array(perm_ct[first:last],numpy.int64)
          arg_perm  = tmpperm.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_perm = True
  
  
        if v_ct.strides[0] == 8:
          arg_v = v_ct.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = False
        else:
          tmpv = numpy.array(v_ct,numpy.int64)
          arg_v  = tmpv.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong))
          copy_v = True
  
        n = last-first
        m = maxval - minval + 1
        workspace = (ctypes.c_longlong*(m+n))()
  
        mosek.__library__.MSK_bucketsort__3JS_3JJJ_3V(arg_perm,first,last,arg_v,minval,maxval,workspace)
  
        if copy_v: v[:] = tmpv
        if copy_perm: perm[first:last] = tmpperm
  
  
  
  
  return Tools
mosek_fusion_Utils_Tools=__mk_mosek_fusion_Utils_Tools()
def __mk_mosek_fusion_SolverInfo():
  from bisect import bisect_left
  import mosek
  class SolverInfo:
    dinfnames  = [ "anaProScalarizedConstraintMatrixDensity","biCleanDualTime","biCleanPrimalTime","biCleanTime","biDualTime","biPrimalTime","biTime","intpntDualFeas","intpntDualObj","intpntFactorNumFlops","intpntOptStatus","intpntOrderTime","intpntPrimalFeas","intpntPrimalObj","intpntTime","mioCliqueSeparationTime","mioCmirSeparationTime","mioConstructSolutionObj","mioDualBoundAfterPresolve","mioGmiSeparationTime","mioImpliedBoundTime","mioInitialFeasibleSolutionObj","mioKnapsackCoverSeparationTime","mioLiproSeparationTime","mioObjAbsGap","mioObjBound","mioObjInt","mioObjRelGap","mioProbingTime","mioRootCutgenTime","mioRootOptimizerTime","mioRootPresolveTime","mioRootTime","mioTime","mioUserObjCut","optimizerTime","presolveEliTime","presolveLindepTime","presolveTime","presolveTotalPrimalPerturbation","primalRepairPenaltyObj","qcqoReformulateMaxPerturbation","qcqoReformulateTime","qcqoReformulateWorstCholeskyColumnScaling","qcqoReformulateWorstCholeskyDiagScaling","readDataTime","remoteTime","simDualTime","simFeas","simObj","simPrimalTime","simTime","solBasDualObj","solBasDviolcon","solBasDviolvar","solBasNrmBarx","solBasNrmSlc","solBasNrmSlx","solBasNrmSuc","solBasNrmSux","solBasNrmXc","solBasNrmXx","solBasNrmY","solBasPrimalObj","solBasPviolcon","solBasPviolvar","solItgNrmBarx","solItgNrmXc","solItgNrmXx","solItgPrimalObj","solItgPviolacc","solItgPviolbarvar","solItgPviolcon","solItgPviolcones","solItgPvioldjc","solItgPviolitg","solItgPviolvar","solItrDualObj","solItrDviolacc","solItrDviolbarvar","solItrDviolcon","solItrDviolcones","solItrDviolvar","solItrNrmBars","solItrNrmBarx","solItrNrmSlc","solItrNrmSlx","solItrNrmSnx","solItrNrmSuc","solItrNrmSux","solItrNrmXc","solItrNrmXx","solItrNrmY","solItrPrimalObj","solItrPviolacc","solItrPviolbarvar","solItrPviolcon","solItrPviolcones","solItrPviolvar","toConicTime","writeDataTime" ];
    iinfnames  = [ "anaProNumCon","anaProNumConEq","anaProNumConFr","anaProNumConLo","anaProNumConRa","anaProNumConUp","anaProNumVar","anaProNumVarBin","anaProNumVarCont","anaProNumVarEq","anaProNumVarFr","anaProNumVarInt","anaProNumVarLo","anaProNumVarRa","anaProNumVarUp","intpntFactorDimDense","intpntIter","intpntNumThreads","intpntSolveDual","mioAbsgapSatisfied","mioCliqueTableSize","mioConstructSolution","mioInitialFeasibleSolution","mioNodeDepth","mioNumActiveNodes","mioNumBranch","mioNumCliqueCuts","mioNumCmirCuts","mioNumGomoryCuts","mioNumImpliedBoundCuts","mioNumIntSolutions","mioNumKnapsackCoverCuts","mioNumLiproCuts","mioNumRelax","mioNumRepeatedPresolve","mioNumbin","mioNumbinconevar","mioNumcon","mioNumcone","mioNumconevar","mioNumcont","mioNumcontconevar","mioNumdexpcones","mioNumdjc","mioNumdpowcones","mioNumint","mioNumintconevar","mioNumpexpcones","mioNumppowcones","mioNumqcones","mioNumrqcones","mioNumvar","mioObjBoundDefined","mioPresolvedNumbin","mioPresolvedNumbinconevar","mioPresolvedNumcon","mioPresolvedNumcone","mioPresolvedNumconevar","mioPresolvedNumcont","mioPresolvedNumcontconevar","mioPresolvedNumdexpcones","mioPresolvedNumdjc","mioPresolvedNumdpowcones","mioPresolvedNumint","mioPresolvedNumintconevar","mioPresolvedNumpexpcones","mioPresolvedNumppowcones","mioPresolvedNumqcones","mioPresolvedNumrqcones","mioPresolvedNumvar","mioRelgapSatisfied","mioTotalNumCuts","mioUserObjCut","optNumcon","optNumvar","optimizeResponse","presolveNumPrimalPerturbations","purifyDualSuccess","purifyPrimalSuccess","rdNumbarvar","rdNumcon","rdNumcone","rdNumintvar","rdNumq","rdNumvar","rdProtype","simDualDegIter","simDualHotstart","simDualHotstartLu","simDualInfIter","simDualIter","simNumcon","simNumvar","simPrimalDegIter","simPrimalHotstart","simPrimalHotstartLu","simPrimalInfIter","simPrimalIter","simSolveDual","solBasProsta","solBasSolsta","solItgProsta","solItgSolsta","solItrProsta","solItrSolsta","stoNumARealloc" ];
    liinfnames = [ "anaProScalarizedConstraintMatrixNumColumns","anaProScalarizedConstraintMatrixNumNz","anaProScalarizedConstraintMatrixNumRows","biCleanDualDegIter","biCleanDualIter","biCleanPrimalDegIter","biCleanPrimalIter","biDualIter","biPrimalIter","intpntFactorNumNz","mioAnz","mioIntpntIter","mioNumDualIllposedCer","mioNumPrimIllposedCer","mioPresolvedAnz","mioSimplexIter","rdNumacc","rdNumanz","rdNumdjc","rdNumqnz","simplexIter" ];
    dinfsyms   = [ mosek.dinfitem.ana_pro_scalarized_constraint_matrix_density,mosek.dinfitem.bi_clean_dual_time,mosek.dinfitem.bi_clean_primal_time,mosek.dinfitem.bi_clean_time,mosek.dinfitem.bi_dual_time,mosek.dinfitem.bi_primal_time,mosek.dinfitem.bi_time,mosek.dinfitem.intpnt_dual_feas,mosek.dinfitem.intpnt_dual_obj,mosek.dinfitem.intpnt_factor_num_flops,mosek.dinfitem.intpnt_opt_status,mosek.dinfitem.intpnt_order_time,mosek.dinfitem.intpnt_primal_feas,mosek.dinfitem.intpnt_primal_obj,mosek.dinfitem.intpnt_time,mosek.dinfitem.mio_clique_separation_time,mosek.dinfitem.mio_cmir_separation_time,mosek.dinfitem.mio_construct_solution_obj,mosek.dinfitem.mio_dual_bound_after_presolve,mosek.dinfitem.mio_gmi_separation_time,mosek.dinfitem.mio_implied_bound_time,mosek.dinfitem.mio_initial_feasible_solution_obj,mosek.dinfitem.mio_knapsack_cover_separation_time,mosek.dinfitem.mio_lipro_separation_time,mosek.dinfitem.mio_obj_abs_gap,mosek.dinfitem.mio_obj_bound,mosek.dinfitem.mio_obj_int,mosek.dinfitem.mio_obj_rel_gap,mosek.dinfitem.mio_probing_time,mosek.dinfitem.mio_root_cutgen_time,mosek.dinfitem.mio_root_optimizer_time,mosek.dinfitem.mio_root_presolve_time,mosek.dinfitem.mio_root_time,mosek.dinfitem.mio_time,mosek.dinfitem.mio_user_obj_cut,mosek.dinfitem.optimizer_time,mosek.dinfitem.presolve_eli_time,mosek.dinfitem.presolve_lindep_time,mosek.dinfitem.presolve_time,mosek.dinfitem.presolve_total_primal_perturbation,mosek.dinfitem.primal_repair_penalty_obj,mosek.dinfitem.qcqo_reformulate_max_perturbation,mosek.dinfitem.qcqo_reformulate_time,mosek.dinfitem.qcqo_reformulate_worst_cholesky_column_scaling,mosek.dinfitem.qcqo_reformulate_worst_cholesky_diag_scaling,mosek.dinfitem.read_data_time,mosek.dinfitem.remote_time,mosek.dinfitem.sim_dual_time,mosek.dinfitem.sim_feas,mosek.dinfitem.sim_obj,mosek.dinfitem.sim_primal_time,mosek.dinfitem.sim_time,mosek.dinfitem.sol_bas_dual_obj,mosek.dinfitem.sol_bas_dviolcon,mosek.dinfitem.sol_bas_dviolvar,mosek.dinfitem.sol_bas_nrm_barx,mosek.dinfitem.sol_bas_nrm_slc,mosek.dinfitem.sol_bas_nrm_slx,mosek.dinfitem.sol_bas_nrm_suc,mosek.dinfitem.sol_bas_nrm_sux,mosek.dinfitem.sol_bas_nrm_xc,mosek.dinfitem.sol_bas_nrm_xx,mosek.dinfitem.sol_bas_nrm_y,mosek.dinfitem.sol_bas_primal_obj,mosek.dinfitem.sol_bas_pviolcon,mosek.dinfitem.sol_bas_pviolvar,mosek.dinfitem.sol_itg_nrm_barx,mosek.dinfitem.sol_itg_nrm_xc,mosek.dinfitem.sol_itg_nrm_xx,mosek.dinfitem.sol_itg_primal_obj,mosek.dinfitem.sol_itg_pviolacc,mosek.dinfitem.sol_itg_pviolbarvar,mosek.dinfitem.sol_itg_pviolcon,mosek.dinfitem.sol_itg_pviolcones,mosek.dinfitem.sol_itg_pvioldjc,mosek.dinfitem.sol_itg_pviolitg,mosek.dinfitem.sol_itg_pviolvar,mosek.dinfitem.sol_itr_dual_obj,mosek.dinfitem.sol_itr_dviolacc,mosek.dinfitem.sol_itr_dviolbarvar,mosek.dinfitem.sol_itr_dviolcon,mosek.dinfitem.sol_itr_dviolcones,mosek.dinfitem.sol_itr_dviolvar,mosek.dinfitem.sol_itr_nrm_bars,mosek.dinfitem.sol_itr_nrm_barx,mosek.dinfitem.sol_itr_nrm_slc,mosek.dinfitem.sol_itr_nrm_slx,mosek.dinfitem.sol_itr_nrm_snx,mosek.dinfitem.sol_itr_nrm_suc,mosek.dinfitem.sol_itr_nrm_sux,mosek.dinfitem.sol_itr_nrm_xc,mosek.dinfitem.sol_itr_nrm_xx,mosek.dinfitem.sol_itr_nrm_y,mosek.dinfitem.sol_itr_primal_obj,mosek.dinfitem.sol_itr_pviolacc,mosek.dinfitem.sol_itr_pviolbarvar,mosek.dinfitem.sol_itr_pviolcon,mosek.dinfitem.sol_itr_pviolcones,mosek.dinfitem.sol_itr_pviolvar,mosek.dinfitem.to_conic_time,mosek.dinfitem.write_data_time ];
    iinfsyms   = [ mosek.iinfitem.ana_pro_num_con,mosek.iinfitem.ana_pro_num_con_eq,mosek.iinfitem.ana_pro_num_con_fr,mosek.iinfitem.ana_pro_num_con_lo,mosek.iinfitem.ana_pro_num_con_ra,mosek.iinfitem.ana_pro_num_con_up,mosek.iinfitem.ana_pro_num_var,mosek.iinfitem.ana_pro_num_var_bin,mosek.iinfitem.ana_pro_num_var_cont,mosek.iinfitem.ana_pro_num_var_eq,mosek.iinfitem.ana_pro_num_var_fr,mosek.iinfitem.ana_pro_num_var_int,mosek.iinfitem.ana_pro_num_var_lo,mosek.iinfitem.ana_pro_num_var_ra,mosek.iinfitem.ana_pro_num_var_up,mosek.iinfitem.intpnt_factor_dim_dense,mosek.iinfitem.intpnt_iter,mosek.iinfitem.intpnt_num_threads,mosek.iinfitem.intpnt_solve_dual,mosek.iinfitem.mio_absgap_satisfied,mosek.iinfitem.mio_clique_table_size,mosek.iinfitem.mio_construct_solution,mosek.iinfitem.mio_initial_feasible_solution,mosek.iinfitem.mio_node_depth,mosek.iinfitem.mio_num_active_nodes,mosek.iinfitem.mio_num_branch,mosek.iinfitem.mio_num_clique_cuts,mosek.iinfitem.mio_num_cmir_cuts,mosek.iinfitem.mio_num_gomory_cuts,mosek.iinfitem.mio_num_implied_bound_cuts,mosek.iinfitem.mio_num_int_solutions,mosek.iinfitem.mio_num_knapsack_cover_cuts,mosek.iinfitem.mio_num_lipro_cuts,mosek.iinfitem.mio_num_relax,mosek.iinfitem.mio_num_repeated_presolve,mosek.iinfitem.mio_numbin,mosek.iinfitem.mio_numbinconevar,mosek.iinfitem.mio_numcon,mosek.iinfitem.mio_numcone,mosek.iinfitem.mio_numconevar,mosek.iinfitem.mio_numcont,mosek.iinfitem.mio_numcontconevar,mosek.iinfitem.mio_numdexpcones,mosek.iinfitem.mio_numdjc,mosek.iinfitem.mio_numdpowcones,mosek.iinfitem.mio_numint,mosek.iinfitem.mio_numintconevar,mosek.iinfitem.mio_numpexpcones,mosek.iinfitem.mio_numppowcones,mosek.iinfitem.mio_numqcones,mosek.iinfitem.mio_numrqcones,mosek.iinfitem.mio_numvar,mosek.iinfitem.mio_obj_bound_defined,mosek.iinfitem.mio_presolved_numbin,mosek.iinfitem.mio_presolved_numbinconevar,mosek.iinfitem.mio_presolved_numcon,mosek.iinfitem.mio_presolved_numcone,mosek.iinfitem.mio_presolved_numconevar,mosek.iinfitem.mio_presolved_numcont,mosek.iinfitem.mio_presolved_numcontconevar,mosek.iinfitem.mio_presolved_numdexpcones,mosek.iinfitem.mio_presolved_numdjc,mosek.iinfitem.mio_presolved_numdpowcones,mosek.iinfitem.mio_presolved_numint,mosek.iinfitem.mio_presolved_numintconevar,mosek.iinfitem.mio_presolved_numpexpcones,mosek.iinfitem.mio_presolved_numppowcones,mosek.iinfitem.mio_presolved_numqcones,mosek.iinfitem.mio_presolved_numrqcones,mosek.iinfitem.mio_presolved_numvar,mosek.iinfitem.mio_relgap_satisfied,mosek.iinfitem.mio_total_num_cuts,mosek.iinfitem.mio_user_obj_cut,mosek.iinfitem.opt_numcon,mosek.iinfitem.opt_numvar,mosek.iinfitem.optimize_response,mosek.iinfitem.presolve_num_primal_perturbations,mosek.iinfitem.purify_dual_success,mosek.iinfitem.purify_primal_success,mosek.iinfitem.rd_numbarvar,mosek.iinfitem.rd_numcon,mosek.iinfitem.rd_numcone,mosek.iinfitem.rd_numintvar,mosek.iinfitem.rd_numq,mosek.iinfitem.rd_numvar,mosek.iinfitem.rd_protype,mosek.iinfitem.sim_dual_deg_iter,mosek.iinfitem.sim_dual_hotstart,mosek.iinfitem.sim_dual_hotstart_lu,mosek.iinfitem.sim_dual_inf_iter,mosek.iinfitem.sim_dual_iter,mosek.iinfitem.sim_numcon,mosek.iinfitem.sim_numvar,mosek.iinfitem.sim_primal_deg_iter,mosek.iinfitem.sim_primal_hotstart,mosek.iinfitem.sim_primal_hotstart_lu,mosek.iinfitem.sim_primal_inf_iter,mosek.iinfitem.sim_primal_iter,mosek.iinfitem.sim_solve_dual,mosek.iinfitem.sol_bas_prosta,mosek.iinfitem.sol_bas_solsta,mosek.iinfitem.sol_itg_prosta,mosek.iinfitem.sol_itg_solsta,mosek.iinfitem.sol_itr_prosta,mosek.iinfitem.sol_itr_solsta,mosek.iinfitem.sto_num_a_realloc ];
    liinfsyms  = [ mosek.liinfitem.ana_pro_scalarized_constraint_matrix_num_columns,mosek.liinfitem.ana_pro_scalarized_constraint_matrix_num_nz,mosek.liinfitem.ana_pro_scalarized_constraint_matrix_num_rows,mosek.liinfitem.bi_clean_dual_deg_iter,mosek.liinfitem.bi_clean_dual_iter,mosek.liinfitem.bi_clean_primal_deg_iter,mosek.liinfitem.bi_clean_primal_iter,mosek.liinfitem.bi_dual_iter,mosek.liinfitem.bi_primal_iter,mosek.liinfitem.intpnt_factor_num_nz,mosek.liinfitem.mio_anz,mosek.liinfitem.mio_intpnt_iter,mosek.liinfitem.mio_num_dual_illposed_cer,mosek.liinfitem.mio_num_prim_illposed_cer,mosek.liinfitem.mio_presolved_anz,mosek.liinfitem.mio_simplex_iter,mosek.liinfitem.rd_numacc,mosek.liinfitem.rd_numanz,mosek.liinfitem.rd_numdjc,mosek.liinfitem.rd_numqnz,mosek.liinfitem.simplex_iter ];
    @staticmethod
    def _getdouinf(infname):
      idx = bisect_left(SolverInfo.dinfnames, infname)
      if idx != len(SolverInfo.dinfnames) and SolverInfo.dinfnames[idx] == infname:
        return SolverInfo.dinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getintinf(infname):
      idx = bisect_left(SolverInfo.iinfnames, infname)
      if idx != len(SolverInfo.iinfnames) and SolverInfo.iinfnames[idx] == infname:
        return SolverInfo.iinfsyms[idx]
      else:
        return None
    @staticmethod
    def _getlintinf(infname):
      idx = bisect_left(SolverInfo.liinfnames, infname)
      if idx != len(SolverInfo.liinfnames) and SolverInfo.liinfnames[idx] == infname:
        return SolverInfo.liinfsyms[idx]
      else:
        return None
  return SolverInfo
mosek_fusion_SolverInfo=__mk_mosek_fusion_SolverInfo()
def __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4PSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedConstraint)
def __arg_alt_match_Lmosek_4fusion_4RangedConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Variable) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Variable_2__)
def __arg_match_LSystem_4DataStream_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4DataStream_2__(v):
  return __arg_match_LSystem_4DataStream_2__(v)
def __arg_match_I__(v):
  return isinstance(v,numpy.int32) or isinstance(v,numpy.int64) or isinstance(v,int)
def __arg_alt_match_I__(v):
  return __arg_match_I__(v)
def __arg_match_D__(v):
  return isinstance(v,numpy.float64) or isinstance(v,float) or isinstance(v,int) or isinstance(v,numpy.int32) or isinstance(v,numpy.int64)
def __arg_alt_match_D__(v):
  return __arg_match_D__(v)
def __arg_match_Lmosek_4fusion_4BaseExpression_2__(v):
  return v is None or isinstance(v,mosek_fusion_BaseExpression)
def __arg_alt_match_Lmosek_4fusion_4BaseExpression_2__(v):
  return __arg_match_Lmosek_4fusion_4BaseExpression_2__(v)
def __arg_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_alt_match_Emosek_4fusion_4PSDKey_2__(v):
  return isinstance(v,mosek_fusion_PSDKey)
def __arg_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_alt_match_Emosek_4fusion_4SolutionType_2__(v):
  return isinstance(v,mosek_fusion_SolutionType)
def __arg_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangedVariable)
def __arg_alt_match_Lmosek_4fusion_4RangedVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4RangedVariable_2__(v)
def __arg_match__3Lmosek_4fusion_4Term_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Term) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Term_2__(v):
  return __arg_match__3Lmosek_4fusion_4Term_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Term_2__)
def __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return v is None or isinstance(v,mosek_fusion_NDSparseArray)
def __arg_alt_match_Lmosek_4fusion_4NDSparseArray_2__(v):
  return __arg_match_Lmosek_4fusion_4NDSparseArray_2__(v)
def __arg_match_Lmosek_4fusion_4SliceConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_SliceConstraint)
def __arg_alt_match_Lmosek_4fusion_4SliceConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4SliceConstraint_2__(v)
def __arg_match_Emosek_4fusion_4ProblemStatus_2__(v):
  return isinstance(v,mosek_fusion_ProblemStatus)
def __arg_alt_match_Emosek_4fusion_4ProblemStatus_2__(v):
  return isinstance(v,mosek_fusion_ProblemStatus)
def __arg_match__3_3D__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3D__(i) for i in v.flatten()])
def __arg_alt_match__3_3D__(v):
  return __arg_match__3_3D__(v) or __arg_match_listof__(v,__arg_alt_match__3D__)
def __arg_match_Lmosek_4fusion_4DJCDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_DJCDomain)
def __arg_alt_match_Lmosek_4fusion_4DJCDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4DJCDomain_2__(v)
def __arg_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelVariable)
def __arg_alt_match_Lmosek_4fusion_4ModelVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelVariable_2__(v)
def __arg_match_Lmosek_4fusion_4LinkedBlocks_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinkedBlocks)
def __arg_alt_match_Lmosek_4fusion_4LinkedBlocks_2__(v):
  return __arg_match_Lmosek_4fusion_4LinkedBlocks_2__(v)
def __arg_match__3_3Lmosek_4fusion_4Parameter_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Parameter_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Parameter_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Parameter_2__)
def __arg_match_Lmosek_4fusion_4SliceVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_SliceVariable)
def __arg_alt_match_Lmosek_4fusion_4SliceVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4SliceVariable_2__(v)
def __arg_match__3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Expression) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Expression_2__)
def __arg_match_J__(v):
  return isinstance(v,numpy.int64) or isinstance(v,int) or isinstance(v,numpy.int32)
def __arg_alt_match_J__(v):
  return __arg_match_J__(v)
def __arg_match_Lmosek_4fusion_4Constraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_Constraint)
def __arg_alt_match_Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match_Lmosek_4fusion_4Constraint_2__(v)
def __arg_match__3J__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int64))
def __arg_alt_match__3J__(v):
  return __arg_match__3J__(v) or __arg_match_listof__(v,__arg_alt_match_J__)
def __arg_match__3_3J__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3J__(i) for i in v.flatten()])
def __arg_alt_match__3_3J__(v):
  return __arg_match__3_3J__(v) or __arg_match_listof__(v,__arg_alt_match__3J__)
def __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearPSDVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearPSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearPSDVariable_2__(v)
def __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_SymmetricMatrix)
def __arg_alt_match_Lmosek_4fusion_4SymmetricMatrix_2__(v):
  return __arg_match_Lmosek_4fusion_4SymmetricMatrix_2__(v)
def __arg_match__3D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3D__(v):
  return __arg_match__3D__(v) or __arg_match_listof__(v,__arg_alt_match_D__)
def __arg_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicVariable)
def __arg_alt_match_Lmosek_4fusion_4ConicVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicVariable_2__(v)
def __arg_match__3I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3I__(v):
  return __arg_match__3I__(v) or __arg_match_listof__(v,__arg_alt_match_I__) or isinstance(v,range)
def __arg_match__3_5D__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.float64))
def __arg_alt_match__3_5D__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_D__,2)
def __arg_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearVariable)
def __arg_alt_match_Lmosek_4fusion_4LinearVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearVariable_2__(v)
def __arg_match__3Lmosek_4fusion_4Model_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Model) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Model_2__(v):
  return __arg_match__3Lmosek_4fusion_4Model_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Model_2__)
def __arg_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_RangeDomain)
def __arg_alt_match_Lmosek_4fusion_4RangeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4RangeDomain_2__(v)
def __arg_match_LSystem_4StreamWriter_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4StreamWriter_2__(v):
  return __arg_match_LSystem_4StreamWriter_2__(v)
def __arg_match_Lmosek_4fusion_4RowBlockManager_2__(v):
  return v is None or isinstance(v,mosek_fusion_RowBlockManager)
def __arg_alt_match_Lmosek_4fusion_4RowBlockManager_2__(v):
  return __arg_match_Lmosek_4fusion_4RowBlockManager_2__(v)
def __arg_match__3S__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == object and all([isinstance(i0,str) for i0 in v ])
def __arg_alt_match__3S__(v):
  return __arg_match__3S__(v) or __arg_match_listof__(v,__arg_alt_match_S__)
def __arg_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDDomain)
def __arg_alt_match_Lmosek_4fusion_4PSDDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDDomain_2__(v)
def __arg_match__3_5I__(v):
  return v is None or (isinstance(v,numpy.ndarray) and v.ndim == 2 and v.dtype == numpy.dtype(numpy.int32))
def __arg_alt_match__3_5I__(v):
  return _monty.arg_match_sloppy_array(v,__arg_alt_match_I__,2)
def __arg_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearDomain)
def __arg_alt_match_Lmosek_4fusion_4LinearDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearDomain_2__(v)
def __arg_match_Lmosek_4fusion_4LinkedInts_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinkedInts)
def __arg_alt_match_Lmosek_4fusion_4LinkedInts_2__(v):
  return __arg_match_Lmosek_4fusion_4LinkedInts_2__(v)
def __arg_match_Emosek_4fusion_4DJCDomainType_2__(v):
  return isinstance(v,mosek_fusion_DJCDomainType)
def __arg_alt_match_Emosek_4fusion_4DJCDomainType_2__(v):
  return isinstance(v,mosek_fusion_DJCDomainType)
def __arg_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_alt_match_Emosek_4fusion_4SolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_SolutionStatus)
def __arg_match_LSystem_4CallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4CallbackHandler_2__(v):
  return __arg_match_LSystem_4CallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4Matrix_2__(v):
  return v is None or isinstance(v,mosek_fusion_Matrix)
def __arg_alt_match_Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match_Lmosek_4fusion_4Matrix_2__(v)
def __arg_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_alt_match_Emosek_4fusion_4AccSolutionStatus_2__(v):
  return isinstance(v,mosek_fusion_AccSolutionStatus)
def __arg_match__3Lmosek_4fusion_4Constraint_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Constraint) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Constraint_2__(v):
  return __arg_match__3Lmosek_4fusion_4Constraint_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Constraint_2__)
def __arg_match_Lmosek_4fusion_4Parameter_2__(v):
  return v is None or isinstance(v,mosek_fusion_Parameter)
def __arg_alt_match_Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match_Lmosek_4fusion_4Parameter_2__(v)
def __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ModelConstraint)
def __arg_alt_match_Lmosek_4fusion_4ModelConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ModelConstraint_2__(v)
def __arg_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_PSDVariable)
def __arg_alt_match_Lmosek_4fusion_4PSDVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4PSDVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Term_2__(v):
  return v is None or isinstance(v,mosek_fusion_Term)
def __arg_alt_match_Lmosek_4fusion_4Term_2__(v):
  return __arg_match_Lmosek_4fusion_4Term_2__(v)
def __arg_match__3_3S__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3S__(i) for i in v.flatten()])
def __arg_alt_match__3_3S__(v):
  return __arg_match__3_3S__(v) or __arg_match_listof__(v,__arg_alt_match__3S__)
def __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return v is None or isinstance(v,mosek_fusion_Utils_StringBuffer)
def __arg_alt_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v):
  return __arg_match_Lmosek_4fusion_4Utils_4StringBuffer_2__(v)
def __arg_match__3_3I__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3I__(i) for i in v.flatten()])
def __arg_alt_match__3_3I__(v):
  return __arg_match__3_3I__(v) or __arg_match_listof__(v,__arg_alt_match__3I__)
def __arg_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return v is None or isinstance(v,mosek_fusion_BaseVariable)
def __arg_alt_match_Lmosek_4fusion_4BaseVariable_2__(v):
  return __arg_match_Lmosek_4fusion_4BaseVariable_2__(v)
def __arg_match_Lmosek_4fusion_4Model_2__(v):
  return v is None or isinstance(v,mosek_fusion_Model)
def __arg_alt_match_Lmosek_4fusion_4Model_2__(v):
  return __arg_match_Lmosek_4fusion_4Model_2__(v)
def __arg_match_Lmosek_4fusion_4FusionException_2__(v):
  return v is None or isinstance(v,mosek_fusion_FusionException)
def __arg_alt_match_Lmosek_4fusion_4FusionException_2__(v):
  return __arg_match_Lmosek_4fusion_4FusionException_2__(v)
def __arg_match_Lmosek_4fusion_4ParameterImpl_2__(v):
  return v is None or isinstance(v,mosek_fusion_ParameterImpl)
def __arg_alt_match_Lmosek_4fusion_4ParameterImpl_2__(v):
  return __arg_match_Lmosek_4fusion_4ParameterImpl_2__(v)
def __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return v is None or isinstance(v,mosek_fusion_SolutionStruct)
def __arg_alt_match_Lmosek_4fusion_4SolutionStruct_2__(v):
  return __arg_match_Lmosek_4fusion_4SolutionStruct_2__(v)
def __arg_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_alt_match_Emosek_4fusion_4RelationKey_2__(v):
  return isinstance(v,mosek_fusion_RelationKey)
def __arg_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Expression_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Expression_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Expression_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Expression_2__)
def __arg_match__3Lmosek_4fusion_4Parameter_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Parameter) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Parameter_2__(v):
  return __arg_match__3Lmosek_4fusion_4Parameter_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Parameter_2__)
def __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Matrix_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_LinearConstraint)
def __arg_alt_match_Lmosek_4fusion_4LinearConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4LinearConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4SimpleTerm_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_SimpleTerm) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4SimpleTerm_2__(v):
  return __arg_match__3Lmosek_4fusion_4SimpleTerm_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__)
def __arg_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_alt_match_Emosek_4fusion_4QConeKey_2__(v):
  return isinstance(v,mosek_fusion_QConeKey)
def __arg_match_Lmosek_4fusion_4SimpleTerm_2__(v):
  return v is None or isinstance(v,mosek_fusion_SimpleTerm)
def __arg_alt_match_Lmosek_4fusion_4SimpleTerm_2__(v):
  return __arg_match_Lmosek_4fusion_4SimpleTerm_2__(v)
def __arg_match_Lmosek_4fusion_4Variable_2__(v):
  return v is None or isinstance(v,mosek_fusion_Variable)
def __arg_alt_match_Lmosek_4fusion_4Variable_2__(v):
  return __arg_match_Lmosek_4fusion_4Variable_2__(v)
def __arg_match_LSystem_4DataCallbackHandler_2__(v):
  return v is None or isinstance(v,object)
def __arg_alt_match_LSystem_4DataCallbackHandler_2__(v):
  return __arg_match_LSystem_4DataCallbackHandler_2__(v)
def __arg_match_Lmosek_4fusion_4Expression_2__(v):
  return v is None or isinstance(v,mosek_fusion_Expression)
def __arg_alt_match_Lmosek_4fusion_4Expression_2__(v):
  return __arg_match_Lmosek_4fusion_4Expression_2__(v)
def __arg_match_Lmosek_4fusion_4WorkStack_2__(v):
  return v is None or isinstance(v,mosek_fusion_WorkStack)
def __arg_alt_match_Lmosek_4fusion_4WorkStack_2__(v):
  return __arg_match_Lmosek_4fusion_4WorkStack_2__(v)
def __arg_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_alt_match_Emosek_4fusion_4ObjectiveSense_2__(v):
  return isinstance(v,mosek_fusion_ObjectiveSense)
def __arg_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([__arg_match__3Lmosek_4fusion_4Variable_2__(i) for i in v.flatten()])
def __arg_alt_match__3_3Lmosek_4fusion_4Variable_2__(v):
  return __arg_match__3_3Lmosek_4fusion_4Variable_2__(v) or __arg_match_listof__(v,__arg_alt_match__3Lmosek_4fusion_4Variable_2__)
def __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConicConstraint)
def __arg_alt_match_Lmosek_4fusion_4ConicConstraint_2__(v):
  return __arg_match_Lmosek_4fusion_4ConicConstraint_2__(v)
def __arg_match__3Lmosek_4fusion_4Matrix_2__(v):
  return isinstance(v,numpy.ndarray) and v.ndim == 1 and v.dtype == numpy.dtype(object) and all([isinstance(i,mosek_fusion_Matrix) for i in v.flatten()])
def __arg_alt_match__3Lmosek_4fusion_4Matrix_2__(v):
  return __arg_match__3Lmosek_4fusion_4Matrix_2__(v) or __arg_match_listof__(v,__arg_alt_match_Lmosek_4fusion_4Matrix_2__)
def __arg_match_Lmosek_4fusion_4ConeDomain_2__(v):
  return v is None or isinstance(v,mosek_fusion_ConeDomain)
def __arg_alt_match_Lmosek_4fusion_4ConeDomain_2__(v):
  return __arg_match_Lmosek_4fusion_4ConeDomain_2__(v)
def __arg_match_Z__(v):
  return isinstance(v,bool) or isinstance(v,numpy.bool_)
def __arg_alt_match_Z__(v):
  return __arg_match_Z__(v)
def __arg_match_S__(v):
  return isinstance(v,str)
def __arg_alt_match_S__(v):
  return __arg_match_S__(v)
def __arg_match_listof__(v,f): return isinstance(v,list) and all([ f(i) for i in v])
import mosek
import mosek.fusion
import mosek.fusion.Utils
from . import fragments
